import {
  EMPTY_OBJ,
  NO,
  NOOP,
  PatchFlagNames,
  camelize,
  capitalize,
  extend,
  generateCodeFrame,
  init_runtime_dom_esm_bundler,
  init_shared_esm_bundler,
  isArray,
  isBuiltInDirective,
  isHTMLTag,
  isMathMLTag,
  isObject,
  isOn,
  isReservedProp,
  isSVGTag,
  isString,
  isSymbol,
  isVoidTag,
  makeMap,
  parseStringStyle,
  runtime_dom_esm_bundler_exports,
  shared_esm_bundler_exports,
  slotFlagsText,
  toHandlerKey
} from "./chunk-CCQ2HDKQ.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-WXXH56N5.js";

// node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach((s) => {
    helperNameMap[s] = helpers[s];
  });
}
function createRoot(children, source = "") {
  return {
    type: 0,
    source,
    children,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: locStub
  };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
    } else {
      context.helper(getVNodeHelper(context.inSSR, isComponent2));
    }
    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }
  return {
    type: 13,
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2,
    loc
  };
}
function createArrayExpression(elements, loc = locStub) {
  return {
    type: 17,
    loc,
    elements
  };
}
function createObjectExpression(properties, loc = locStub) {
  return {
    type: 15,
    loc,
    properties
  };
}
function createObjectProperty(key, value) {
  return {
    type: 16,
    loc: locStub,
    key: isString(key) ? createSimpleExpression(key, true) : key,
    value
  };
}
function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
  return {
    type: 4,
    loc,
    content,
    isStatic,
    constType: isStatic ? 3 : constType
  };
}
function createInterpolation(content, loc) {
  return {
    type: 5,
    loc,
    content: isString(content) ? createSimpleExpression(content, false, loc) : content
  };
}
function createCompoundExpression(children, loc = locStub) {
  return {
    type: 8,
    loc,
    children
  };
}
function createCallExpression(callee, args = [], loc = locStub) {
  return {
    type: 14,
    loc,
    callee,
    arguments: args
  };
}
function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
  return {
    type: 18,
    params,
    returns,
    newline,
    isSlot,
    loc
  };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
  return {
    type: 19,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  };
}
function createCacheExpression(index, value, isVNode = false) {
  return {
    type: 20,
    index,
    value,
    isVNode,
    loc: locStub
  };
}
function createBlockStatement(body) {
  return {
    type: 21,
    body,
    loc: locStub
  };
}
function createTemplateLiteral(elements) {
  return {
    type: 22,
    elements,
    loc: locStub
  };
}
function createIfStatement(test, consequent, alternate) {
  return {
    type: 23,
    test,
    consequent,
    alternate,
    loc: locStub
  };
}
function createAssignmentExpression(left, right) {
  return {
    type: 24,
    left,
    right,
    loc: locStub
  };
}
function createSequenceExpression(expressions) {
  return {
    type: 25,
    expressions,
    loc: locStub
  };
}
function createReturnStatement(returns) {
  return {
    type: 26,
    returns,
    loc: locStub
  };
}
function getVNodeHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
}
function getVNodeBlockHelper(ssr, isComponent2) {
  return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
}
function convertToBlock(node, { helper, removeHelper, inSSR }) {
  if (!node.isBlock) {
    node.isBlock = true;
    removeHelper(getVNodeHelper(inSSR, node.isComponent));
    helper(OPEN_BLOCK);
    helper(getVNodeBlockHelper(inSSR, node.isComponent));
  }
}
function isTagStartChar(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function isWhitespace(c) {
  return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
}
function isEndOfTagSection(c) {
  return c === 47 || c === 62 || isWhitespace(c);
}
function toCharCodes(str) {
  const ret = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    ret[i] = str.charCodeAt(i);
  }
  return ret;
}
function getCompatValue(key, { compatConfig }) {
  const value = compatConfig && compatConfig[key];
  if (key === "MODE") {
    return value || 3;
  } else {
    return value;
  }
}
function isCompatEnabled(key, context) {
  const mode = getCompatValue("MODE", context);
  const value = getCompatValue(key, context);
  return mode === 3 ? value === true : value !== false;
}
function checkCompatEnabled(key, context, loc, ...args) {
  const enabled = isCompatEnabled(key, context);
  if (enabled) {
    warnDeprecation(key, context, loc, ...args);
  }
  return enabled;
}
function warnDeprecation(key, context, loc, ...args) {
  const val = getCompatValue(key, context);
  if (val === "suppress-warning") {
    return;
  }
  const { message, link } = deprecationData[key];
  const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
  const err = new SyntaxError(msg);
  err.code = key;
  if (loc)
    err.loc = loc;
  context.onWarn(err);
}
function defaultOnError(error) {
  throw error;
}
function defaultOnWarn(msg) {
  console.warn(`[Vue warn] ${msg.message}`);
}
function createCompilerError(code, loc, messages, additionalMessage) {
  const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : `https://vuejs.org/error-reference/#compiler-${code}`;
  const error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}
function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
  {
    return;
  }
}
function isReferencedIdentifier(id, parent, parentStack) {
  {
    return false;
  }
}
function isInDestructureAssignment(parent, parentStack) {
  if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
    let i = parentStack.length;
    while (i--) {
      const p = parentStack[i];
      if (p.type === "AssignmentExpression") {
        return true;
      } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
        break;
      }
    }
  }
  return false;
}
function isInNewExpression(parentStack) {
  let i = parentStack.length;
  while (i--) {
    const p = parentStack[i];
    if (p.type === "NewExpression") {
      return true;
    } else if (p.type !== "MemberExpression") {
      break;
    }
  }
  return false;
}
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function walkBlockDeclarations(block, onIdent) {
  for (const stmt of block.body) {
    if (stmt.type === "VariableDeclaration") {
      if (stmt.declare)
        continue;
      for (const decl of stmt.declarations) {
        for (const id of extractIdentifiers(decl.id)) {
          onIdent(id);
        }
      }
    } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
      if (stmt.declare || !stmt.id)
        continue;
      onIdent(stmt.id);
    } else if (stmt.type === "ForOfStatement" || stmt.type === "ForInStatement" || stmt.type === "ForStatement") {
      const variable = stmt.type === "ForStatement" ? stmt.init : stmt.left;
      if (variable && variable.type === "VariableDeclaration") {
        for (const decl of variable.declarations) {
          for (const id of extractIdentifiers(decl.id)) {
            onIdent(id);
          }
        }
      }
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}
function unwrapTSNode(node) {
  if (TS_NODE_TYPES.includes(node.type)) {
    return unwrapTSNode(node.expression);
  } else {
    return node;
  }
}
function isCoreComponent(tag) {
  switch (tag) {
    case "Teleport":
    case "teleport":
      return TELEPORT;
    case "Suspense":
    case "suspense":
      return SUSPENSE;
    case "KeepAlive":
    case "keep-alive":
      return KEEP_ALIVE;
    case "BaseTransition":
    case "base-transition":
      return BASE_TRANSITION;
  }
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
  return advancePositionWithMutation(
    {
      offset: pos.offset,
      line: pos.line,
      column: pos.column
    },
    source,
    numberOfCharacters
  );
}
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
  let linesCount = 0;
  let lastNewLinePos = -1;
  for (let i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10) {
      linesCount++;
      lastNewLinePos = i;
    }
  }
  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg || `unexpected compiler condition`);
  }
}
function findDir(node, name, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 7 && (allowEmpty || p.exp) && (isString(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (dynamicOnly)
        continue;
      if (p.name === name && (p.value || allowEmpty)) {
        return p;
      }
    } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
      return p;
    }
  }
}
function isStaticArgOf(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}
function hasDynamicKeyVBind(node) {
  return node.props.some(
    (p) => p.type === 7 && p.name === "bind" && (!p.arg || // v-bind="obj"
    p.arg.type !== 4 || // v-bind:[_ctx.foo]
    !p.arg.isStatic)
    // v-bind:[foo]
  );
}
function isText$1(node) {
  return node.type === 5 || node.type === 2;
}
function isVSlot(p) {
  return p.type === 7 && p.name === "slot";
}
function isTemplateNode(node) {
  return node.type === 1 && node.tagType === 3;
}
function isSlotOutlet(node) {
  return node.type === 1 && node.tagType === 2;
}
function getUnnormalizedProps(props, callPath = []) {
  if (props && !isString(props) && props.type === 14) {
    const callee = props.callee;
    if (!isString(callee) && propsHelperSet.has(callee)) {
      return getUnnormalizedProps(
        props.arguments[0],
        callPath.concat(props)
      );
    }
  }
  return [props, callPath];
}
function injectProp(node, prop, context) {
  let propsWithInjection;
  let props = node.type === 13 ? node.props : node.arguments[2];
  let callPath = [];
  let parentCall;
  if (props && !isString(props) && props.type === 14) {
    const ret = getUnnormalizedProps(props);
    props = ret[0];
    callPath = ret[1];
    parentCall = callPath[callPath.length - 1];
  }
  if (props == null || isString(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14) {
    const first = props.arguments[0];
    if (!isString(first) && first.type === 15) {
      if (!hasProp(prop, first)) {
        first.properties.unshift(prop);
      }
    } else {
      if (props.callee === TO_HANDLERS) {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
      } else {
        props.arguments.unshift(createObjectExpression([prop]));
      }
    }
    !propsWithInjection && (propsWithInjection = props);
  } else if (props.type === 15) {
    if (!hasProp(prop, props)) {
      props.properties.unshift(prop);
    }
    propsWithInjection = props;
  } else {
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
      createObjectExpression([prop]),
      props
    ]);
    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
      parentCall = callPath[callPath.length - 2];
    }
  }
  if (node.type === 13) {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.props = propsWithInjection;
    }
  } else {
    if (parentCall) {
      parentCall.arguments[0] = propsWithInjection;
    } else {
      node.arguments[2] = propsWithInjection;
    }
  }
}
function hasProp(prop, props) {
  let result = false;
  if (prop.key.type === 4) {
    const propKeyName = prop.key.content;
    result = props.properties.some(
      (p) => p.key.type === 4 && p.key.content === propKeyName
    );
  }
  return result;
}
function toValidAssetId(name, type) {
  return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
    return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
  })}`;
}
function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }
  switch (node.type) {
    case 1:
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 11:
      if (hasScopeRef(node.source, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 9:
      return node.branches.some((b) => hasScopeRef(b, ids));
    case 10:
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }
      return node.children.some((c) => hasScopeRef(c, ids));
    case 4:
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
    case 8:
      return node.children.some((c) => isObject(c) && hasScopeRef(c, ids));
    case 5:
    case 12:
      return hasScopeRef(node.content, ids);
    case 2:
    case 3:
      return false;
    default:
      if (true)
        ;
      return false;
  }
}
function getMemoedVNodeCall(node) {
  if (node.type === 14 && node.callee === WITH_MEMO) {
    return node.arguments[1].returns;
  } else {
    return node;
  }
}
function parseForExpression(input) {
  const loc = input.loc;
  const exp = input.content;
  const inMatch = exp.match(forAliasRE);
  if (!inMatch)
    return;
  const [, LHS, RHS] = inMatch;
  const createAliasExpression = (content, offset, asParam = false) => {
    const start = loc.start.offset + offset;
    const end = start + content.length;
    return createExp(
      content,
      false,
      getLoc(start, end),
      0,
      asParam ? 1 : 0
      /* Normal */
    );
  };
  const result = {
    source: createAliasExpression(RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: void 0,
    key: void 0,
    index: void 0,
    finalized: false
  };
  let valueContent = LHS.trim().replace(stripParensRE, "").trim();
  const trimmedOffset = LHS.indexOf(valueContent);
  const iteratorMatch = valueContent.match(forIteratorRE);
  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, "").trim();
    const keyContent = iteratorMatch[1].trim();
    let keyOffset;
    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(keyContent, keyOffset, true);
    }
    if (iteratorMatch[2]) {
      const indexContent = iteratorMatch[2].trim();
      if (indexContent) {
        result.index = createAliasExpression(
          indexContent,
          exp.indexOf(
            indexContent,
            result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length
          ),
          true
        );
      }
    }
  }
  if (valueContent) {
    result.value = createAliasExpression(valueContent, trimmedOffset, true);
  }
  return result;
}
function getSlice(start, end) {
  return currentInput.slice(start, end);
}
function endOpenTag(end) {
  if (tokenizer.inSFCRoot) {
    currentOpenTag.innerLoc = getLoc(end + 1, end + 1);
  }
  addNode(currentOpenTag);
  const { tag, ns } = currentOpenTag;
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre++;
  }
  if (currentOptions.isVoidTag(tag)) {
    onCloseTag(currentOpenTag, end);
  } else {
    stack.unshift(currentOpenTag);
    if (ns === 1 || ns === 2) {
      tokenizer.inXML = true;
    }
  }
  currentOpenTag = null;
}
function onText(content, start, end) {
  {
    const tag = stack[0] && stack[0].tag;
    if (tag !== "script" && tag !== "style" && content.includes("&")) {
      content = currentOptions.decodeEntities(content, false);
    }
  }
  const parent = stack[0] || currentRoot;
  const lastNode = parent.children[parent.children.length - 1];
  if (lastNode && lastNode.type === 2) {
    lastNode.content += content;
    setLocEnd(lastNode.loc, end);
  } else {
    parent.children.push({
      type: 2,
      content,
      loc: getLoc(start, end)
    });
  }
}
function onCloseTag(el, end, isImplied = false) {
  if (isImplied) {
    setLocEnd(el.loc, backTrack(end, 60));
  } else {
    setLocEnd(el.loc, lookAhead(end, 62) + 1);
  }
  if (tokenizer.inSFCRoot) {
    if (el.children.length) {
      el.innerLoc.end = extend({}, el.children[el.children.length - 1].loc.end);
    } else {
      el.innerLoc.end = extend({}, el.innerLoc.start);
    }
    el.innerLoc.source = getSlice(
      el.innerLoc.start.offset,
      el.innerLoc.end.offset
    );
  }
  const { tag, ns } = el;
  if (!inVPre) {
    if (tag === "slot") {
      el.tagType = 2;
    } else if (isFragmentTemplate(el)) {
      el.tagType = 3;
    } else if (isComponent(el)) {
      el.tagType = 1;
    }
  }
  if (!tokenizer.inRCDATA) {
    el.children = condenseWhitespace(el.children, el.tag);
  }
  if (ns === 0 && currentOptions.isPreTag(tag)) {
    inPre--;
  }
  if (currentVPreBoundary === el) {
    inVPre = tokenizer.inVPre = false;
    currentVPreBoundary = null;
  }
  if (tokenizer.inXML && (stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
    tokenizer.inXML = false;
  }
  {
    const props = el.props;
    if (isCompatEnabled(
      "COMPILER_V_IF_V_FOR_PRECEDENCE",
      currentOptions
    )) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 7) {
          if (p.name === "if") {
            hasIf = true;
          } else if (p.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation(
            "COMPILER_V_IF_V_FOR_PRECEDENCE",
            currentOptions,
            el.loc
          );
          break;
        }
      }
    }
    if (!tokenizer.inSFCRoot && isCompatEnabled(
      "COMPILER_NATIVE_TEMPLATE",
      currentOptions
    ) && el.tag === "template" && !isFragmentTemplate(el)) {
      warnDeprecation(
        "COMPILER_NATIVE_TEMPLATE",
        currentOptions,
        el.loc
      );
      const parent = stack[0] || currentRoot;
      const index = parent.children.indexOf(el);
      parent.children.splice(index, 1, ...el.children);
    }
    const inlineTemplateProp = props.find(
      (p) => p.type === 6 && p.name === "inline-template"
    );
    if (inlineTemplateProp && checkCompatEnabled(
      "COMPILER_INLINE_TEMPLATE",
      currentOptions,
      inlineTemplateProp.loc
    ) && el.children.length) {
      inlineTemplateProp.value = {
        type: 2,
        content: getSlice(
          el.children[0].loc.start.offset,
          el.children[el.children.length - 1].loc.end.offset
        ),
        loc: inlineTemplateProp.loc
      };
    }
  }
}
function lookAhead(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i < currentInput.length - 1)
    i++;
  return i;
}
function backTrack(index, c) {
  let i = index;
  while (currentInput.charCodeAt(i) !== c && i >= 0)
    i--;
  return i;
}
function isFragmentTemplate({ tag, props }) {
  if (tag === "template") {
    for (let i = 0; i < props.length; i++) {
      if (props[i].type === 7 && specialTemplateDir.has(props[i].name)) {
        return true;
      }
    }
  }
  return false;
}
function isComponent({ tag, props }) {
  if (currentOptions.isCustomElement(tag)) {
    return false;
  }
  if (tag === "component" || isUpperCase(tag.charCodeAt(0)) || isCoreComponent(tag) || currentOptions.isBuiltInComponent && currentOptions.isBuiltInComponent(tag) || currentOptions.isNativeTag && !currentOptions.isNativeTag(tag)) {
    return true;
  }
  for (let i = 0; i < props.length; i++) {
    const p = props[i];
    if (p.type === 6) {
      if (p.name === "is" && p.value) {
        if (p.value.content.startsWith("vue:")) {
          return true;
        } else if (checkCompatEnabled(
          "COMPILER_IS_ON_ELEMENT",
          currentOptions,
          p.loc
        )) {
          return true;
        }
      }
    } else if (
      // :is on plain element - only treat as component in compat mode
      p.name === "bind" && isStaticArgOf(p.arg, "is") && checkCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        currentOptions,
        p.loc
      )
    ) {
      return true;
    }
  }
  return false;
}
function isUpperCase(c) {
  return c > 64 && c < 91;
}
function condenseWhitespace(nodes, tag) {
  const shouldCondense = currentOptions.whitespace !== "preserve";
  let removedWhitespace = false;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === 2) {
      if (!inPre) {
        if (isAllWhitespace(node.content)) {
          const prev = nodes[i - 1] && nodes[i - 1].type;
          const next = nodes[i + 1] && nodes[i + 1].type;
          if (!prev || !next || shouldCondense && (prev === 3 && (next === 3 || next === 1) || prev === 1 && (next === 3 || next === 1 && hasNewlineChar(node.content)))) {
            removedWhitespace = true;
            nodes[i] = null;
          } else {
            node.content = " ";
          }
        } else if (shouldCondense) {
          node.content = condense(node.content);
        }
      } else {
        node.content = node.content.replace(windowsNewlineRE, "\n");
      }
    }
  }
  if (inPre && tag && currentOptions.isPreTag(tag)) {
    const first = nodes[0];
    if (first && first.type === 2) {
      first.content = first.content.replace(/^\r?\n/, "");
    }
  }
  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function isAllWhitespace(str) {
  for (let i = 0; i < str.length; i++) {
    if (!isWhitespace(str.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function hasNewlineChar(str) {
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c === 10 || c === 13) {
      return true;
    }
  }
  return false;
}
function condense(str) {
  let ret = "";
  let prevCharIsWhitespace = false;
  for (let i = 0; i < str.length; i++) {
    if (isWhitespace(str.charCodeAt(i))) {
      if (!prevCharIsWhitespace) {
        ret += " ";
        prevCharIsWhitespace = true;
      }
    } else {
      ret += str[i];
      prevCharIsWhitespace = false;
    }
  }
  return ret;
}
function addNode(node) {
  (stack[0] || currentRoot).children.push(node);
}
function getLoc(start, end) {
  return {
    start: tokenizer.getPos(start),
    // @ts-expect-error allow late attachment
    end: end == null ? end : tokenizer.getPos(end),
    // @ts-expect-error allow late attachment
    source: end == null ? end : getSlice(start, end)
  };
}
function setLocEnd(loc, end) {
  loc.end = tokenizer.getPos(end);
  loc.source = getSlice(loc.start.offset, end);
}
function dirToAttr(dir) {
  const attr = {
    type: 6,
    name: dir.rawName,
    nameLoc: getLoc(
      dir.loc.start.offset,
      dir.loc.start.offset + dir.rawName.length
    ),
    value: void 0,
    loc: dir.loc
  };
  if (dir.exp) {
    const loc = dir.exp.loc;
    if (loc.end.offset < dir.loc.end.offset) {
      loc.start.offset--;
      loc.start.column--;
      loc.end.offset++;
      loc.end.column++;
    }
    attr.value = {
      type: 2,
      content: dir.exp.content,
      loc
    };
  }
  return attr;
}
function createExp(content, isStatic = false, loc, constType = 0, parseMode = 0) {
  const exp = createSimpleExpression(content, isStatic, loc, constType);
  return exp;
}
function emitError(code, index, message) {
  currentOptions.onError(
    createCompilerError(code, getLoc(index, index), void 0, message)
  );
}
function reset() {
  tokenizer.reset();
  currentOpenTag = null;
  currentProp = null;
  currentAttrValue = "";
  currentAttrStartIndex = -1;
  currentAttrEndIndex = -1;
  stack.length = 0;
}
function baseParse(input, options) {
  reset();
  currentInput = input;
  currentOptions = extend({}, defaultParserOptions);
  if (options) {
    let key;
    for (key in options) {
      if (options[key] != null) {
        currentOptions[key] = options[key];
      }
    }
  }
  if (true) {
    if (!currentOptions.decodeEntities) {
      throw new Error(
        `[@vue/compiler-core] decodeEntities option is required in browser builds.`
      );
    }
  }
  tokenizer.mode = currentOptions.parseMode === "html" ? 1 : currentOptions.parseMode === "sfc" ? 2 : 0;
  tokenizer.inXML = currentOptions.ns === 1 || currentOptions.ns === 2;
  const delimiters = options && options.delimiters;
  if (delimiters) {
    tokenizer.delimiterOpen = toCharCodes(delimiters[0]);
    tokenizer.delimiterClose = toCharCodes(delimiters[1]);
  }
  const root = currentRoot = createRoot([], input);
  tokenizer.parse(currentInput);
  root.loc = getLoc(0, input.length);
  root.children = condenseWhitespace(root.children);
  currentRoot = null;
  return root;
}
function hoistStatic(root, context) {
  walk(
    root,
    context,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0])
  );
}
function isSingleElementRoot(root, child) {
  const { children } = root;
  return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
}
function walk(node, context, doNotHoistNode = false) {
  const { children } = node;
  const originalCount = children.length;
  let hoistedCount = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.type === 1 && child.tagType === 0) {
      const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
      if (constantType > 0) {
        if (constantType >= 2) {
          child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
          continue;
        }
      } else {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          const flag = getPatchFlag(codegenNode);
          if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
            const props = getNodeProps(child);
            if (props) {
              codegenNode.props = context.hoist(props);
            }
          }
          if (codegenNode.dynamicProps) {
            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
          }
        }
      }
    }
    if (child.type === 1) {
      const isComponent2 = child.tagType === 1;
      if (isComponent2) {
        context.scopes.vSlot++;
      }
      walk(child, context);
      if (isComponent2) {
        context.scopes.vSlot--;
      }
    } else if (child.type === 11) {
      walk(child, context, child.children.length === 1);
    } else if (child.type === 9) {
      for (let i2 = 0; i2 < child.branches.length; i2++) {
        walk(
          child.branches[i2],
          context,
          child.branches[i2].children.length === 1
        );
      }
    }
  }
  if (hoistedCount && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
  if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
    const hoisted = context.hoist(
      createArrayExpression(node.codegenNode.children)
    );
    if (context.hmr) {
      hoisted.content = `[...${hoisted.content}]`;
    }
    node.codegenNode.children = hoisted;
  }
}
function getConstantType(node, context) {
  const { constantCache } = context;
  switch (node.type) {
    case 1:
      if (node.tagType !== 0) {
        return 0;
      }
      const cached = constantCache.get(node);
      if (cached !== void 0) {
        return cached;
      }
      const codegenNode = node.codegenNode;
      if (codegenNode.type !== 13) {
        return 0;
      }
      if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
        return 0;
      }
      const flag = getPatchFlag(codegenNode);
      if (!flag) {
        let returnType2 = 3;
        const generatedPropsType = getGeneratedPropsConstantType(node, context);
        if (generatedPropsType === 0) {
          constantCache.set(node, 0);
          return 0;
        }
        if (generatedPropsType < returnType2) {
          returnType2 = generatedPropsType;
        }
        for (let i = 0; i < node.children.length; i++) {
          const childType = getConstantType(node.children[i], context);
          if (childType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (childType < returnType2) {
            returnType2 = childType;
          }
        }
        if (returnType2 > 1) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && p.name === "bind" && p.exp) {
              const expType = getConstantType(p.exp, context);
              if (expType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (expType < returnType2) {
                returnType2 = expType;
              }
            }
          }
        }
        if (codegenNode.isBlock) {
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7) {
              constantCache.set(node, 0);
              return 0;
            }
          }
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(
            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)
          );
          codegenNode.isBlock = false;
          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
        }
        constantCache.set(node, returnType2);
        return returnType2;
      } else {
        constantCache.set(node, 0);
        return 0;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return getConstantType(node.content, context);
    case 4:
      return node.constType;
    case 8:
      let returnType = 3;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (isString(child) || isSymbol(child)) {
          continue;
        }
        const childType = getConstantType(child, context);
        if (childType === 0) {
          return 0;
        } else if (childType < returnType) {
          returnType = childType;
        }
      }
      return returnType;
    default:
      if (true)
        ;
      return 0;
  }
}
function getConstantTypeOfHelperCall(value, context) {
  if (value.type === 14 && !isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
    const arg = value.arguments[0];
    if (arg.type === 4) {
      return getConstantType(arg, context);
    } else if (arg.type === 14) {
      return getConstantTypeOfHelperCall(arg, context);
    }
  }
  return 0;
}
function getGeneratedPropsConstantType(node, context) {
  let returnType = 3;
  const props = getNodeProps(node);
  if (props && props.type === 15) {
    const { properties } = props;
    for (let i = 0; i < properties.length; i++) {
      const { key, value } = properties[i];
      const keyType = getConstantType(key, context);
      if (keyType === 0) {
        return keyType;
      }
      if (keyType < returnType) {
        returnType = keyType;
      }
      let valueType;
      if (value.type === 4) {
        valueType = getConstantType(value, context);
      } else if (value.type === 14) {
        valueType = getConstantTypeOfHelperCall(value, context);
      } else {
        valueType = 0;
      }
      if (valueType === 0) {
        return valueType;
      }
      if (valueType < returnType) {
        returnType = valueType;
      }
    }
  }
  return returnType;
}
function getNodeProps(node) {
  const codegenNode = node.codegenNode;
  if (codegenNode.type === 13) {
    return codegenNode.props;
  }
}
function getPatchFlag(node) {
  const flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : void 0;
}
function createTransformContext(root, {
  filename = "",
  prefixIdentifiers = false,
  hoistStatic: hoistStatic2 = false,
  hmr = false,
  cacheHandlers = false,
  nodeTransforms = [],
  directiveTransforms = {},
  transformHoist = null,
  isBuiltInComponent = NOOP,
  isCustomElement = NOOP,
  expressionPlugins = [],
  scopeId = null,
  slotted = true,
  ssr = false,
  inSSR = false,
  ssrCssVars = ``,
  bindingMetadata = EMPTY_OBJ,
  inline = false,
  isTS = false,
  onError = defaultOnError,
  onWarn = defaultOnWarn,
  compatConfig
}) {
  const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
  const context = {
    // options
    filename,
    selfName: nameMatch && capitalize(camelize(nameMatch[1])),
    prefixIdentifiers,
    hoistStatic: hoistStatic2,
    hmr,
    cacheHandlers,
    nodeTransforms,
    directiveTransforms,
    transformHoist,
    isBuiltInComponent,
    isCustomElement,
    expressionPlugins,
    scopeId,
    slotted,
    ssr,
    inSSR,
    ssrCssVars,
    bindingMetadata,
    inline,
    isTS,
    onError,
    onWarn,
    compatConfig,
    // state
    root,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new WeakMap(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    grandParent: null,
    currentNode: root,
    childIndex: 0,
    inVOnce: false,
    // methods
    helper(name) {
      const count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper(name) {
      const count = context.helpers.get(name);
      if (count) {
        const currentCount = count - 1;
        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString(name) {
      return `_${helperNameMap[context.helper(name)]}`;
    },
    replaceNode(node) {
      if (true) {
        if (!context.currentNode) {
          throw new Error(`Node being replaced is already removed.`);
        }
        if (!context.parent) {
          throw new Error(`Cannot replace root node.`);
        }
      }
      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode(node) {
      if (!context.parent) {
        throw new Error(`Cannot remove root node.`);
      }
      const list = context.parent.children;
      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      if (removalIndex < 0) {
        throw new Error(`node being removed is not a child of current parent`);
      }
      if (!node || node === context.currentNode) {
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }
      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: NOOP,
    addIdentifiers(exp) {
    },
    removeIdentifiers(exp) {
    },
    hoist(exp) {
      if (isString(exp))
        exp = createSimpleExpression(exp);
      context.hoists.push(exp);
      const identifier = createSimpleExpression(
        `_hoisted_${context.hoists.length}`,
        false,
        exp.loc,
        2
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache(exp, isVNode = false) {
      return createCacheExpression(context.cached++, exp, isVNode);
    }
  };
  {
    context.filters = /* @__PURE__ */ new Set();
  }
  return context;
}
function transform(root, options) {
  const context = createTransformContext(root, options);
  traverseNode(root, context);
  if (options.hoistStatic) {
    hoistStatic(root, context);
  }
  if (!options.ssr) {
    createRootCodegen(root, context);
  }
  root.helpers = /* @__PURE__ */ new Set([...context.helpers.keys()]);
  root.components = [...context.components];
  root.directives = [...context.directives];
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  root.transformed = true;
  {
    root.filters = [...context.filters];
  }
}
function createRootCodegen(root, context) {
  const { helper } = context;
  const { children } = root;
  if (children.length === 1) {
    const child = children[0];
    if (isSingleElementRoot(root, child) && child.codegenNode) {
      const codegenNode = child.codegenNode;
      if (codegenNode.type === 13) {
        convertToBlock(codegenNode, context);
      }
      root.codegenNode = codegenNode;
    } else {
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    let patchFlag = 64;
    let patchFlagText = PatchFlagNames[64];
    if (children.filter((c) => c.type !== 3).length === 1) {
      patchFlag |= 2048;
      patchFlagText += `, ${PatchFlagNames[2048]}`;
    }
    root.codegenNode = createVNodeCall(
      context,
      helper(FRAGMENT),
      void 0,
      root.children,
      patchFlag + (true ? ` /* ${patchFlagText} */` : ``),
      void 0,
      void 0,
      true,
      void 0,
      false
    );
  } else
    ;
}
function traverseChildren(parent, context) {
  let i = 0;
  const nodeRemoved = () => {
    i--;
  };
  for (; i < parent.children.length; i++) {
    const child = parent.children[i];
    if (isString(child))
      continue;
    context.grandParent = context.parent;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}
function traverseNode(node, context) {
  context.currentNode = node;
  const { nodeTransforms } = context;
  const exitFns = [];
  for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
    const onExit = nodeTransforms[i2](node, context);
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit);
      } else {
        exitFns.push(onExit);
      }
    }
    if (!context.currentNode) {
      return;
    } else {
      node = context.currentNode;
    }
  }
  switch (node.type) {
    case 3:
      if (!context.ssr) {
        context.helper(CREATE_COMMENT);
      }
      break;
    case 5:
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }
      break;
    case 9:
      for (let i2 = 0; i2 < node.branches.length; i2++) {
        traverseNode(node.branches[i2], context);
      }
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      traverseChildren(node, context);
      break;
  }
  context.currentNode = node;
  let i = exitFns.length;
  while (i--) {
    exitFns[i]();
  }
}
function createStructuralDirectiveTransform(name, fn) {
  const matches = isString(name) ? (n) => n === name : (n) => name.test(n);
  return (node, context) => {
    if (node.type === 1) {
      const { props } = node;
      if (node.tagType === 3 && props.some(isVSlot)) {
        return;
      }
      const exitFns = [];
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 7 && matches(prop.name)) {
          props.splice(i, 1);
          i--;
          const onExit = fn(node, prop, context);
          if (onExit)
            exitFns.push(onExit);
        }
      }
      return exitFns;
    }
  };
}
function createCodegenContext(ast, {
  mode = "function",
  prefixIdentifiers = mode === "module",
  sourceMap = false,
  filename = `template.vue.html`,
  scopeId = null,
  optimizeImports = false,
  runtimeGlobalName = `Vue`,
  runtimeModuleName = `vue`,
  ssrRuntimeModuleName = "vue/server-renderer",
  ssr = false,
  isTS = false,
  inSSR = false
}) {
  const context = {
    mode,
    prefixIdentifiers,
    sourceMap,
    filename,
    scopeId,
    optimizeImports,
    runtimeGlobalName,
    runtimeModuleName,
    ssrRuntimeModuleName,
    ssr,
    isTS,
    inSSR,
    source: ast.source,
    code: ``,
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: void 0,
    helper(key) {
      return `_${helperNameMap[key]}`;
    },
    push(code, newlineIndex = -2, node) {
      context.code += code;
    },
    indent() {
      newline(++context.indentLevel);
    },
    deindent(withoutNewLine = false) {
      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        newline(--context.indentLevel);
      }
    },
    newline() {
      newline(context.indentLevel);
    }
  };
  function newline(n) {
    context.push(
      "\n" + `  `.repeat(n),
      0
      /* Start */
    );
  }
  return context;
}
function generate(ast, options = {}) {
  const context = createCodegenContext(ast, options);
  if (options.onContextCreated)
    options.onContextCreated(context);
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context;
  const helpers = Array.from(ast.helpers);
  const hasHelpers = helpers.length > 0;
  const useWithBlock = !prefixIdentifiers && mode !== "module";
  const preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  }
  const functionName = ssr ? `ssrRender` : `render`;
  const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
  const signature = args.join(", ");
  {
    push(`function ${functionName}(${signature}) {`);
  }
  indent();
  if (useWithBlock) {
    push(`with (_ctx) {`);
    indent();
    if (hasHelpers) {
      push(
        `const { ${helpers.map(aliasHelper).join(", ")} } = _Vue
`,
        -1
        /* End */
      );
      newline();
    }
  }
  if (ast.components.length) {
    genAssets(ast.components, "component", context);
    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, "directive", context);
    if (ast.temps > 0) {
      newline();
    }
  }
  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, "filter", context);
    newline();
  }
  if (ast.temps > 0) {
    push(`let `);
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`);
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(
      `
`,
      0
      /* Start */
    );
    newline();
  }
  if (!ssr) {
    push(`return `);
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push(`null`);
  }
  if (useWithBlock) {
    deindent();
    push(`}`);
  }
  deindent();
  push(`}`);
  return {
    ast,
    code: context.code,
    preamble: ``,
    map: context.map ? context.map.toJSON() : void 0
  };
}
function genFunctionPreamble(ast, context) {
  const {
    ssr,
    prefixIdentifiers,
    push,
    newline,
    runtimeModuleName,
    runtimeGlobalName,
    ssrRuntimeModuleName
  } = context;
  const VueBinding = runtimeGlobalName;
  const helpers = Array.from(ast.helpers);
  if (helpers.length > 0) {
    {
      push(
        `const _Vue = ${VueBinding}
`,
        -1
        /* End */
      );
      if (ast.hoists.length) {
        const staticHelpers = [
          CREATE_VNODE,
          CREATE_ELEMENT_VNODE,
          CREATE_COMMENT,
          CREATE_TEXT,
          CREATE_STATIC
        ].filter((helper) => helpers.includes(helper)).map(aliasHelper).join(", ");
        push(
          `const { ${staticHelpers} } = _Vue
`,
          -1
          /* End */
        );
      }
    }
  }
  genHoists(ast.hoists, context);
  newline();
  push(`return `);
}
function genAssets(assets, type, { helper, push, newline, isTS }) {
  const resolver = helper(
    type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE
  );
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i];
    const maybeSelfReference = id.endsWith("__self");
    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`
    );
    if (i < assets.length - 1) {
      newline();
    }
  }
}
function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }
  context.pure = true;
  const { push, newline, helper, scopeId, mode } = context;
  newline();
  for (let i = 0; i < hoists.length; i++) {
    const exp = hoists[i];
    if (exp) {
      push(
        `const _hoisted_${i + 1} = ${``}`
      );
      genNode(exp, context);
      newline();
    }
  }
  context.pure = false;
}
function isText(n) {
  return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
}
function genNodeListAsArray(nodes, context) {
  const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText(n));
  context.push(`[`);
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
  const { push, newline } = context;
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (isString(node)) {
      push(
        node,
        -3
        /* Unknown */
      );
    } else if (isArray(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }
    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(",");
        newline();
      } else {
        comma && push(", ");
      }
    }
  }
}
function genNode(node, context) {
  if (isString(node)) {
    context.push(
      node,
      -3
      /* Unknown */
    );
    return;
  }
  if (isSymbol(node)) {
    context.push(context.helper(node));
    return;
  }
  switch (node.type) {
    case 1:
    case 9:
    case 11:
      assert(
        node.codegenNode != null,
        `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`
      );
      genNode(node.codegenNode, context);
      break;
    case 2:
      genText(node, context);
      break;
    case 4:
      genExpression(node, context);
      break;
    case 5:
      genInterpolation(node, context);
      break;
    case 12:
      genNode(node.codegenNode, context);
      break;
    case 8:
      genCompoundExpression(node, context);
      break;
    case 3:
      genComment(node, context);
      break;
    case 13:
      genVNodeCall(node, context);
      break;
    case 14:
      genCallExpression(node, context);
      break;
    case 15:
      genObjectExpression(node, context);
      break;
    case 17:
      genArrayExpression(node, context);
      break;
    case 18:
      genFunctionExpression(node, context);
      break;
    case 19:
      genConditionalExpression(node, context);
      break;
    case 20:
      genCacheExpression(node, context);
      break;
    case 21:
      genNodeList(node.body, context, true, false);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if (true) {
        assert(false, `unhandled codegen node type: ${node.type}`);
        const exhaustiveCheck = node;
        return exhaustiveCheck;
      }
  }
}
function genText(node, context) {
  context.push(JSON.stringify(node.content), -3, node);
}
function genExpression(node, context) {
  const { content, isStatic } = node;
  context.push(
    isStatic ? JSON.stringify(content) : content,
    -3,
    node
  );
}
function genInterpolation(node, context) {
  const { push, helper, pure } = context;
  if (pure)
    push(PURE_ANNOTATION);
  push(`${helper(TO_DISPLAY_STRING)}(`);
  genNode(node.content, context);
  push(`)`);
}
function genCompoundExpression(node, context) {
  for (let i = 0; i < node.children.length; i++) {
    const child = node.children[i];
    if (isString(child)) {
      context.push(
        child,
        -3
        /* Unknown */
      );
    } else {
      genNode(child, context);
    }
  }
}
function genExpressionAsPropertyKey(node, context) {
  const { push } = context;
  if (node.type === 8) {
    push(`[`);
    genCompoundExpression(node, context);
    push(`]`);
  } else if (node.isStatic) {
    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, -2, node);
  } else {
    push(`[${node.content}]`, -3, node);
  }
}
function genComment(node, context) {
  const { push, helper, pure } = context;
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(
    `${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,
    -3,
    node
  );
}
function genVNodeCall(node, context) {
  const { push, helper, pure } = context;
  const {
    tag,
    props,
    children,
    patchFlag,
    dynamicProps,
    directives,
    isBlock,
    disableTracking,
    isComponent: isComponent2
  } = node;
  if (directives) {
    push(helper(WITH_DIRECTIVES) + `(`);
  }
  if (isBlock) {
    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
  }
  if (pure) {
    push(PURE_ANNOTATION);
  }
  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
  push(helper(callHelper) + `(`, -2, node);
  genNodeList(
    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),
    context
  );
  push(`)`);
  if (isBlock) {
    push(`)`);
  }
  if (directives) {
    push(`, `);
    genNode(directives, context);
    push(`)`);
  }
}
function genNullableArgs(args) {
  let i = args.length;
  while (i--) {
    if (args[i] != null)
      break;
  }
  return args.slice(0, i + 1).map((arg) => arg || `null`);
}
function genCallExpression(node, context) {
  const { push, helper, pure } = context;
  const callee = isString(node.callee) ? node.callee : helper(node.callee);
  if (pure) {
    push(PURE_ANNOTATION);
  }
  push(callee + `(`, -2, node);
  genNodeList(node.arguments, context);
  push(`)`);
}
function genObjectExpression(node, context) {
  const { push, indent, deindent, newline } = context;
  const { properties } = node;
  if (!properties.length) {
    push(`{}`, -2, node);
    return;
  }
  const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
  push(multilines ? `{` : `{ `);
  multilines && indent();
  for (let i = 0; i < properties.length; i++) {
    const { key, value } = properties[i];
    genExpressionAsPropertyKey(key, context);
    push(`: `);
    genNode(value, context);
    if (i < properties.length - 1) {
      push(`,`);
      newline();
    }
  }
  multilines && deindent();
  push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
  const { push, indent, deindent } = context;
  const { params, returns, body, newline, isSlot } = node;
  if (isSlot) {
    push(`_${helperNameMap[WITH_CTX]}(`);
  }
  push(`(`, -2, node);
  if (isArray(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }
  push(`) => `);
  if (newline || body) {
    push(`{`);
    indent();
  }
  if (returns) {
    if (newline) {
      push(`return `);
    }
    if (isArray(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }
  if (newline || body) {
    deindent();
    push(`}`);
  }
  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(`, undefined, true`);
    }
    push(`)`);
  }
}
function genConditionalExpression(node, context) {
  const { test, consequent, alternate, newline: needNewline } = node;
  const { push, indent, deindent, newline } = context;
  if (test.type === 4) {
    const needsParens = !isSimpleIdentifier(test.content);
    needsParens && push(`(`);
    genExpression(test, context);
    needsParens && push(`)`);
  } else {
    push(`(`);
    genNode(test, context);
    push(`)`);
  }
  needNewline && indent();
  context.indentLevel++;
  needNewline || push(` `);
  push(`? `);
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(` `);
  push(`: `);
  const isNested = alternate.type === 19;
  if (!isNested) {
    context.indentLevel++;
  }
  genNode(alternate, context);
  if (!isNested) {
    context.indentLevel--;
  }
  needNewline && deindent(
    true
    /* without newline */
  );
}
function genCacheExpression(node, context) {
  const { push, helper, indent, deindent, newline } = context;
  push(`_cache[${node.index}] || (`);
  if (node.isVNode) {
    indent();
    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
    newline();
  }
  push(`_cache[${node.index}] = `);
  genNode(node.value, context);
  if (node.isVNode) {
    push(`,`);
    newline();
    push(`${helper(SET_BLOCK_TRACKING)}(1),`);
    newline();
    push(`_cache[${node.index}]`);
    deindent();
  }
  push(`)`);
}
function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
  const exp = node.content;
  if (!exp.trim()) {
    return;
  }
  try {
    new Function(
      asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`
    );
  } catch (e) {
    let message = e.message;
    const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
    if (keywordMatch) {
      message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
    }
    context.onError(
      createCompilerError(
        45,
        node.loc,
        void 0,
        message
      )
    );
  }
}
function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
  {
    if (true) {
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }
    return node;
  }
}
function stringifyExpression(exp) {
  if (isString(exp)) {
    return exp;
  } else if (exp.type === 4) {
    return exp.content;
  } else {
    return exp.children.map(stringifyExpression).join("");
  }
}
function processIf(node, dir, context, processCodegen) {
  if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
    const loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(
      createCompilerError(28, dir.loc)
    );
    dir.exp = createSimpleExpression(`true`, false, loc);
  }
  if (dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }
  if (dir.name === "if") {
    const branch = createIfBranch(node, dir);
    const ifNode = {
      type: 9,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);
    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    const siblings = context.parent.children;
    const comments = [];
    let i = siblings.indexOf(node);
    while (i-- >= -1) {
      const sibling = siblings[i];
      if (sibling && sibling.type === 3) {
        context.removeNode(sibling);
        comments.unshift(sibling);
        continue;
      }
      if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }
      if (sibling && sibling.type === 9) {
        if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
          context.onError(
            createCompilerError(30, node.loc)
          );
        }
        context.removeNode();
        const branch = createIfBranch(node, dir);
        if (comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(context.parent && context.parent.type === 1 && (context.parent.tag === "transition" || context.parent.tag === "Transition"))) {
          branch.children = [...comments, ...branch.children];
        }
        if (true) {
          const key = branch.userKey;
          if (key) {
            sibling.branches.forEach(({ userKey }) => {
              if (isSameKey(userKey, key)) {
                context.onError(
                  createCompilerError(
                    29,
                    branch.userKey.loc
                  )
                );
              }
            });
          }
        }
        sibling.branches.push(branch);
        const onExit = processCodegen && processCodegen(sibling, branch, false);
        traverseNode(branch, context);
        if (onExit)
          onExit();
        context.currentNode = null;
      } else {
        context.onError(
          createCompilerError(30, node.loc)
        );
      }
      break;
    }
  }
}
function createIfBranch(node, dir) {
  const isTemplateIf = node.tagType === 3;
  return {
    type: 10,
    loc: node.loc,
    condition: dir.name === "else" ? void 0 : dir.exp,
    children: isTemplateIf && !findDir(node, "for") ? node.children : [node],
    userKey: findProp(node, `key`),
    isTemplateIf
  };
}
function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(
      branch.condition,
      createChildrenCodegenNode(branch, keyIndex, context),
      // make sure to pass in asBlock: true so that the comment node call
      // closes the current block.
      createCallExpression(context.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ])
    );
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}
function createChildrenCodegenNode(branch, keyIndex, context) {
  const { helper } = context;
  const keyProperty = createObjectProperty(
    `key`,
    createSimpleExpression(
      `${keyIndex}`,
      false,
      locStub,
      2
    )
  );
  const { children } = branch;
  const firstChild = children[0];
  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11) {
      const vnodeCall = firstChild.codegenNode;
      injectProp(vnodeCall, keyProperty, context);
      return vnodeCall;
    } else {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (!branch.isTemplateIf && children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      return createVNodeCall(
        context,
        helper(FRAGMENT),
        createObjectExpression([keyProperty]),
        children,
        patchFlag + (true ? ` /* ${patchFlagText} */` : ``),
        void 0,
        void 0,
        true,
        false,
        false,
        branch.loc
      );
    }
  } else {
    const ret = firstChild.codegenNode;
    const vnodeCall = getMemoedVNodeCall(ret);
    if (vnodeCall.type === 13) {
      convertToBlock(vnodeCall, context);
    }
    injectProp(vnodeCall, keyProperty, context);
    return ret;
  }
}
function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }
  if (a.type === 6) {
    if (a.value.content !== b.value.content) {
      return false;
    }
  } else {
    const exp = a.exp;
    const branchExp = b.exp;
    if (exp.type !== branchExp.type) {
      return false;
    }
    if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }
  return true;
}
function getParentCondition(node) {
  while (true) {
    if (node.type === 19) {
      if (node.alternate.type === 19) {
        node = node.alternate;
      } else {
        return node;
      }
    } else if (node.type === 20) {
      node = node.value;
    }
  }
}
function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(
      createCompilerError(31, dir.loc)
    );
    return;
  }
  const parseResult = dir.forParseResult;
  if (!parseResult) {
    context.onError(
      createCompilerError(32, dir.loc)
    );
    return;
  }
  finalizeForParseResult(parseResult, context);
  const { addIdentifiers, removeIdentifiers, scopes } = context;
  const { source, value, key, index } = parseResult;
  const forNode = {
    type: 11,
    loc: dir.loc,
    source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode);
  scopes.vFor++;
  const onExit = processCodegen && processCodegen(forNode);
  return () => {
    scopes.vFor--;
    if (onExit)
      onExit();
  };
}
function finalizeForParseResult(result, context) {
  if (result.finalized)
    return;
  if (true) {
    validateBrowserExpression(result.source, context);
    if (result.key) {
      validateBrowserExpression(
        result.key,
        context,
        true
      );
    }
    if (result.index) {
      validateBrowserExpression(
        result.index,
        context,
        true
      );
    }
    if (result.value) {
      validateBrowserExpression(
        result.value,
        context,
        true
      );
    }
  }
  result.finalized = true;
}
function createForLoopParams({ value, key, index }, memoArgs = []) {
  return createParamsList([value, key, index, ...memoArgs]);
}
function createParamsList(args) {
  let i = args.length;
  while (i--) {
    if (args[i])
      break;
  }
  return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
}
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
  context.helper(WITH_CTX);
  const { children, loc } = node;
  const slotsProperties = [];
  const dynamicSlots = [];
  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
  const onComponentSlot = findDir(node, "slot", true);
  if (onComponentSlot) {
    const { arg, exp } = onComponentSlot;
    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }
    slotsProperties.push(
      createObjectProperty(
        arg || createSimpleExpression("default", true),
        buildSlotFn(exp, void 0, children, loc)
      )
    );
  }
  let hasTemplateSlots = false;
  let hasNamedDefaultSlot = false;
  const implicitDefaultChildren = [];
  const seenSlotNames = /* @__PURE__ */ new Set();
  let conditionalBranchIndex = 0;
  for (let i = 0; i < children.length; i++) {
    const slotElement = children[i];
    let slotDir;
    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
      if (slotElement.type !== 3) {
        implicitDefaultChildren.push(slotElement);
      }
      continue;
    }
    if (onComponentSlot) {
      context.onError(
        createCompilerError(37, slotDir.loc)
      );
      break;
    }
    hasTemplateSlots = true;
    const { children: slotChildren, loc: slotLoc } = slotElement;
    const {
      arg: slotName = createSimpleExpression(`default`, true),
      exp: slotProps,
      loc: dirLoc
    } = slotDir;
    let staticSlotName;
    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : `default`;
    } else {
      hasDynamicSlots = true;
    }
    const vFor = findDir(slotElement, "for");
    const slotFunction = buildSlotFn(slotProps, vFor, slotChildren, slotLoc);
    let vIf;
    let vElse;
    if (vIf = findDir(slotElement, "if")) {
      hasDynamicSlots = true;
      dynamicSlots.push(
        createConditionalExpression(
          vIf.exp,
          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),
          defaultFallback
        )
      );
    } else if (vElse = findDir(
      slotElement,
      /^else(-if)?$/,
      true
      /* allowEmpty */
    )) {
      let j = i;
      let prev;
      while (j--) {
        prev = children[j];
        if (prev.type !== 3) {
          break;
        }
      }
      if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
        children.splice(i, 1);
        i--;
        let conditional = dynamicSlots[dynamicSlots.length - 1];
        while (conditional.alternate.type === 19) {
          conditional = conditional.alternate;
        }
        conditional.alternate = vElse.exp ? createConditionalExpression(
          vElse.exp,
          buildDynamicSlot(
            slotName,
            slotFunction,
            conditionalBranchIndex++
          ),
          defaultFallback
        ) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);
      } else {
        context.onError(
          createCompilerError(30, vElse.loc)
        );
      }
    } else if (vFor) {
      hasDynamicSlots = true;
      const parseResult = vFor.forParseResult;
      if (parseResult) {
        finalizeForParseResult(parseResult, context);
        dynamicSlots.push(
          createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(
              createForLoopParams(parseResult),
              buildDynamicSlot(slotName, slotFunction),
              true
            )
          ])
        );
      } else {
        context.onError(
          createCompilerError(
            32,
            vFor.loc
          )
        );
      }
    } else {
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(
            createCompilerError(
              38,
              dirLoc
            )
          );
          continue;
        }
        seenSlotNames.add(staticSlotName);
        if (staticSlotName === "default") {
          hasNamedDefaultSlot = true;
        }
      }
      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }
  if (!onComponentSlot) {
    const buildDefaultSlotProperty = (props, children2) => {
      const fn = buildSlotFn(props, void 0, children2, loc);
      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }
      return createObjectProperty(`default`, fn);
    };
    if (!hasTemplateSlots) {
      slotsProperties.push(buildDefaultSlotProperty(void 0, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
      if (hasNamedDefaultSlot) {
        context.onError(
          createCompilerError(
            39,
            implicitDefaultChildren[0].loc
          )
        );
      } else {
        slotsProperties.push(
          buildDefaultSlotProperty(void 0, implicitDefaultChildren)
        );
      }
    }
  }
  const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
  let slots = createObjectExpression(
    slotsProperties.concat(
      createObjectProperty(
        `_`,
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        createSimpleExpression(
          slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``),
          false
        )
      )
    ),
    loc
  );
  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [
      slots,
      createArrayExpression(dynamicSlots)
    ]);
  }
  return {
    slots,
    hasDynamicSlots
  };
}
function buildDynamicSlot(name, fn, index) {
  const props = [
    createObjectProperty(`name`, name),
    createObjectProperty(`fn`, fn)
  ];
  if (index != null) {
    props.push(
      createObjectProperty(`key`, createSimpleExpression(String(index), true))
    );
  }
  return createObjectExpression(props);
}
function hasForwardedSlots(children) {
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    switch (child.type) {
      case 1:
        if (child.tagType === 2 || hasForwardedSlots(child.children)) {
          return true;
        }
        break;
      case 9:
        if (hasForwardedSlots(child.branches))
          return true;
        break;
      case 10:
      case 11:
        if (hasForwardedSlots(child.children))
          return true;
        break;
    }
  }
  return false;
}
function isNonWhitespaceContent(node) {
  if (node.type !== 2 && node.type !== 12)
    return true;
  return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
}
function resolveComponentType(node, context, ssr = false) {
  let { tag } = node;
  const isExplicitDynamic = isComponentTag(tag);
  const isProp = findProp(
    node,
    "is",
    false,
    true
    /* allow empty */
  );
  if (isProp) {
    if (isExplicitDynamic || isCompatEnabled(
      "COMPILER_IS_ON_ELEMENT",
      context
    )) {
      let exp;
      if (isProp.type === 6) {
        exp = isProp.value && createSimpleExpression(isProp.value.content, true);
      } else {
        exp = isProp.exp;
        if (!exp) {
          exp = createSimpleExpression(`is`, false, isProp.loc);
        }
      }
      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          exp
        ]);
      }
    } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
      tag = isProp.value.content.slice(4);
    }
  }
  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
  if (builtIn) {
    if (!ssr)
      context.helper(builtIn);
    return builtIn;
  }
  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, isComponent2, isDynamicComponent, ssr = false) {
  const { tag, loc: elementLoc, children } = node;
  let properties = [];
  const mergeArgs = [];
  const runtimeDirectives = [];
  const hasChildren = children.length > 0;
  let shouldUseBlock = false;
  let patchFlag = 0;
  let hasRef = false;
  let hasClassBinding = false;
  let hasStyleBinding = false;
  let hasHydrationEventBinding = false;
  let hasDynamicKeys = false;
  let hasVnodeHook = false;
  const dynamicPropNames = [];
  const pushMergeArg = (arg) => {
    if (properties.length) {
      mergeArgs.push(
        createObjectExpression(dedupeProperties(properties), elementLoc)
      );
      properties = [];
    }
    if (arg)
      mergeArgs.push(arg);
  };
  const pushRefVForMarker = () => {
    if (context.scopes.vFor > 0) {
      properties.push(
        createObjectProperty(
          createSimpleExpression("ref_for", true),
          createSimpleExpression("true")
        )
      );
    }
  };
  const analyzePatchFlag = ({ key, value }) => {
    if (isStaticExp(key)) {
      const name = key.content;
      const isEventHandler = isOn(name);
      if (isEventHandler && (!isComponent2 || isDynamicComponent) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== "onclick" && // omit v-model handlers
      name !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !isReservedProp(name)) {
        hasHydrationEventBinding = true;
      }
      if (isEventHandler && isReservedProp(name)) {
        hasVnodeHook = true;
      }
      if (isEventHandler && value.type === 14) {
        value = value.arguments[0];
      }
      if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
        return;
      }
      if (name === "ref") {
        hasRef = true;
      } else if (name === "class") {
        hasClassBinding = true;
      } else if (name === "style") {
        hasStyleBinding = true;
      } else if (name !== "key" && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
      if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (prop.type === 6) {
      const { loc, name, nameLoc, value } = prop;
      let isStatic = true;
      if (name === "ref") {
        hasRef = true;
        pushRefVForMarker();
      }
      if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      properties.push(
        createObjectProperty(
          createSimpleExpression(name, true, nameLoc),
          createSimpleExpression(
            value ? value.content : "",
            isStatic,
            value ? value.loc : loc
          )
        )
      );
    } else {
      const { name, arg, exp, loc, modifiers } = prop;
      const isVBind = name === "bind";
      const isVOn = name === "on";
      if (name === "slot") {
        if (!isComponent2) {
          context.onError(
            createCompilerError(40, loc)
          );
        }
        continue;
      }
      if (name === "once" || name === "memo") {
        continue;
      }
      if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled(
        "COMPILER_IS_ON_ELEMENT",
        context
      ))) {
        continue;
      }
      if (isVOn && ssr) {
        continue;
      }
      if (
        // #938: elements with dynamic keys should be forced into blocks
        isVBind && isStaticArgOf(arg, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")
      ) {
        shouldUseBlock = true;
      }
      if (isVBind && isStaticArgOf(arg, "ref")) {
        pushRefVForMarker();
      }
      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;
        if (exp) {
          if (isVBind) {
            pushRefVForMarker();
            pushMergeArg();
            {
              if (true) {
                const hasOverridableKeys = mergeArgs.some((arg2) => {
                  if (arg2.type === 15) {
                    return arg2.properties.some(({ key }) => {
                      if (key.type !== 4 || !key.isStatic) {
                        return true;
                      }
                      return key.content !== "class" && key.content !== "style" && !isOn(key.content);
                    });
                  } else {
                    return true;
                  }
                });
                if (hasOverridableKeys) {
                  checkCompatEnabled(
                    "COMPILER_V_BIND_OBJECT_ORDER",
                    context,
                    loc
                  );
                }
              }
              if (isCompatEnabled(
                "COMPILER_V_BIND_OBJECT_ORDER",
                context
              )) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            pushMergeArg({
              type: 14,
              loc,
              callee: context.helper(TO_HANDLERS),
              arguments: isComponent2 ? [exp] : [exp, `true`]
            });
          }
        } else {
          context.onError(
            createCompilerError(
              isVBind ? 34 : 35,
              loc
            )
          );
        }
        continue;
      }
      if (isVBind && modifiers.includes("prop")) {
        patchFlag |= 32;
      }
      const directiveTransform = context.directiveTransforms[name];
      if (directiveTransform) {
        const { props: props2, needRuntime } = directiveTransform(prop, node, context);
        !ssr && props2.forEach(analyzePatchFlag);
        if (isVOn && arg && !isStaticExp(arg)) {
          pushMergeArg(createObjectExpression(props2, elementLoc));
        } else {
          properties.push(...props2);
        }
        if (needRuntime) {
          runtimeDirectives.push(prop);
          if (isSymbol(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else if (!isBuiltInDirective(name)) {
        runtimeDirectives.push(prop);
        if (hasChildren) {
          shouldUseBlock = true;
        }
      }
    }
  }
  let propsExpression = void 0;
  if (mergeArgs.length) {
    pushMergeArg();
    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(
        context.helper(MERGE_PROPS),
        mergeArgs,
        elementLoc
      );
    } else {
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(
      dedupeProperties(properties),
      elementLoc
    );
  }
  if (hasDynamicKeys) {
    patchFlag |= 16;
  } else {
    if (hasClassBinding && !isComponent2) {
      patchFlag |= 2;
    }
    if (hasStyleBinding && !isComponent2) {
      patchFlag |= 4;
    }
    if (dynamicPropNames.length) {
      patchFlag |= 8;
    }
    if (hasHydrationEventBinding) {
      patchFlag |= 32;
    }
  }
  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512;
  }
  if (!context.inSSR && propsExpression) {
    switch (propsExpression.type) {
      case 15:
        let classKeyIndex = -1;
        let styleKeyIndex = -1;
        let hasDynamicKey = false;
        for (let i = 0; i < propsExpression.properties.length; i++) {
          const key = propsExpression.properties[i].key;
          if (isStaticExp(key)) {
            if (key.content === "class") {
              classKeyIndex = i;
            } else if (key.content === "style") {
              styleKeyIndex = i;
            }
          } else if (!key.isHandlerKey) {
            hasDynamicKey = true;
          }
        }
        const classProp = propsExpression.properties[classKeyIndex];
        const styleProp = propsExpression.properties[styleKeyIndex];
        if (!hasDynamicKey) {
          if (classProp && !isStaticExp(classProp.value)) {
            classProp.value = createCallExpression(
              context.helper(NORMALIZE_CLASS),
              [classProp.value]
            );
          }
          if (styleProp && // the static style is compiled into an object,
          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
          (hasStyleBinding || styleProp.value.type === 4 && styleProp.value.content.trim()[0] === `[` || // v-bind:style and style both exist,
          // v-bind:style with static literal object
          styleProp.value.type === 17)) {
            styleProp.value = createCallExpression(
              context.helper(NORMALIZE_STYLE),
              [styleProp.value]
            );
          }
        } else {
          propsExpression = createCallExpression(
            context.helper(NORMALIZE_PROPS),
            [propsExpression]
          );
        }
        break;
      case 14:
        break;
      default:
        propsExpression = createCallExpression(
          context.helper(NORMALIZE_PROPS),
          [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]
        );
        break;
    }
  }
  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag,
    dynamicPropNames,
    shouldUseBlock
  };
}
function dedupeProperties(properties) {
  const knownProps = /* @__PURE__ */ new Map();
  const deduped = [];
  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i];
    if (prop.key.type === 8 || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }
    const name = prop.key.content;
    const existing = knownProps.get(name);
    if (existing) {
      if (name === "style" || name === "class" || isOn(name)) {
        mergeAsArray(existing, prop);
      }
    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }
  return deduped;
}
function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17) {
    existing.value.elements.push(incoming.value);
  } else {
    existing.value = createArrayExpression(
      [existing.value, incoming.value],
      existing.loc
    );
  }
}
function buildDirectiveArgs(dir, context) {
  const dirArgs = [];
  const runtime = directiveImportMap.get(dir);
  if (runtime) {
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
  }
  const { loc } = dir;
  if (dir.exp)
    dirArgs.push(dir.exp);
  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push(`void 0`);
    }
    dirArgs.push(dir.arg);
  }
  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(`void 0`);
    }
    const trueExpression = createSimpleExpression(`true`, false, loc);
    dirArgs.push(
      createObjectExpression(
        dir.modifiers.map(
          (modifier) => createObjectProperty(modifier, trueExpression)
        ),
        loc
      )
    );
  }
  return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
  let propsNamesString = `[`;
  for (let i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1)
      propsNamesString += ", ";
  }
  return propsNamesString + `]`;
}
function isComponentTag(tag) {
  return tag === "component" || tag === "Component";
}
function processSlotOutlet(node, context) {
  let slotName = `"default"`;
  let slotProps = void 0;
  const nonNameProps = [];
  for (let i = 0; i < node.props.length; i++) {
    const p = node.props[i];
    if (p.type === 6) {
      if (p.value) {
        if (p.name === "name") {
          slotName = JSON.stringify(p.value.content);
        } else {
          p.name = camelize(p.name);
          nonNameProps.push(p);
        }
      }
    } else {
      if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
        if (p.exp) {
          slotName = p.exp;
        } else if (p.arg && p.arg.type === 4) {
          const name = camelize(p.arg.content);
          slotName = p.exp = createSimpleExpression(name, false, p.arg.loc);
        }
      } else {
        if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }
        nonNameProps.push(p);
      }
    }
  }
  if (nonNameProps.length > 0) {
    const { props, directives } = buildProps(
      node,
      context,
      nonNameProps,
      false,
      false
    );
    slotProps = props;
    if (directives.length) {
      context.onError(
        createCompilerError(
          36,
          directives[0].loc
        )
      );
    }
  }
  return {
    slotName,
    slotProps
  };
}
function createTransformProps(props = []) {
  return { props };
}
function rewriteFilter(node, context) {
  if (node.type === 4) {
    parseFilter(node, context);
  } else {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (typeof child !== "object")
        continue;
      if (child.type === 4) {
        parseFilter(child, context);
      } else if (child.type === 8) {
        rewriteFilter(node, context);
      } else if (child.type === 5) {
        rewriteFilter(child.content, context);
      }
    }
  }
}
function parseFilter(node, context) {
  const exp = node.content;
  let inSingle = false;
  let inDouble = false;
  let inTemplateString = false;
  let inRegex = false;
  let curly = 0;
  let square = 0;
  let paren = 0;
  let lastFilterIndex = 0;
  let c, prev, i, expression, filters = [];
  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 39 && prev !== 92)
        inSingle = false;
    } else if (inDouble) {
      if (c === 34 && prev !== 92)
        inDouble = false;
    } else if (inTemplateString) {
      if (c === 96 && prev !== 92)
        inTemplateString = false;
    } else if (inRegex) {
      if (c === 47 && prev !== 92)
        inRegex = false;
    } else if (c === 124 && // pipe
    exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
      if (expression === void 0) {
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 34:
          inDouble = true;
          break;
        case 39:
          inSingle = true;
          break;
        case 96:
          inTemplateString = true;
          break;
        case 40:
          paren++;
          break;
        case 41:
          paren--;
          break;
        case 91:
          square++;
          break;
        case 93:
          square--;
          break;
        case 123:
          curly++;
          break;
        case 125:
          curly--;
          break;
      }
      if (c === 47) {
        let j = i - 1;
        let p;
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== " ")
            break;
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }
  if (expression === void 0) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }
  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }
  if (filters.length) {
    warnDeprecation(
      "COMPILER_FILTERS",
      context,
      node.loc
    );
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }
    node.content = expression;
  }
}
function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  const i = filter.indexOf("(");
  if (i < 0) {
    context.filters.add(filter);
    return `${toValidAssetId(filter, "filter")}(${exp})`;
  } else {
    const name = filter.slice(0, i);
    const args = filter.slice(i + 1);
    context.filters.add(name);
    return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
  }
}
function getBaseTransformPreset(prefixIdentifiers) {
  return [
    [
      transformOnce,
      transformIf,
      transformMemo,
      transformFor,
      ...[transformFilter],
      ...true ? [transformExpression] : [],
      transformSlotOutlet,
      transformElement,
      trackSlotScopes,
      transformText
    ],
    {
      on: transformOn,
      bind: transformBind,
      model: transformModel
    }
  ];
}
function baseCompile(source, options = {}) {
  const onError = options.onError || defaultOnError;
  const isModuleMode = options.mode === "module";
  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(47));
    } else if (isModuleMode) {
      onError(createCompilerError(48));
    }
  }
  const prefixIdentifiers = false;
  if (options.cacheHandlers) {
    onError(createCompilerError(49));
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(50));
  }
  const resolvedOptions = extend({}, options, {
    prefixIdentifiers
  });
  const ast = isString(source) ? baseParse(source, resolvedOptions) : source;
  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
  transform(
    ast,
    extend({}, resolvedOptions, {
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {}
        // user transforms
      )
    })
  );
  return generate(ast, resolvedOptions);
}
var FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, Namespaces, NodeTypes, ElementTypes, ConstantTypes, locStub, defaultDelimitersOpen, defaultDelimitersClose, Sequences, Tokenizer, CompilerDeprecationTypes, deprecationData, ErrorCodes, errorMessages, isFunctionType, isStaticProperty, isStaticPropertyKey, TS_NODE_TYPES, isStaticExp, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, isMemberExpressionBrowser, isMemberExpressionNode, isMemberExpression, propsHelperSet, forAliasRE, defaultParserOptions, currentOptions, currentRoot, currentInput, currentOpenTag, currentProp, currentAttrValue, currentAttrStartIndex, currentAttrEndIndex, inPre, inVPre, currentVPreBoundary, stack, tokenizer, forIteratorRE, stripParensRE, specialTemplateDir, windowsNewlineRE, allowHoistedHelperSet, PURE_ANNOTATION, aliasHelper, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, defaultFallback, trackSlotScopes, trackVForSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, transformSlotOutlet, fnExpRE, transformOn, transformBind, injectPrefix, transformText, seen$1, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen, transformMemo, BindingTypes, noopDirectiveTransform;
var init_compiler_core_esm_bundler = __esm({
  "node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
    init_shared_esm_bundler();
    init_shared_esm_bundler();
    FRAGMENT = Symbol(true ? `Fragment` : ``);
    TELEPORT = Symbol(true ? `Teleport` : ``);
    SUSPENSE = Symbol(true ? `Suspense` : ``);
    KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
    BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
    OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
    CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
    CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
    CREATE_VNODE = Symbol(true ? `createVNode` : ``);
    CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
    CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
    CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
    CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
    RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
    RESOLVE_DYNAMIC_COMPONENT = Symbol(
      true ? `resolveDynamicComponent` : ``
    );
    RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
    RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
    WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
    RENDER_LIST = Symbol(true ? `renderList` : ``);
    RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
    CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
    TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
    MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
    NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
    NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
    NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
    GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
    TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
    CAMELIZE = Symbol(true ? `camelize` : ``);
    CAPITALIZE = Symbol(true ? `capitalize` : ``);
    TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
    SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
    PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
    POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
    WITH_CTX = Symbol(true ? `withCtx` : ``);
    UNREF = Symbol(true ? `unref` : ``);
    IS_REF = Symbol(true ? `isRef` : ``);
    WITH_MEMO = Symbol(true ? `withMemo` : ``);
    IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
    helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    Namespaces = {
      "HTML": 0,
      "0": "HTML",
      "SVG": 1,
      "1": "SVG",
      "MATH_ML": 2,
      "2": "MATH_ML"
    };
    NodeTypes = {
      "ROOT": 0,
      "0": "ROOT",
      "ELEMENT": 1,
      "1": "ELEMENT",
      "TEXT": 2,
      "2": "TEXT",
      "COMMENT": 3,
      "3": "COMMENT",
      "SIMPLE_EXPRESSION": 4,
      "4": "SIMPLE_EXPRESSION",
      "INTERPOLATION": 5,
      "5": "INTERPOLATION",
      "ATTRIBUTE": 6,
      "6": "ATTRIBUTE",
      "DIRECTIVE": 7,
      "7": "DIRECTIVE",
      "COMPOUND_EXPRESSION": 8,
      "8": "COMPOUND_EXPRESSION",
      "IF": 9,
      "9": "IF",
      "IF_BRANCH": 10,
      "10": "IF_BRANCH",
      "FOR": 11,
      "11": "FOR",
      "TEXT_CALL": 12,
      "12": "TEXT_CALL",
      "VNODE_CALL": 13,
      "13": "VNODE_CALL",
      "JS_CALL_EXPRESSION": 14,
      "14": "JS_CALL_EXPRESSION",
      "JS_OBJECT_EXPRESSION": 15,
      "15": "JS_OBJECT_EXPRESSION",
      "JS_PROPERTY": 16,
      "16": "JS_PROPERTY",
      "JS_ARRAY_EXPRESSION": 17,
      "17": "JS_ARRAY_EXPRESSION",
      "JS_FUNCTION_EXPRESSION": 18,
      "18": "JS_FUNCTION_EXPRESSION",
      "JS_CONDITIONAL_EXPRESSION": 19,
      "19": "JS_CONDITIONAL_EXPRESSION",
      "JS_CACHE_EXPRESSION": 20,
      "20": "JS_CACHE_EXPRESSION",
      "JS_BLOCK_STATEMENT": 21,
      "21": "JS_BLOCK_STATEMENT",
      "JS_TEMPLATE_LITERAL": 22,
      "22": "JS_TEMPLATE_LITERAL",
      "JS_IF_STATEMENT": 23,
      "23": "JS_IF_STATEMENT",
      "JS_ASSIGNMENT_EXPRESSION": 24,
      "24": "JS_ASSIGNMENT_EXPRESSION",
      "JS_SEQUENCE_EXPRESSION": 25,
      "25": "JS_SEQUENCE_EXPRESSION",
      "JS_RETURN_STATEMENT": 26,
      "26": "JS_RETURN_STATEMENT"
    };
    ElementTypes = {
      "ELEMENT": 0,
      "0": "ELEMENT",
      "COMPONENT": 1,
      "1": "COMPONENT",
      "SLOT": 2,
      "2": "SLOT",
      "TEMPLATE": 3,
      "3": "TEMPLATE"
    };
    ConstantTypes = {
      "NOT_CONSTANT": 0,
      "0": "NOT_CONSTANT",
      "CAN_SKIP_PATCH": 1,
      "1": "CAN_SKIP_PATCH",
      "CAN_HOIST": 2,
      "2": "CAN_HOIST",
      "CAN_STRINGIFY": 3,
      "3": "CAN_STRINGIFY"
    };
    locStub = {
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 },
      source: ""
    };
    defaultDelimitersOpen = new Uint8Array([123, 123]);
    defaultDelimitersClose = new Uint8Array([125, 125]);
    Sequences = {
      Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
      // CDATA[
      CdataEnd: new Uint8Array([93, 93, 62]),
      // ]]>
      CommentEnd: new Uint8Array([45, 45, 62]),
      // `-->`
      ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
      // `<\/script`
      StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
      // `</style`
      TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
      // `</title`
      TextareaEnd: new Uint8Array([
        60,
        47,
        116,
        101,
        120,
        116,
        97,
        114,
        101,
        97
      ])
      // `</textarea
    };
    Tokenizer = class {
      constructor(stack2, cbs) {
        this.stack = stack2;
        this.cbs = cbs;
        this.state = 1;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.entityStart = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.inXML = false;
        this.inVPre = false;
        this.newlines = [];
        this.mode = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
        this.delimiterIndex = -1;
        this.currentSequence = void 0;
        this.sequenceIndex = 0;
      }
      get inSFCRoot() {
        return this.mode === 2 && this.stack.length === 0;
      }
      reset() {
        this.state = 1;
        this.mode = 0;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = 1;
        this.inRCDATA = false;
        this.currentSequence = void 0;
        this.newlines.length = 0;
        this.delimiterOpen = defaultDelimitersOpen;
        this.delimiterClose = defaultDelimitersClose;
      }
      /**
       * Generate Position object with line / column information using recorded
       * newline positions. We know the index is always going to be an already
       * processed index, so all the newlines up to this index should have been
       * recorded.
       */
      getPos(index) {
        let line = 1;
        let column = index + 1;
        for (let i = this.newlines.length - 1; i >= 0; i--) {
          const newlineIndex = this.newlines[i];
          if (index > newlineIndex) {
            line = i + 2;
            column = index - newlineIndex;
            break;
          }
        }
        return {
          column,
          line,
          offset: index
        };
      }
      peek() {
        return this.buffer.charCodeAt(this.index + 1);
      }
      stateText(c) {
        if (c === 60) {
          if (this.index > this.sectionStart) {
            this.cbs.ontext(this.sectionStart, this.index);
          }
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!this.inVPre && c === this.delimiterOpen[0]) {
          this.state = 2;
          this.delimiterIndex = 0;
          this.stateInterpolationOpen(c);
        }
      }
      stateInterpolationOpen(c) {
        if (c === this.delimiterOpen[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterOpen.length - 1) {
            const start = this.index + 1 - this.delimiterOpen.length;
            if (start > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, start);
            }
            this.state = 3;
            this.sectionStart = start;
          } else {
            this.delimiterIndex++;
          }
        } else if (this.inRCDATA) {
          this.state = 32;
          this.stateInRCDATA(c);
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInterpolation(c) {
        if (c === this.delimiterClose[0]) {
          this.state = 4;
          this.delimiterIndex = 0;
          this.stateInterpolationClose(c);
        }
      }
      stateInterpolationClose(c) {
        if (c === this.delimiterClose[this.delimiterIndex]) {
          if (this.delimiterIndex === this.delimiterClose.length - 1) {
            this.cbs.oninterpolation(this.sectionStart, this.index + 1);
            if (this.inRCDATA) {
              this.state = 32;
            } else {
              this.state = 1;
            }
            this.sectionStart = this.index + 1;
          } else {
            this.delimiterIndex++;
          }
        } else {
          this.state = 3;
          this.stateInterpolation(c);
        }
      }
      stateSpecialStartSequence(c) {
        const isEnd = this.sequenceIndex === this.currentSequence.length;
        const isMatch = isEnd ? (
          // If we are at the end of the sequence, make sure the tag name has ended
          isEndOfTagSection(c)
        ) : (
          // Otherwise, do a case-insensitive comparison
          (c | 32) === this.currentSequence[this.sequenceIndex]
        );
        if (!isMatch) {
          this.inRCDATA = false;
        } else if (!isEnd) {
          this.sequenceIndex++;
          return;
        }
        this.sequenceIndex = 0;
        this.state = 6;
        this.stateInTagName(c);
      }
      /** Look for an end tag. For <title> and <textarea>, also decode entities. */
      stateInRCDATA(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
          if (c === 62 || isWhitespace(c)) {
            const endOfText = this.index - this.currentSequence.length;
            if (this.sectionStart < endOfText) {
              const actualIndex = this.index;
              this.index = endOfText;
              this.cbs.ontext(this.sectionStart, endOfText);
              this.index = actualIndex;
            }
            this.sectionStart = endOfText + 2;
            this.stateInClosingTagName(c);
            this.inRCDATA = false;
            return;
          }
          this.sequenceIndex = 0;
        }
        if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
          this.sequenceIndex += 1;
        } else if (this.sequenceIndex === 0) {
          if (this.currentSequence === Sequences.TitleEnd || this.currentSequence === Sequences.TextareaEnd && !this.inSFCRoot) {
            if (c === this.delimiterOpen[0]) {
              this.state = 2;
              this.delimiterIndex = 0;
              this.stateInterpolationOpen(c);
            }
          } else if (this.fastForwardTo(60)) {
            this.sequenceIndex = 1;
          }
        } else {
          this.sequenceIndex = Number(c === 60);
        }
      }
      stateCDATASequence(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
          if (++this.sequenceIndex === Sequences.Cdata.length) {
            this.state = 28;
            this.currentSequence = Sequences.CdataEnd;
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
          }
        } else {
          this.sequenceIndex = 0;
          this.state = 23;
          this.stateInDeclaration(c);
        }
      }
      /**
       * When we wait for one specific character, we can speed things up
       * by skipping through the buffer until we find it.
       *
       * @returns Whether the character was found.
       */
      fastForwardTo(c) {
        while (++this.index < this.buffer.length) {
          const cc = this.buffer.charCodeAt(this.index);
          if (cc === 10) {
            this.newlines.push(this.index);
          }
          if (cc === c) {
            return true;
          }
        }
        this.index = this.buffer.length - 1;
        return false;
      }
      /**
       * Comments and CDATA end with `-->` and `]]>`.
       *
       * Their common qualities are:
       * - Their end sequences have a distinct character they start with.
       * - That character is then repeated, so we have to check multiple repeats.
       * - All characters but the start character of the sequence can be skipped.
       */
      stateInCommentLike(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
          if (++this.sequenceIndex === this.currentSequence.length) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, this.index - 2);
            } else {
              this.cbs.oncomment(this.sectionStart, this.index - 2);
            }
            this.sequenceIndex = 0;
            this.sectionStart = this.index + 1;
            this.state = 1;
          }
        } else if (this.sequenceIndex === 0) {
          if (this.fastForwardTo(this.currentSequence[0])) {
            this.sequenceIndex = 1;
          }
        } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
          this.sequenceIndex = 0;
        }
      }
      startSpecial(sequence, offset) {
        this.enterRCDATA(sequence, offset);
        this.state = 31;
      }
      enterRCDATA(sequence, offset) {
        this.inRCDATA = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
      }
      stateBeforeTagName(c) {
        if (c === 33) {
          this.state = 22;
          this.sectionStart = this.index + 1;
        } else if (c === 63) {
          this.state = 24;
          this.sectionStart = this.index + 1;
        } else if (isTagStartChar(c)) {
          this.sectionStart = this.index;
          if (this.mode === 0) {
            this.state = 6;
          } else if (this.inSFCRoot) {
            this.state = 34;
          } else if (!this.inXML) {
            if (c === 116) {
              this.state = 30;
            } else {
              this.state = c === 115 ? 29 : 6;
            }
          } else {
            this.state = 6;
          }
        } else if (c === 47) {
          this.state = 8;
        } else {
          this.state = 1;
          this.stateText(c);
        }
      }
      stateInTagName(c) {
        if (isEndOfTagSection(c)) {
          this.handleTagName(c);
        }
      }
      stateInSFCRootTagName(c) {
        if (isEndOfTagSection(c)) {
          const tag = this.buffer.slice(this.sectionStart, this.index);
          if (tag !== "template") {
            this.enterRCDATA(toCharCodes(`</` + tag), 0);
          }
          this.handleTagName(c);
        }
      }
      handleTagName(c) {
        this.cbs.onopentagname(this.sectionStart, this.index);
        this.sectionStart = -1;
        this.state = 11;
        this.stateBeforeAttrName(c);
      }
      stateBeforeClosingTagName(c) {
        if (isWhitespace(c))
          ;
        else if (c === 62) {
          if (true) {
            this.cbs.onerr(14, this.index);
          }
          this.state = 1;
          this.sectionStart = this.index + 1;
        } else {
          this.state = isTagStartChar(c) ? 9 : 27;
          this.sectionStart = this.index;
        }
      }
      stateInClosingTagName(c) {
        if (c === 62 || isWhitespace(c)) {
          this.cbs.onclosetag(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.state = 10;
          this.stateAfterClosingTagName(c);
        }
      }
      stateAfterClosingTagName(c) {
        if (c === 62) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeAttrName(c) {
        if (c === 62) {
          this.cbs.onopentagend(this.index);
          if (this.inRCDATA) {
            this.state = 32;
          } else {
            this.state = 1;
          }
          this.sectionStart = this.index + 1;
        } else if (c === 47) {
          this.state = 7;
          if (this.peek() !== 62) {
            this.cbs.onerr(22, this.index);
          }
        } else if (c === 60 && this.peek() === 47) {
          this.cbs.onopentagend(this.index);
          this.state = 5;
          this.sectionStart = this.index;
        } else if (!isWhitespace(c)) {
          if (c === 61) {
            this.cbs.onerr(
              19,
              this.index
            );
          }
          this.handleAttrStart(c);
        }
      }
      handleAttrStart(c) {
        if (c === 118 && this.peek() === 45) {
          this.state = 13;
          this.sectionStart = this.index;
        } else if (c === 46 || c === 58 || c === 64 || c === 35) {
          this.cbs.ondirname(this.index, this.index + 1);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 12;
          this.sectionStart = this.index;
        }
      }
      stateInSelfClosingTag(c) {
        if (c === 62) {
          this.cbs.onselfclosingtag(this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
          this.inRCDATA = false;
        } else if (!isWhitespace(c)) {
          this.state = 11;
          this.stateBeforeAttrName(c);
        }
      }
      stateInAttrName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.onattribname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 34 || c === 39 || c === 60) {
          this.cbs.onerr(
            17,
            this.index
          );
        }
      }
      stateInDirName(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 58) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 14;
          this.sectionStart = this.index + 1;
        } else if (c === 46) {
          this.cbs.ondirname(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDirArg(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 91) {
          this.state = 15;
        } else if (c === 46) {
          this.cbs.ondirarg(this.sectionStart, this.index);
          this.state = 16;
          this.sectionStart = this.index + 1;
        }
      }
      stateInDynamicDirArg(c) {
        if (c === 93) {
          this.state = 14;
        } else if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirarg(this.sectionStart, this.index + 1);
          this.handleAttrNameEnd(c);
          if (true) {
            this.cbs.onerr(
              27,
              this.index
            );
          }
        }
      }
      stateInDirModifier(c) {
        if (c === 61 || isEndOfTagSection(c)) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.handleAttrNameEnd(c);
        } else if (c === 46) {
          this.cbs.ondirmodifier(this.sectionStart, this.index);
          this.sectionStart = this.index + 1;
        }
      }
      handleAttrNameEnd(c) {
        this.sectionStart = this.index;
        this.state = 17;
        this.cbs.onattribnameend(this.index);
        this.stateAfterAttrName(c);
      }
      stateAfterAttrName(c) {
        if (c === 61) {
          this.state = 18;
        } else if (c === 47 || c === 62) {
          this.cbs.onattribend(0, this.sectionStart);
          this.sectionStart = -1;
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (!isWhitespace(c)) {
          this.cbs.onattribend(0, this.sectionStart);
          this.handleAttrStart(c);
        }
      }
      stateBeforeAttrValue(c) {
        if (c === 34) {
          this.state = 19;
          this.sectionStart = this.index + 1;
        } else if (c === 39) {
          this.state = 20;
          this.sectionStart = this.index + 1;
        } else if (!isWhitespace(c)) {
          this.sectionStart = this.index;
          this.state = 21;
          this.stateInAttrValueNoQuotes(c);
        }
      }
      handleInAttrValue(c, quote) {
        if (c === quote || this.fastForwardTo(quote)) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(
            quote === 34 ? 3 : 2,
            this.index + 1
          );
          this.state = 11;
        }
      }
      stateInAttrValueDoubleQuotes(c) {
        this.handleInAttrValue(c, 34);
      }
      stateInAttrValueSingleQuotes(c) {
        this.handleInAttrValue(c, 39);
      }
      stateInAttrValueNoQuotes(c) {
        if (isWhitespace(c) || c === 62) {
          this.cbs.onattribdata(this.sectionStart, this.index);
          this.sectionStart = -1;
          this.cbs.onattribend(1, this.index);
          this.state = 11;
          this.stateBeforeAttrName(c);
        } else if (c === 34 || c === 39 || c === 60 || c === 61 || c === 96) {
          this.cbs.onerr(
            18,
            this.index
          );
        } else
          ;
      }
      stateBeforeDeclaration(c) {
        if (c === 91) {
          this.state = 26;
          this.sequenceIndex = 0;
        } else {
          this.state = c === 45 ? 25 : 23;
        }
      }
      stateInDeclaration(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateInProcessingInstruction(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.onprocessinginstruction(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeComment(c) {
        if (c === 45) {
          this.state = 28;
          this.currentSequence = Sequences.CommentEnd;
          this.sequenceIndex = 2;
          this.sectionStart = this.index + 1;
        } else {
          this.state = 23;
        }
      }
      stateInSpecialComment(c) {
        if (c === 62 || this.fastForwardTo(62)) {
          this.cbs.oncomment(this.sectionStart, this.index);
          this.state = 1;
          this.sectionStart = this.index + 1;
        }
      }
      stateBeforeSpecialS(c) {
        if (c === Sequences.ScriptEnd[3]) {
          this.startSpecial(Sequences.ScriptEnd, 4);
        } else if (c === Sequences.StyleEnd[3]) {
          this.startSpecial(Sequences.StyleEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      stateBeforeSpecialT(c) {
        if (c === Sequences.TitleEnd[3]) {
          this.startSpecial(Sequences.TitleEnd, 4);
        } else if (c === Sequences.TextareaEnd[3]) {
          this.startSpecial(Sequences.TextareaEnd, 4);
        } else {
          this.state = 6;
          this.stateInTagName(c);
        }
      }
      startEntity() {
      }
      stateInEntity() {
      }
      /**
       * Iterates through the buffer, calling the function corresponding to the current state.
       *
       * States that are more likely to be hit are higher up, as a performance improvement.
       */
      parse(input) {
        this.buffer = input;
        while (this.index < this.buffer.length) {
          const c = this.buffer.charCodeAt(this.index);
          if (c === 10) {
            this.newlines.push(this.index);
          }
          switch (this.state) {
            case 1: {
              this.stateText(c);
              break;
            }
            case 2: {
              this.stateInterpolationOpen(c);
              break;
            }
            case 3: {
              this.stateInterpolation(c);
              break;
            }
            case 4: {
              this.stateInterpolationClose(c);
              break;
            }
            case 31: {
              this.stateSpecialStartSequence(c);
              break;
            }
            case 32: {
              this.stateInRCDATA(c);
              break;
            }
            case 26: {
              this.stateCDATASequence(c);
              break;
            }
            case 19: {
              this.stateInAttrValueDoubleQuotes(c);
              break;
            }
            case 12: {
              this.stateInAttrName(c);
              break;
            }
            case 13: {
              this.stateInDirName(c);
              break;
            }
            case 14: {
              this.stateInDirArg(c);
              break;
            }
            case 15: {
              this.stateInDynamicDirArg(c);
              break;
            }
            case 16: {
              this.stateInDirModifier(c);
              break;
            }
            case 28: {
              this.stateInCommentLike(c);
              break;
            }
            case 27: {
              this.stateInSpecialComment(c);
              break;
            }
            case 11: {
              this.stateBeforeAttrName(c);
              break;
            }
            case 6: {
              this.stateInTagName(c);
              break;
            }
            case 34: {
              this.stateInSFCRootTagName(c);
              break;
            }
            case 9: {
              this.stateInClosingTagName(c);
              break;
            }
            case 5: {
              this.stateBeforeTagName(c);
              break;
            }
            case 17: {
              this.stateAfterAttrName(c);
              break;
            }
            case 20: {
              this.stateInAttrValueSingleQuotes(c);
              break;
            }
            case 18: {
              this.stateBeforeAttrValue(c);
              break;
            }
            case 8: {
              this.stateBeforeClosingTagName(c);
              break;
            }
            case 10: {
              this.stateAfterClosingTagName(c);
              break;
            }
            case 29: {
              this.stateBeforeSpecialS(c);
              break;
            }
            case 30: {
              this.stateBeforeSpecialT(c);
              break;
            }
            case 21: {
              this.stateInAttrValueNoQuotes(c);
              break;
            }
            case 7: {
              this.stateInSelfClosingTag(c);
              break;
            }
            case 23: {
              this.stateInDeclaration(c);
              break;
            }
            case 22: {
              this.stateBeforeDeclaration(c);
              break;
            }
            case 25: {
              this.stateBeforeComment(c);
              break;
            }
            case 24: {
              this.stateInProcessingInstruction(c);
              break;
            }
            case 33: {
              this.stateInEntity();
              break;
            }
          }
          this.index++;
        }
        this.cleanup();
        this.finish();
      }
      /**
       * Remove data that has already been consumed from the buffer.
       */
      cleanup() {
        if (this.sectionStart !== this.index) {
          if (this.state === 1 || this.state === 32 && this.sequenceIndex === 0) {
            this.cbs.ontext(this.sectionStart, this.index);
            this.sectionStart = this.index;
          } else if (this.state === 19 || this.state === 20 || this.state === 21) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = this.index;
          }
        }
      }
      finish() {
        this.handleTrailingData();
        this.cbs.onend();
      }
      /** Handle any trailing data. */
      handleTrailingData() {
        const endIndex = this.buffer.length;
        if (this.sectionStart >= endIndex) {
          return;
        }
        if (this.state === 28) {
          if (this.currentSequence === Sequences.CdataEnd) {
            this.cbs.oncdata(this.sectionStart, endIndex);
          } else {
            this.cbs.oncomment(this.sectionStart, endIndex);
          }
        } else if (this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9)
          ;
        else {
          this.cbs.ontext(this.sectionStart, endIndex);
        }
      }
      emitCodePoint(cp, consumed) {
      }
    };
    CompilerDeprecationTypes = {
      "COMPILER_IS_ON_ELEMENT": "COMPILER_IS_ON_ELEMENT",
      "COMPILER_V_BIND_SYNC": "COMPILER_V_BIND_SYNC",
      "COMPILER_V_BIND_OBJECT_ORDER": "COMPILER_V_BIND_OBJECT_ORDER",
      "COMPILER_V_ON_NATIVE": "COMPILER_V_ON_NATIVE",
      "COMPILER_V_IF_V_FOR_PRECEDENCE": "COMPILER_V_IF_V_FOR_PRECEDENCE",
      "COMPILER_NATIVE_TEMPLATE": "COMPILER_NATIVE_TEMPLATE",
      "COMPILER_INLINE_TEMPLATE": "COMPILER_INLINE_TEMPLATE",
      "COMPILER_FILTERS": "COMPILER_FILTERS"
    };
    deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTERS"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    ErrorCodes = {
      "ABRUPT_CLOSING_OF_EMPTY_COMMENT": 0,
      "0": "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
      "CDATA_IN_HTML_CONTENT": 1,
      "1": "CDATA_IN_HTML_CONTENT",
      "DUPLICATE_ATTRIBUTE": 2,
      "2": "DUPLICATE_ATTRIBUTE",
      "END_TAG_WITH_ATTRIBUTES": 3,
      "3": "END_TAG_WITH_ATTRIBUTES",
      "END_TAG_WITH_TRAILING_SOLIDUS": 4,
      "4": "END_TAG_WITH_TRAILING_SOLIDUS",
      "EOF_BEFORE_TAG_NAME": 5,
      "5": "EOF_BEFORE_TAG_NAME",
      "EOF_IN_CDATA": 6,
      "6": "EOF_IN_CDATA",
      "EOF_IN_COMMENT": 7,
      "7": "EOF_IN_COMMENT",
      "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT": 8,
      "8": "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
      "EOF_IN_TAG": 9,
      "9": "EOF_IN_TAG",
      "INCORRECTLY_CLOSED_COMMENT": 10,
      "10": "INCORRECTLY_CLOSED_COMMENT",
      "INCORRECTLY_OPENED_COMMENT": 11,
      "11": "INCORRECTLY_OPENED_COMMENT",
      "INVALID_FIRST_CHARACTER_OF_TAG_NAME": 12,
      "12": "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
      "MISSING_ATTRIBUTE_VALUE": 13,
      "13": "MISSING_ATTRIBUTE_VALUE",
      "MISSING_END_TAG_NAME": 14,
      "14": "MISSING_END_TAG_NAME",
      "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES": 15,
      "15": "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
      "NESTED_COMMENT": 16,
      "16": "NESTED_COMMENT",
      "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME": 17,
      "17": "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
      "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE": 18,
      "18": "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
      "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME": 19,
      "19": "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
      "UNEXPECTED_NULL_CHARACTER": 20,
      "20": "UNEXPECTED_NULL_CHARACTER",
      "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME": 21,
      "21": "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
      "UNEXPECTED_SOLIDUS_IN_TAG": 22,
      "22": "UNEXPECTED_SOLIDUS_IN_TAG",
      "X_INVALID_END_TAG": 23,
      "23": "X_INVALID_END_TAG",
      "X_MISSING_END_TAG": 24,
      "24": "X_MISSING_END_TAG",
      "X_MISSING_INTERPOLATION_END": 25,
      "25": "X_MISSING_INTERPOLATION_END",
      "X_MISSING_DIRECTIVE_NAME": 26,
      "26": "X_MISSING_DIRECTIVE_NAME",
      "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END": 27,
      "27": "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
      "X_V_IF_NO_EXPRESSION": 28,
      "28": "X_V_IF_NO_EXPRESSION",
      "X_V_IF_SAME_KEY": 29,
      "29": "X_V_IF_SAME_KEY",
      "X_V_ELSE_NO_ADJACENT_IF": 30,
      "30": "X_V_ELSE_NO_ADJACENT_IF",
      "X_V_FOR_NO_EXPRESSION": 31,
      "31": "X_V_FOR_NO_EXPRESSION",
      "X_V_FOR_MALFORMED_EXPRESSION": 32,
      "32": "X_V_FOR_MALFORMED_EXPRESSION",
      "X_V_FOR_TEMPLATE_KEY_PLACEMENT": 33,
      "33": "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
      "X_V_BIND_NO_EXPRESSION": 34,
      "34": "X_V_BIND_NO_EXPRESSION",
      "X_V_ON_NO_EXPRESSION": 35,
      "35": "X_V_ON_NO_EXPRESSION",
      "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET": 36,
      "36": "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
      "X_V_SLOT_MIXED_SLOT_USAGE": 37,
      "37": "X_V_SLOT_MIXED_SLOT_USAGE",
      "X_V_SLOT_DUPLICATE_SLOT_NAMES": 38,
      "38": "X_V_SLOT_DUPLICATE_SLOT_NAMES",
      "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN": 39,
      "39": "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
      "X_V_SLOT_MISPLACED": 40,
      "40": "X_V_SLOT_MISPLACED",
      "X_V_MODEL_NO_EXPRESSION": 41,
      "41": "X_V_MODEL_NO_EXPRESSION",
      "X_V_MODEL_MALFORMED_EXPRESSION": 42,
      "42": "X_V_MODEL_MALFORMED_EXPRESSION",
      "X_V_MODEL_ON_SCOPE_VARIABLE": 43,
      "43": "X_V_MODEL_ON_SCOPE_VARIABLE",
      "X_V_MODEL_ON_PROPS": 44,
      "44": "X_V_MODEL_ON_PROPS",
      "X_INVALID_EXPRESSION": 45,
      "45": "X_INVALID_EXPRESSION",
      "X_KEEP_ALIVE_INVALID_CHILDREN": 46,
      "46": "X_KEEP_ALIVE_INVALID_CHILDREN",
      "X_PREFIX_ID_NOT_SUPPORTED": 47,
      "47": "X_PREFIX_ID_NOT_SUPPORTED",
      "X_MODULE_MODE_NOT_SUPPORTED": 48,
      "48": "X_MODULE_MODE_NOT_SUPPORTED",
      "X_CACHE_HANDLER_NOT_SUPPORTED": 49,
      "49": "X_CACHE_HANDLER_NOT_SUPPORTED",
      "X_SCOPE_ID_NOT_SUPPORTED": 50,
      "50": "X_SCOPE_ID_NOT_SUPPORTED",
      "X_VNODE_HOOKS": 51,
      "51": "X_VNODE_HOOKS",
      "X_V_BIND_INVALID_SAME_NAME_ARGUMENT": 52,
      "52": "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
      "__EXTEND_POINT__": 53,
      "53": "__EXTEND_POINT__"
    };
    errorMessages = {
      // parse errors
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      // transform errors
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [52]: `v-bind with same-name shorthand only allows static argument.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
      [45]: `Error parsing JavaScript expression: `,
      [46]: `<KeepAlive> expects exactly one child component.`,
      [51]: `@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.`,
      // generic errors
      [47]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [48]: `ES module mode is not supported in this build of compiler.`,
      [49]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [50]: `"scopeId" option is only supported in module mode.`,
      // just to fulfill types
      [53]: ``
    };
    isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    TS_NODE_TYPES = [
      "TSAsExpression",
      // foo as number
      "TSTypeAssertion",
      // (<number>foo)
      "TSNonNullExpression",
      // foo!
      "TSInstantiationExpression",
      // foo<string>
      "TSSatisfiesExpression"
      // foo satisfies T
    ];
    isStaticExp = (p) => p.type === 4 && p.isStatic;
    nonIdentifierRE = /^\d|[^\$\w]/;
    isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    isMemberExpressionNode = NOOP;
    isMemberExpression = isMemberExpressionBrowser;
    propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    defaultParserOptions = {
      parseMode: "base",
      ns: 0,
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true,
      prefixIdentifiers: false
    };
    currentOptions = defaultParserOptions;
    currentRoot = null;
    currentInput = "";
    currentOpenTag = null;
    currentProp = null;
    currentAttrValue = "";
    currentAttrStartIndex = -1;
    currentAttrEndIndex = -1;
    inPre = 0;
    inVPre = false;
    currentVPreBoundary = null;
    stack = [];
    tokenizer = new Tokenizer(stack, {
      onerr: emitError,
      ontext(start, end) {
        onText(getSlice(start, end), start, end);
      },
      ontextentity(char, start, end) {
        onText(char, start, end);
      },
      oninterpolation(start, end) {
        if (inVPre) {
          return onText(getSlice(start, end), start, end);
        }
        let innerStart = start + tokenizer.delimiterOpen.length;
        let innerEnd = end - tokenizer.delimiterClose.length;
        while (isWhitespace(currentInput.charCodeAt(innerStart))) {
          innerStart++;
        }
        while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
          innerEnd--;
        }
        let exp = getSlice(innerStart, innerEnd);
        if (exp.includes("&")) {
          {
            exp = currentOptions.decodeEntities(exp, false);
          }
        }
        addNode({
          type: 5,
          content: createExp(exp, false, getLoc(innerStart, innerEnd)),
          loc: getLoc(start, end)
        });
      },
      onopentagname(start, end) {
        const name = getSlice(start, end);
        currentOpenTag = {
          type: 1,
          tag: name,
          ns: currentOptions.getNamespace(name, stack[0], currentOptions.ns),
          tagType: 0,
          // will be refined on tag close
          props: [],
          children: [],
          loc: getLoc(start - 1, end),
          codegenNode: void 0
        };
      },
      onopentagend(end) {
        endOpenTag(end);
      },
      onclosetag(start, end) {
        const name = getSlice(start, end);
        if (!currentOptions.isVoidTag(name)) {
          let found = false;
          for (let i = 0; i < stack.length; i++) {
            const e = stack[i];
            if (e.tag.toLowerCase() === name.toLowerCase()) {
              found = true;
              if (i > 0) {
                emitError(24, stack[0].loc.start.offset);
              }
              for (let j = 0; j <= i; j++) {
                const el = stack.shift();
                onCloseTag(el, end, j < i);
              }
              break;
            }
          }
          if (!found) {
            emitError(23, backTrack(start, 60));
          }
        }
      },
      onselfclosingtag(end) {
        const name = currentOpenTag.tag;
        currentOpenTag.isSelfClosing = true;
        endOpenTag(end);
        if (stack[0] && stack[0].tag === name) {
          onCloseTag(stack.shift(), end);
        }
      },
      onattribname(start, end) {
        currentProp = {
          type: 6,
          name: getSlice(start, end),
          nameLoc: getLoc(start, end),
          value: void 0,
          loc: getLoc(start)
        };
      },
      ondirname(start, end) {
        const raw = getSlice(start, end);
        const name = raw === "." || raw === ":" ? "bind" : raw === "@" ? "on" : raw === "#" ? "slot" : raw.slice(2);
        if (!inVPre && name === "") {
          emitError(26, start);
        }
        if (inVPre || name === "") {
          currentProp = {
            type: 6,
            name: raw,
            nameLoc: getLoc(start, end),
            value: void 0,
            loc: getLoc(start)
          };
        } else {
          currentProp = {
            type: 7,
            name,
            rawName: raw,
            exp: void 0,
            arg: void 0,
            modifiers: raw === "." ? ["prop"] : [],
            loc: getLoc(start)
          };
          if (name === "pre") {
            inVPre = tokenizer.inVPre = true;
            currentVPreBoundary = currentOpenTag;
            const props = currentOpenTag.props;
            for (let i = 0; i < props.length; i++) {
              if (props[i].type === 7) {
                props[i] = dirToAttr(props[i]);
              }
            }
          }
        }
      },
      ondirarg(start, end) {
        if (start === end)
          return;
        const arg = getSlice(start, end);
        if (inVPre) {
          currentProp.name += arg;
          setLocEnd(currentProp.nameLoc, end);
        } else {
          const isStatic = arg[0] !== `[`;
          currentProp.arg = createExp(
            isStatic ? arg : arg.slice(1, -1),
            isStatic,
            getLoc(start, end),
            isStatic ? 3 : 0
          );
        }
      },
      ondirmodifier(start, end) {
        const mod = getSlice(start, end);
        if (inVPre) {
          currentProp.name += "." + mod;
          setLocEnd(currentProp.nameLoc, end);
        } else if (currentProp.name === "slot") {
          const arg = currentProp.arg;
          if (arg) {
            arg.content += "." + mod;
            setLocEnd(arg.loc, end);
          }
        } else {
          currentProp.modifiers.push(mod);
        }
      },
      onattribdata(start, end) {
        currentAttrValue += getSlice(start, end);
        if (currentAttrStartIndex < 0)
          currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribentity(char, start, end) {
        currentAttrValue += char;
        if (currentAttrStartIndex < 0)
          currentAttrStartIndex = start;
        currentAttrEndIndex = end;
      },
      onattribnameend(end) {
        const start = currentProp.loc.start.offset;
        const name = getSlice(start, end);
        if (currentProp.type === 7) {
          currentProp.rawName = name;
        }
        if (currentOpenTag.props.some(
          (p) => (p.type === 7 ? p.rawName : p.name) === name
        )) {
          emitError(2, start);
        }
      },
      onattribend(quote, end) {
        if (currentOpenTag && currentProp) {
          setLocEnd(currentProp.loc, end);
          if (quote !== 0) {
            if (currentAttrValue.includes("&")) {
              currentAttrValue = currentOptions.decodeEntities(
                currentAttrValue,
                true
              );
            }
            if (currentProp.type === 6) {
              if (currentProp.name === "class") {
                currentAttrValue = condense(currentAttrValue).trim();
              }
              if (quote === 1 && !currentAttrValue) {
                emitError(13, end);
              }
              currentProp.value = {
                type: 2,
                content: currentAttrValue,
                loc: quote === 1 ? getLoc(currentAttrStartIndex, currentAttrEndIndex) : getLoc(currentAttrStartIndex - 1, currentAttrEndIndex + 1)
              };
              if (tokenizer.inSFCRoot && currentOpenTag.tag === "template" && currentProp.name === "lang" && currentAttrValue && currentAttrValue !== "html") {
                tokenizer.enterRCDATA(toCharCodes(`</template`), 0);
              }
            } else {
              let expParseMode = 0;
              currentProp.exp = createExp(
                currentAttrValue,
                false,
                getLoc(currentAttrStartIndex, currentAttrEndIndex),
                0,
                expParseMode
              );
              if (currentProp.name === "for") {
                currentProp.forParseResult = parseForExpression(currentProp.exp);
              }
              let syncIndex = -1;
              if (currentProp.name === "bind" && (syncIndex = currentProp.modifiers.indexOf("sync")) > -1 && checkCompatEnabled(
                "COMPILER_V_BIND_SYNC",
                currentOptions,
                currentProp.loc,
                currentProp.rawName
              )) {
                currentProp.name = "model";
                currentProp.modifiers.splice(syncIndex, 1);
              }
            }
          }
          if (currentProp.type !== 7 || currentProp.name !== "pre") {
            currentOpenTag.props.push(currentProp);
          }
        }
        currentAttrValue = "";
        currentAttrStartIndex = currentAttrEndIndex = -1;
      },
      oncomment(start, end) {
        if (currentOptions.comments) {
          addNode({
            type: 3,
            content: getSlice(start, end),
            loc: getLoc(start - 4, end + 3)
          });
        }
      },
      onend() {
        const end = currentInput.length;
        if (tokenizer.state !== 1) {
          switch (tokenizer.state) {
            case 5:
            case 8:
              emitError(5, end);
              break;
            case 3:
            case 4:
              emitError(
                25,
                tokenizer.sectionStart
              );
              break;
            case 28:
              if (tokenizer.currentSequence === Sequences.CdataEnd) {
                emitError(6, end);
              } else {
                emitError(7, end);
              }
              break;
            case 6:
            case 7:
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              emitError(9, end);
              break;
          }
        }
        for (let index = 0; index < stack.length; index++) {
          onCloseTag(stack[index], end - 1);
          emitError(24, stack[index].loc.start.offset);
        }
      },
      oncdata(start, end) {
        if (stack[0].ns !== 0) {
          onText(getSlice(start, end), start, end);
        } else {
          emitError(1, start - 9);
        }
      },
      onprocessinginstruction(start) {
        if ((stack[0] ? stack[0].ns : currentOptions.ns) === 0) {
          emitError(
            21,
            start - 1
          );
        }
      }
    });
    forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    stripParensRE = /^\(|\)$/g;
    specialTemplateDir = /* @__PURE__ */ new Set(["if", "else", "else-if", "for", "slot"]);
    windowsNewlineRE = /\r\n/g;
    allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    PURE_ANNOTATION = `/*#__PURE__*/`;
    aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    prohibitedKeywordRE = new RegExp(
      "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
    );
    stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
    transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(
          node.content,
          context
        );
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(
                exp,
                context,
                // slot args must be processed as function params
                dir.name === "slot"
              );
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    transformIf = createStructuralDirectiveTransform(
      /^(if|else|else-if)$/,
      (node, dir, context) => {
        return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(
                branch,
                key,
                context
              );
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(
                branch,
                key + ifNode.branches.length - 1,
                context
              );
            }
          };
        });
      }
    );
    transformFor = createStructuralDirectiveTransform(
      "for",
      (node, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`);
          const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(
            context,
            helper(FRAGMENT),
            void 0,
            renderExp,
            fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),
            void 0,
            void 0,
            true,
            !isStableFragment,
            false,
            node.loc
          );
          return () => {
            let childBlock;
            const { children } = forNode;
            if (isTemplate) {
              node.children.some((c) => {
                if (c.type === 1) {
                  const key = findProp(c, "key");
                  if (key) {
                    context.onError(
                      createCompilerError(
                        33,
                        key.loc
                      )
                    );
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(
                context,
                helper(FRAGMENT),
                keyProperty ? createObjectExpression([keyProperty]) : void 0,
                node.children,
                64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``),
                void 0,
                void 0,
                true,
                void 0,
                false
              );
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(
                    getVNodeBlockHelper(context.inSSR, childBlock.isComponent)
                  );
                } else {
                  removeHelper(
                    getVNodeHelper(context.inSSR, childBlock.isComponent)
                  );
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(
                createForLoopParams(forNode.parseResult, [
                  createSimpleExpression(`_cached`)
                ])
              );
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context.helperString(
                    IS_MEMO_SAME
                  )}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(
                loop,
                createSimpleExpression(`_cache`),
                createSimpleExpression(String(context.cached++))
              );
            } else {
              renderExp.arguments.push(
                createFunctionExpression(
                  createForLoopParams(forNode.parseResult),
                  childBlock,
                  true
                )
              );
            }
          };
        });
      }
    );
    defaultFallback = createSimpleExpression(`undefined`, false);
    trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          vSlot.exp;
          context.scopes.vSlot++;
          return () => {
            context.scopes.vSlot--;
          };
        }
      }
    };
    trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.forParseResult;
        if (result) {
          finalizeForParseResult(result, context);
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    buildClientSlotFn = (props, _vForExp, children, loc) => createFunctionExpression(
      props,
      children,
      false,
      true,
      children.length ? children[0].loc : loc
    );
    directiveImportMap = /* @__PURE__ */ new WeakMap();
    transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = (
          // dynamic component may resolve to plain elements
          isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && // <svg> and <foreignObject> must be forced into blocks so that block
          // updates inside get proper isSVG flag at runtime. (#639, #643)
          // This is technically web-specific, but splitting the logic out of core
          // leads to too much unnecessary complexity.
          (tag === "svg" || tag === "foreignObject")
        );
        if (props.length > 0) {
          const propsBuildResult = buildProps(
            node,
            context,
            void 0,
            isComponent2,
            isDynamicComponent
          );
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(
            directives.map((dir) => buildDirectiveArgs(dir, context))
          ) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
            if (node.children.length > 1) {
              context.onError(
                createCompilerError(46, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                })
              );
            }
          }
          const shouldBuildAsSlots = isComponent2 && // Teleport is not a real component and has dedicated runtime handling
          vnodeTag !== TELEPORT && // explained above.
          vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          if (true) {
            if (patchFlag < 0) {
              vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
            } else {
              const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
              vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
            }
          } else {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(
          context,
          vnodeTag,
          vnodeProps,
          vnodeChildren,
          vnodePatchFlag,
          vnodeDynamicProps,
          vnodeDirectives,
          !!shouldUseBlock,
          false,
          isComponent2,
          node.loc
        );
      };
    };
    transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(
          context.helper(RENDER_SLOT),
          slotArgs,
          loc
        );
      }
    };
    fnExpRE = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vnode")) {
            context.onError(createCompilerError(51, arg.loc));
          }
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          const eventString = node.tagType !== 0 || rawName.startsWith("vnode") || !/[A-Z]/.test(rawName) ? (
            // for non-element and vnode lifecycle event listeners, auto convert
            // it to camelCase. See issue #2249
            toHandlerKey(camelize(rawName))
          ) : (
            // preserve case for plain element listeners that have uppercase
            // letters, as these may be custom elements' custom events
            `on:${rawName}`
          );
          eventName = createSimpleExpression(eventString, true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (true) {
          validateBrowserExpression(
            exp,
            context,
            false,
            hasMultipleStatements
          );
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(
            eventName,
            exp || createSimpleExpression(`() => {}`, false, loc)
          )
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    transformBind = (dir, _node, context) => {
      const { modifiers, loc } = dir;
      const arg = dir.arg;
      let { exp } = dir;
      if (exp && exp.type === 4 && !exp.content.trim()) {
        {
          exp = void 0;
        }
      }
      if (!exp) {
        if (arg.type !== 4 || !arg.isStatic) {
          context.onError(
            createCompilerError(
              52,
              arg.loc
            )
          );
          return {
            props: [
              createObjectProperty(arg, createSimpleExpression("", true, loc))
            ]
          };
        }
        const propName = camelize(arg.content);
        exp = dir.exp = createSimpleExpression(propName, false, arg.loc);
      }
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText$1(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = createCompoundExpression(
                      [child],
                      child.loc
                    );
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || // if this is a plain element with a single text child, leave it
          // as-is since the runtime has dedicated fast path for this by directly
          // setting textContent of the element.
          // for component root it's always normalized anyway.
          children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && // #3756
          // custom directives can potentially add DOM elements arbitrarily,
          // we need to avoid setting textContent of the element at runtime
          // to avoid accidentally overwriting the DOM elements added
          // by the user through custom directives.
          !node.props.find(
            (p) => p.type === 7 && !context.directiveTransforms[p.name]
          ) && // in compat mode, <template> tags with no special directives
          // will be rendered as a fragment so its children must be
          // converted into vnodes.
          !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText$1(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(
                  1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``)
                );
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(
                  context.helper(CREATE_TEXT),
                  callArgs
                )
              };
            }
          }
        };
      }
    };
    seen$1 = /* @__PURE__ */ new WeakSet();
    transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen$1.has(node) || context.inVOnce || context.inSSR) {
          return;
        }
        seen$1.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(
              cur.codegenNode,
              true
              /* isVNode */
            );
          }
        };
      }
    };
    transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(
          createCompilerError(41, dir.loc)
        );
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      if (bindingType === "props" || bindingType === "props-aliased") {
        context.onError(createCompilerError(44, exp.loc));
        return createTransformProps();
      }
      const maybeRef = false;
      if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
        context.onError(
          createCompilerError(42, exp.loc)
        );
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${camelize(arg.content)}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, assignmentExp)
      ];
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(
          createObjectProperty(
            modifiersKey,
            createSimpleExpression(
              `{ ${modifiers} }`,
              false,
              dir.loc,
              2
            )
          )
        );
      }
      return createTransformProps(props);
    };
    validDivisionCharRE = /[\w).+\-_$\]]/;
    transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTERS", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    seen = /* @__PURE__ */ new WeakSet();
    transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen.has(node)) {
          return;
        }
        seen.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              convertToBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++)
            ]);
          }
        };
      }
    };
    BindingTypes = {
      "DATA": "data",
      "PROPS": "props",
      "PROPS_ALIASED": "props-aliased",
      "SETUP_LET": "setup-let",
      "SETUP_CONST": "setup-const",
      "SETUP_REACTIVE_CONST": "setup-reactive-const",
      "SETUP_MAYBE_REF": "setup-maybe-ref",
      "SETUP_REF": "setup-ref",
      "OPTIONS": "options",
      "LITERAL_CONST": "literal-const"
    };
    noopDirectiveTransform = () => ({ props: [] });
  }
});

// node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
var compiler_dom_esm_bundler_exports = {};
__export(compiler_dom_esm_bundler_exports, {
  BASE_TRANSITION: () => BASE_TRANSITION,
  BindingTypes: () => BindingTypes,
  CAMELIZE: () => CAMELIZE,
  CAPITALIZE: () => CAPITALIZE,
  CREATE_BLOCK: () => CREATE_BLOCK,
  CREATE_COMMENT: () => CREATE_COMMENT,
  CREATE_ELEMENT_BLOCK: () => CREATE_ELEMENT_BLOCK,
  CREATE_ELEMENT_VNODE: () => CREATE_ELEMENT_VNODE,
  CREATE_SLOTS: () => CREATE_SLOTS,
  CREATE_STATIC: () => CREATE_STATIC,
  CREATE_TEXT: () => CREATE_TEXT,
  CREATE_VNODE: () => CREATE_VNODE,
  CompilerDeprecationTypes: () => CompilerDeprecationTypes,
  ConstantTypes: () => ConstantTypes,
  DOMDirectiveTransforms: () => DOMDirectiveTransforms,
  DOMErrorCodes: () => DOMErrorCodes,
  DOMErrorMessages: () => DOMErrorMessages,
  DOMNodeTransforms: () => DOMNodeTransforms,
  ElementTypes: () => ElementTypes,
  ErrorCodes: () => ErrorCodes,
  FRAGMENT: () => FRAGMENT,
  GUARD_REACTIVE_PROPS: () => GUARD_REACTIVE_PROPS,
  IS_MEMO_SAME: () => IS_MEMO_SAME,
  IS_REF: () => IS_REF,
  KEEP_ALIVE: () => KEEP_ALIVE,
  MERGE_PROPS: () => MERGE_PROPS,
  NORMALIZE_CLASS: () => NORMALIZE_CLASS,
  NORMALIZE_PROPS: () => NORMALIZE_PROPS,
  NORMALIZE_STYLE: () => NORMALIZE_STYLE,
  Namespaces: () => Namespaces,
  NodeTypes: () => NodeTypes,
  OPEN_BLOCK: () => OPEN_BLOCK,
  POP_SCOPE_ID: () => POP_SCOPE_ID,
  PUSH_SCOPE_ID: () => PUSH_SCOPE_ID,
  RENDER_LIST: () => RENDER_LIST,
  RENDER_SLOT: () => RENDER_SLOT,
  RESOLVE_COMPONENT: () => RESOLVE_COMPONENT,
  RESOLVE_DIRECTIVE: () => RESOLVE_DIRECTIVE,
  RESOLVE_DYNAMIC_COMPONENT: () => RESOLVE_DYNAMIC_COMPONENT,
  RESOLVE_FILTER: () => RESOLVE_FILTER,
  SET_BLOCK_TRACKING: () => SET_BLOCK_TRACKING,
  SUSPENSE: () => SUSPENSE,
  TELEPORT: () => TELEPORT,
  TO_DISPLAY_STRING: () => TO_DISPLAY_STRING,
  TO_HANDLERS: () => TO_HANDLERS,
  TO_HANDLER_KEY: () => TO_HANDLER_KEY,
  TRANSITION: () => TRANSITION,
  TRANSITION_GROUP: () => TRANSITION_GROUP,
  TS_NODE_TYPES: () => TS_NODE_TYPES,
  UNREF: () => UNREF,
  V_MODEL_CHECKBOX: () => V_MODEL_CHECKBOX,
  V_MODEL_DYNAMIC: () => V_MODEL_DYNAMIC,
  V_MODEL_RADIO: () => V_MODEL_RADIO,
  V_MODEL_SELECT: () => V_MODEL_SELECT,
  V_MODEL_TEXT: () => V_MODEL_TEXT,
  V_ON_WITH_KEYS: () => V_ON_WITH_KEYS,
  V_ON_WITH_MODIFIERS: () => V_ON_WITH_MODIFIERS,
  V_SHOW: () => V_SHOW,
  WITH_CTX: () => WITH_CTX,
  WITH_DIRECTIVES: () => WITH_DIRECTIVES,
  WITH_MEMO: () => WITH_MEMO,
  advancePositionWithClone: () => advancePositionWithClone,
  advancePositionWithMutation: () => advancePositionWithMutation,
  assert: () => assert,
  baseCompile: () => baseCompile,
  baseParse: () => baseParse,
  buildDirectiveArgs: () => buildDirectiveArgs,
  buildProps: () => buildProps,
  buildSlots: () => buildSlots,
  checkCompatEnabled: () => checkCompatEnabled,
  compile: () => compile,
  convertToBlock: () => convertToBlock,
  createArrayExpression: () => createArrayExpression,
  createAssignmentExpression: () => createAssignmentExpression,
  createBlockStatement: () => createBlockStatement,
  createCacheExpression: () => createCacheExpression,
  createCallExpression: () => createCallExpression,
  createCompilerError: () => createCompilerError,
  createCompoundExpression: () => createCompoundExpression,
  createConditionalExpression: () => createConditionalExpression,
  createDOMCompilerError: () => createDOMCompilerError,
  createForLoopParams: () => createForLoopParams,
  createFunctionExpression: () => createFunctionExpression,
  createIfStatement: () => createIfStatement,
  createInterpolation: () => createInterpolation,
  createObjectExpression: () => createObjectExpression,
  createObjectProperty: () => createObjectProperty,
  createReturnStatement: () => createReturnStatement,
  createRoot: () => createRoot,
  createSequenceExpression: () => createSequenceExpression,
  createSimpleExpression: () => createSimpleExpression,
  createStructuralDirectiveTransform: () => createStructuralDirectiveTransform,
  createTemplateLiteral: () => createTemplateLiteral,
  createTransformContext: () => createTransformContext,
  createVNodeCall: () => createVNodeCall,
  errorMessages: () => errorMessages,
  extractIdentifiers: () => extractIdentifiers,
  findDir: () => findDir,
  findProp: () => findProp,
  forAliasRE: () => forAliasRE,
  generate: () => generate,
  generateCodeFrame: () => generateCodeFrame,
  getBaseTransformPreset: () => getBaseTransformPreset,
  getConstantType: () => getConstantType,
  getMemoedVNodeCall: () => getMemoedVNodeCall,
  getVNodeBlockHelper: () => getVNodeBlockHelper,
  getVNodeHelper: () => getVNodeHelper,
  hasDynamicKeyVBind: () => hasDynamicKeyVBind,
  hasScopeRef: () => hasScopeRef,
  helperNameMap: () => helperNameMap,
  injectProp: () => injectProp,
  isCoreComponent: () => isCoreComponent,
  isFunctionType: () => isFunctionType,
  isInDestructureAssignment: () => isInDestructureAssignment,
  isInNewExpression: () => isInNewExpression,
  isMemberExpression: () => isMemberExpression,
  isMemberExpressionBrowser: () => isMemberExpressionBrowser,
  isMemberExpressionNode: () => isMemberExpressionNode,
  isReferencedIdentifier: () => isReferencedIdentifier,
  isSimpleIdentifier: () => isSimpleIdentifier,
  isSlotOutlet: () => isSlotOutlet,
  isStaticArgOf: () => isStaticArgOf,
  isStaticExp: () => isStaticExp,
  isStaticProperty: () => isStaticProperty,
  isStaticPropertyKey: () => isStaticPropertyKey,
  isTemplateNode: () => isTemplateNode,
  isText: () => isText$1,
  isVSlot: () => isVSlot,
  locStub: () => locStub,
  noopDirectiveTransform: () => noopDirectiveTransform,
  parse: () => parse,
  parserOptions: () => parserOptions,
  processExpression: () => processExpression,
  processFor: () => processFor,
  processIf: () => processIf,
  processSlotOutlet: () => processSlotOutlet,
  registerRuntimeHelpers: () => registerRuntimeHelpers,
  resolveComponentType: () => resolveComponentType,
  stringifyExpression: () => stringifyExpression,
  toValidAssetId: () => toValidAssetId,
  trackSlotScopes: () => trackSlotScopes,
  trackVForSlotScopes: () => trackVForSlotScopes,
  transform: () => transform,
  transformBind: () => transformBind,
  transformElement: () => transformElement,
  transformExpression: () => transformExpression,
  transformModel: () => transformModel,
  transformOn: () => transformOn,
  transformStyle: () => transformStyle,
  traverseNode: () => traverseNode,
  unwrapTSNode: () => unwrapTSNode,
  walkBlockDeclarations: () => walkBlockDeclarations,
  walkFunctionParams: () => walkFunctionParams,
  walkIdentifiers: () => walkIdentifiers,
  warnDeprecation: () => warnDeprecation
});
function decodeHtmlBrowser(raw, asAttr = false) {
  if (!decoder) {
    decoder = document.createElement("div");
  }
  if (asAttr) {
    decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
    return decoder.children[0].getAttribute("foo");
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}
function createDOMCompilerError(code, loc) {
  return createCompilerError(
    code,
    loc,
    true ? DOMErrorMessages : void 0
  );
}
function hasMultipleChildren(node) {
  const children = node.children = node.children.filter(
    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())
  );
  const child = children[0];
  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
}
function compile(src, options = {}) {
  return baseCompile(
    src,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function parse(template, options = {}) {
  return baseParse(template, extend({}, parserOptions, options));
}
var V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION, TRANSITION_GROUP, decoder, parserOptions, transformStyle, parseInlineCSS, DOMErrorCodes, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, transformTransition, ignoreSideEffectTags, DOMNodeTransforms, DOMDirectiveTransforms;
var init_compiler_dom_esm_bundler = __esm({
  "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
    init_compiler_core_esm_bundler();
    init_compiler_core_esm_bundler();
    init_shared_esm_bundler();
    V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
    V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : ``);
    V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
    V_MODEL_SELECT = Symbol(true ? `vModelSelect` : ``);
    V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : ``);
    V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : ``);
    V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : ``);
    V_SHOW = Symbol(true ? `vShow` : ``);
    TRANSITION = Symbol(true ? `Transition` : ``);
    TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : ``);
    registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    parserOptions = {
      parseMode: "html",
      isVoidTag,
      isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtmlBrowser,
      isBuiltInComponent: (tag) => {
        if (tag === "Transition" || tag === "transition") {
          return TRANSITION;
        } else if (tag === "TransitionGroup" || tag === "transition-group") {
          return TRANSITION_GROUP;
        }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent, rootNamespace) {
        let ns = parent ? parent.ns : rootNamespace;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some(
              (a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml")
            )) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      }
    };
    transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(
        JSON.stringify(normalized),
        false,
        loc,
        3
      );
    };
    DOMErrorCodes = {
      "X_V_HTML_NO_EXPRESSION": 53,
      "53": "X_V_HTML_NO_EXPRESSION",
      "X_V_HTML_WITH_CHILDREN": 54,
      "54": "X_V_HTML_WITH_CHILDREN",
      "X_V_TEXT_NO_EXPRESSION": 55,
      "55": "X_V_TEXT_NO_EXPRESSION",
      "X_V_TEXT_WITH_CHILDREN": 56,
      "56": "X_V_TEXT_WITH_CHILDREN",
      "X_V_MODEL_ON_INVALID_ELEMENT": 57,
      "57": "X_V_MODEL_ON_INVALID_ELEMENT",
      "X_V_MODEL_ARG_ON_ELEMENT": 58,
      "58": "X_V_MODEL_ARG_ON_ELEMENT",
      "X_V_MODEL_ON_FILE_INPUT_ELEMENT": 59,
      "59": "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
      "X_V_MODEL_UNNECESSARY_VALUE": 60,
      "60": "X_V_MODEL_UNNECESSARY_VALUE",
      "X_V_SHOW_NO_EXPRESSION": 61,
      "61": "X_V_SHOW_NO_EXPRESSION",
      "X_TRANSITION_INVALID_CHILDREN": 62,
      "62": "X_TRANSITION_INVALID_CHILDREN",
      "X_IGNORED_SIDE_EFFECT_TAG": 63,
      "63": "X_IGNORED_SIDE_EFFECT_TAG",
      "__EXTEND_POINT__": 64,
      "64": "__EXTEND_POINT__"
    };
    DOMErrorMessages = {
      [53]: `v-html is missing expression.`,
      [54]: `v-html will override element children.`,
      [55]: `v-text is missing expression.`,
      [56]: `v-text will override element children.`,
      [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [58]: `v-model argument is not supported on plain elements.`,
      [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [61]: `v-show is missing expression.`,
      [62]: `<Transition> expects exactly one child element or component.`,
      [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(53, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(54, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`innerHTML`, true, loc),
            exp || createSimpleExpression("", true)
          )
        ]
      };
    };
    transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(55, loc)
        );
      }
      if (node.children.length) {
        context.onError(
          createDOMCompilerError(56, loc)
        );
        node.children.length = 0;
      }
      return {
        props: [
          createObjectProperty(
            createSimpleExpression(`textContent`, true),
            exp ? getConstantType(exp, context) > 0 ? exp : createCallExpression(
              context.helperString(TO_DISPLAY_STRING),
              [exp],
              loc
            ) : createSimpleExpression("", true)
          )
        ]
      };
    };
    transformModel2 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(
          createDOMCompilerError(
            58,
            dir.arg.loc
          )
        );
      }
      function checkDuplicatedValue() {
        const value = findDir(node, "bind");
        if (value && isStaticArgOf(value.arg, "value")) {
          context.onError(
            createDOMCompilerError(
              60,
              value.loc
            )
          );
        }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(
                    createDOMCompilerError(
                      59,
                      dir.loc
                    )
                  );
                  break;
                default:
                  checkDuplicatedValue();
                  break;
              }
            }
          } else if (hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else {
            checkDuplicatedValue();
          }
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else {
          checkDuplicatedValue();
        }
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(
          createDOMCompilerError(
            57,
            dir.loc
          )
        );
      }
      baseResult.props = baseResult.props.filter(
        (p) => !(p.key.type === 4 && p.key.content === "modelValue")
      );
      return baseResult;
    };
    isEventOptionModifier = makeMap(`passive,once,capture`);
    isNonKeyModifier = makeMap(
      // event propagation management
      `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`
    );
    maybeKeyModifier = makeMap("left,right");
    isKeyboardEvent = makeMap(
      `onkeyup,onkeydown,onkeypress`,
      true
    );
    resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && checkCompatEnabled(
          "COMPILER_V_ON_NATIVE",
          context,
          loc
        )) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4 ? createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    transformOn2 = (dir, node, context) => {
      return transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard
        (!isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
          key = isStaticExp(key) ? createSimpleExpression(`${key.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [createObjectProperty(key, handlerExp)]
        };
      });
    };
    transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(
          createDOMCompilerError(61, loc)
        );
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    transformTransition = (node, context) => {
      if (node.type === 1 && node.tagType === 1) {
        const component = context.isBuiltInComponent(node.tag);
        if (component === TRANSITION) {
          return () => {
            if (!node.children.length) {
              return;
            }
            if (hasMultipleChildren(node)) {
              context.onError(
                createDOMCompilerError(
                  62,
                  {
                    start: node.children[0].loc.start,
                    end: node.children[node.children.length - 1].loc.end,
                    source: ""
                  }
                )
              );
            }
            const child = node.children[0];
            if (child.type === 1) {
              for (const p of child.props) {
                if (p.type === 7 && p.name === "show") {
                  node.props.push({
                    type: 6,
                    name: "persisted",
                    nameLoc: node.loc,
                    value: void 0,
                    loc: node.loc
                  });
                }
              }
            }
          };
        }
      }
    };
    ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(
          createDOMCompilerError(
            63,
            node.loc
          )
        );
        context.removeNode();
      }
    };
    DOMNodeTransforms = [
      transformStyle,
      ...true ? [transformTransition] : []
    ];
    DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel2,
      // override compiler-core
      on: transformOn2,
      // override compiler-core
      show: transformShow
    };
  }
});

// node_modules/vue/dist/vue.cjs.js
var require_vue_cjs = __commonJS({
  "node_modules/vue/dist/vue.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var compilerDom = (init_compiler_dom_esm_bundler(), __toCommonJS(compiler_dom_esm_bundler_exports));
    var runtimeDom = (init_runtime_dom_esm_bundler(), __toCommonJS(runtime_dom_esm_bundler_exports));
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        for (var k in e) {
          n[k] = e[k];
        }
      }
      n.default = e;
      return Object.freeze(n);
    }
    var runtimeDom__namespace = _interopNamespaceDefault(runtimeDom);
    var compileCache = /* @__PURE__ */ new WeakMap();
    function getCache(options) {
      let c = compileCache.get(options != null ? options : shared.EMPTY_OBJ);
      if (!c) {
        c = /* @__PURE__ */ Object.create(null);
        compileCache.set(options != null ? options : shared.EMPTY_OBJ, c);
      }
      return c;
    }
    function compileToFunction(template, options) {
      if (!shared.isString(template)) {
        if (template.nodeType) {
          template = template.innerHTML;
        } else {
          runtimeDom.warn(`invalid template option: `, template);
          return shared.NOOP;
        }
      }
      const key = template;
      const cache = getCache(options);
      const cached = cache[key];
      if (cached) {
        return cached;
      }
      if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
          runtimeDom.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
      }
      const opts = shared.extend(
        {
          hoistStatic: true,
          onError,
          onWarn: (e) => onError(e, true)
        },
        options
      );
      if (!opts.isCustomElement && typeof customElements !== "undefined") {
        opts.isCustomElement = (tag) => !!customElements.get(tag);
      }
      const { code } = compilerDom.compile(template, opts);
      function onError(err, asWarning = false) {
        const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
        const codeFrame = err.loc && shared.generateCodeFrame(
          template,
          err.loc.start.offset,
          err.loc.end.offset
        );
        runtimeDom.warn(codeFrame ? `${message}
${codeFrame}` : message);
      }
      const render = new Function("Vue", code)(runtimeDom__namespace);
      render._rc = true;
      return cache[key] = render;
    }
    runtimeDom.registerRuntimeCompiler(compileToFunction);
    exports.compile = compileToFunction;
    Object.keys(runtimeDom).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k))
        exports[k] = runtimeDom[k];
    });
  }
});

// node_modules/vue/index.js
var require_vue = __commonJS({
  "node_modules/vue/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_vue_cjs();
    }
  }
});

// node_modules/dropzone-vue/dist/dropzone-vue.common.js
var require_dropzone_vue_common = __commonJS({
  "node_modules/dropzone-vue/dist/dropzone-vue.common.js"(exports, module) {
    var e = require_vue();
    var t = function(e2) {
      try {
        return !!e2();
      } catch (e3) {
        return true;
      }
    };
    var i = !t(function() {
      return 7 != Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1];
    });
    var n = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function a(e2) {
      var t2 = { exports: {} };
      return e2(t2, t2.exports), t2.exports;
    }
    var p = function(e2) {
      return e2 && e2.Math == Math && e2;
    };
    var r = p("object" == typeof globalThis && globalThis) || p("object" == typeof window && window) || p("object" == typeof self && self) || p("object" == typeof n && n) || /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")();
    var o = function(e2) {
      return "object" == typeof e2 ? null !== e2 : "function" == typeof e2;
    };
    var m = r.document;
    var c = o(m) && o(m.createElement);
    var l = function(e2) {
      return c ? m.createElement(e2) : {};
    };
    var s = !i && !t(function() {
      return 7 != Object.defineProperty(l("div"), "a", { get: function() {
        return 7;
      } }).a;
    });
    var d = function(e2) {
      if (!o(e2))
        throw TypeError(String(e2) + " is not an object");
      return e2;
    };
    var u = function(e2, t2) {
      if (!o(e2))
        return e2;
      var i2, n2;
      if (t2 && "function" == typeof (i2 = e2.toString) && !o(n2 = i2.call(e2)))
        return n2;
      if ("function" == typeof (i2 = e2.valueOf) && !o(n2 = i2.call(e2)))
        return n2;
      if (!t2 && "function" == typeof (i2 = e2.toString) && !o(n2 = i2.call(e2)))
        return n2;
      throw TypeError("Can't convert object to primitive value");
    };
    var f = Object.defineProperty;
    var y = { f: i ? f : function(e2, t2, i2) {
      if (d(e2), t2 = u(t2, true), d(i2), s)
        try {
          return f(e2, t2, i2);
        } catch (e3) {
        }
      if ("get" in i2 || "set" in i2)
        throw TypeError("Accessors not supported");
      return "value" in i2 && (e2[t2] = i2.value), e2;
    } };
    var v = y.f;
    var x = Function.prototype;
    var _ = x.toString;
    var h = /^\s*function ([^ (]*)/;
    function g(e2, t2, i2) {
      return t2 in e2 ? Object.defineProperty(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
    }
    function b(e2, t2) {
      var i2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i2.push.apply(i2, n2);
      }
      return i2;
    }
    function w(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i2 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? b(Object(i2), true).forEach(function(t3) {
          g(e2, t3, i2[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : b(Object(i2)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
        });
      }
      return e2;
    }
    function k(e2, t2) {
      (null == t2 || t2 > e2.length) && (t2 = e2.length);
      for (var i2 = 0, n2 = new Array(t2); i2 < t2; i2++)
        n2[i2] = e2[i2];
      return n2;
    }
    function A(e2) {
      return function(e3) {
        if (Array.isArray(e3))
          return k(e3);
      }(e2) || function(e3) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
          return Array.from(e3);
      }(e2) || function(e3, t2) {
        if (e3) {
          if ("string" == typeof e3)
            return k(e3, t2);
          var i2 = Object.prototype.toString.call(e3).slice(8, -1);
          return "Object" === i2 && e3.constructor && (i2 = e3.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(e3) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? k(e3, t2) : void 0;
        }
      }(e2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    i && !("name" in x) && v(x, "name", { configurable: true, get: function() {
      try {
        return _.call(this).match(h)[1];
      } catch (e2) {
        return "";
      }
    } });
    var E = {}.propertyIsEnumerable;
    var S = Object.getOwnPropertyDescriptor;
    var j = { f: S && !E.call({ 1: 2 }, 1) ? function(e2) {
      var t2 = S(this, e2);
      return !!t2 && t2.enumerable;
    } : E };
    var O = function(e2, t2) {
      return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
    };
    var T = {}.toString;
    var I = function(e2) {
      return T.call(e2).slice(8, -1);
    };
    var R = "".split;
    var L = t(function() {
      return !Object("z").propertyIsEnumerable(0);
    }) ? function(e2) {
      return "String" == I(e2) ? R.call(e2, "") : Object(e2);
    } : Object;
    var U = function(e2) {
      if (null == e2)
        throw TypeError("Can't call method on " + e2);
      return e2;
    };
    var z = function(e2) {
      return L(U(e2));
    };
    var N = {}.hasOwnProperty;
    var F = function(e2, t2) {
      return N.call(e2, t2);
    };
    var P = Object.getOwnPropertyDescriptor;
    var C = { f: i ? P : function(e2, t2) {
      if (e2 = z(e2), t2 = u(t2, true), s)
        try {
          return P(e2, t2);
        } catch (e3) {
        }
      if (F(e2, t2))
        return O(!j.f.call(e2, t2), e2[t2]);
    } };
    var M = i ? function(e2, t2, i2) {
      return y.f(e2, t2, O(1, i2));
    } : function(e2, t2, i2) {
      return e2[t2] = i2, e2;
    };
    var q = function(e2, t2) {
      try {
        M(r, e2, t2);
      } catch (i2) {
        r[e2] = t2;
      }
      return t2;
    };
    var D = r["__core-js_shared__"] || q("__core-js_shared__", {});
    var B = Function.toString;
    "function" != typeof D.inspectSource && (D.inspectSource = function(e2) {
      return B.call(e2);
    });
    var V;
    var G;
    var $;
    var W = D.inspectSource;
    var Y = r.WeakMap;
    var H = "function" == typeof Y && /native code/.test(W(Y));
    var Q = a(function(e2) {
      (e2.exports = function(e3, t2) {
        return D[e3] || (D[e3] = void 0 !== t2 ? t2 : {});
      })("versions", []).push({ version: "3.9.1", mode: "global", copyright: "© 2021 Denis Pushkarev (zloirock.ru)" });
    });
    var X = 0;
    var K = Math.random();
    var Z = function(e2) {
      return "Symbol(" + String(void 0 === e2 ? "" : e2) + ")_" + (++X + K).toString(36);
    };
    var J = Q("keys");
    var ee = function(e2) {
      return J[e2] || (J[e2] = Z(e2));
    };
    var te = {};
    var ie = r.WeakMap;
    if (H) {
      ne = D.state || (D.state = new ie()), ae = ne.get, pe = ne.has, re = ne.set;
      V = function(e2, t2) {
        return t2.facade = e2, re.call(ne, e2, t2), t2;
      }, G = function(e2) {
        return ae.call(ne, e2) || {};
      }, $ = function(e2) {
        return pe.call(ne, e2);
      };
    } else {
      oe = ee("state");
      te[oe] = true, V = function(e2, t2) {
        return t2.facade = e2, M(e2, oe, t2), t2;
      }, G = function(e2) {
        return F(e2, oe) ? e2[oe] : {};
      }, $ = function(e2) {
        return F(e2, oe);
      };
    }
    var ne;
    var ae;
    var pe;
    var re;
    var oe;
    var me = { set: V, get: G, has: $, enforce: function(e2) {
      return $(e2) ? G(e2) : V(e2, {});
    }, getterFor: function(e2) {
      return function(t2) {
        var i2;
        if (!o(t2) || (i2 = G(t2)).type !== e2)
          throw TypeError("Incompatible receiver, " + e2 + " required");
        return i2;
      };
    } };
    var ce = a(function(e2) {
      var t2 = me.get, i2 = me.enforce, n2 = String(String).split("String");
      (e2.exports = function(e3, t3, a2, p2) {
        var o2, m2 = !!p2 && !!p2.unsafe, c2 = !!p2 && !!p2.enumerable, l2 = !!p2 && !!p2.noTargetGet;
        "function" == typeof a2 && ("string" != typeof t3 || F(a2, "name") || M(a2, "name", t3), (o2 = i2(a2)).source || (o2.source = n2.join("string" == typeof t3 ? t3 : ""))), e3 !== r ? (m2 ? !l2 && e3[t3] && (c2 = true) : delete e3[t3], c2 ? e3[t3] = a2 : M(e3, t3, a2)) : c2 ? e3[t3] = a2 : q(t3, a2);
      })(Function.prototype, "toString", function() {
        return "function" == typeof this && t2(this).source || W(this);
      });
    });
    var le = r;
    var se = function(e2) {
      return "function" == typeof e2 ? e2 : void 0;
    };
    var de = function(e2, t2) {
      return arguments.length < 2 ? se(le[e2]) || se(r[e2]) : le[e2] && le[e2][t2] || r[e2] && r[e2][t2];
    };
    var ue = Math.ceil;
    var fe = Math.floor;
    var ye = function(e2) {
      return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? fe : ue)(e2);
    };
    var ve = Math.min;
    var xe = function(e2) {
      return e2 > 0 ? ve(ye(e2), 9007199254740991) : 0;
    };
    var _e = Math.max;
    var he = Math.min;
    var ge = function(e2, t2) {
      var i2 = ye(e2);
      return i2 < 0 ? _e(i2 + t2, 0) : he(i2, t2);
    };
    var be = function(e2) {
      return function(t2, i2, n2) {
        var a2, p2 = z(t2), r2 = xe(p2.length), o2 = ge(n2, r2);
        if (e2 && i2 != i2) {
          for (; r2 > o2; )
            if ((a2 = p2[o2++]) != a2)
              return true;
        } else
          for (; r2 > o2; o2++)
            if ((e2 || o2 in p2) && p2[o2] === i2)
              return e2 || o2 || 0;
        return !e2 && -1;
      };
    };
    var we = { includes: be(true), indexOf: be(false) };
    var ke = we.indexOf;
    var Ae = function(e2, t2) {
      var i2, n2 = z(e2), a2 = 0, p2 = [];
      for (i2 in n2)
        !F(te, i2) && F(n2, i2) && p2.push(i2);
      for (; t2.length > a2; )
        F(n2, i2 = t2[a2++]) && (~ke(p2, i2) || p2.push(i2));
      return p2;
    };
    var Ee = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    var Se = Ee.concat("length", "prototype");
    var je = { f: Object.getOwnPropertyNames || function(e2) {
      return Ae(e2, Se);
    } };
    var Oe = { f: Object.getOwnPropertySymbols };
    var Te = de("Reflect", "ownKeys") || function(e2) {
      var t2 = je.f(d(e2)), i2 = Oe.f;
      return i2 ? t2.concat(i2(e2)) : t2;
    };
    var Ie = function(e2, t2) {
      for (var i2 = Te(t2), n2 = y.f, a2 = C.f, p2 = 0; p2 < i2.length; p2++) {
        var r2 = i2[p2];
        F(e2, r2) || n2(e2, r2, a2(t2, r2));
      }
    };
    var Re = /#|\.prototype\./;
    var Le = function(e2, i2) {
      var n2 = ze[Ue(e2)];
      return n2 == Fe || n2 != Ne && ("function" == typeof i2 ? t(i2) : !!i2);
    };
    var Ue = Le.normalize = function(e2) {
      return String(e2).replace(Re, ".").toLowerCase();
    };
    var ze = Le.data = {};
    var Ne = Le.NATIVE = "N";
    var Fe = Le.POLYFILL = "P";
    var Pe = Le;
    var Ce = C.f;
    var Me = function(e2, t2) {
      var i2, n2, a2, p2, o2, m2 = e2.target, c2 = e2.global, l2 = e2.stat;
      if (i2 = c2 ? r : l2 ? r[m2] || q(m2, {}) : (r[m2] || {}).prototype)
        for (n2 in t2) {
          if (p2 = t2[n2], a2 = e2.noTargetGet ? (o2 = Ce(i2, n2)) && o2.value : i2[n2], !Pe(c2 ? n2 : m2 + (l2 ? "." : "#") + n2, e2.forced) && void 0 !== a2) {
            if (typeof p2 == typeof a2)
              continue;
            Ie(p2, a2);
          }
          (e2.sham || a2 && a2.sham) && M(p2, "sham", true), ce(i2, n2, p2, e2);
        }
    };
    var qe = function() {
      var e2 = d(this), t2 = "";
      return e2.global && (t2 += "g"), e2.ignoreCase && (t2 += "i"), e2.multiline && (t2 += "m"), e2.dotAll && (t2 += "s"), e2.unicode && (t2 += "u"), e2.sticky && (t2 += "y"), t2;
    };
    function De(e2, t2) {
      return RegExp(e2, t2);
    }
    var Be;
    var Ve;
    var Ge = { UNSUPPORTED_Y: t(function() {
      var e2 = De("a", "y");
      return e2.lastIndex = 2, null != e2.exec("abcd");
    }), BROKEN_CARET: t(function() {
      var e2 = De("^r", "gy");
      return e2.lastIndex = 2, null != e2.exec("str");
    }) };
    var $e = RegExp.prototype.exec;
    var We = String.prototype.replace;
    var Ye = $e;
    var He = (Be = /a/, Ve = /b*/g, $e.call(Be, "a"), $e.call(Ve, "a"), 0 !== Be.lastIndex || 0 !== Ve.lastIndex);
    var Qe = Ge.UNSUPPORTED_Y || Ge.BROKEN_CARET;
    var Xe = void 0 !== /()??/.exec("")[1];
    (He || Xe || Qe) && (Ye = function(e2) {
      var t2, i2, n2, a2, p2 = this, r2 = Qe && p2.sticky, o2 = qe.call(p2), m2 = p2.source, c2 = 0, l2 = e2;
      return r2 && (-1 === (o2 = o2.replace("y", "")).indexOf("g") && (o2 += "g"), l2 = String(e2).slice(p2.lastIndex), p2.lastIndex > 0 && (!p2.multiline || p2.multiline && "\n" !== e2[p2.lastIndex - 1]) && (m2 = "(?: " + m2 + ")", l2 = " " + l2, c2++), i2 = new RegExp("^(?:" + m2 + ")", o2)), Xe && (i2 = new RegExp("^" + m2 + "$(?!\\s)", o2)), He && (t2 = p2.lastIndex), n2 = $e.call(r2 ? i2 : p2, l2), r2 ? n2 ? (n2.input = n2.input.slice(c2), n2[0] = n2[0].slice(c2), n2.index = p2.lastIndex, p2.lastIndex += n2[0].length) : p2.lastIndex = 0 : He && n2 && (p2.lastIndex = p2.global ? n2.index + n2[0].length : t2), Xe && n2 && n2.length > 1 && We.call(n2[0], i2, function() {
        for (a2 = 1; a2 < arguments.length - 2; a2++)
          void 0 === arguments[a2] && (n2[a2] = void 0);
      }), n2;
    });
    var Ke = Ye;
    Me({ target: "RegExp", proto: true, forced: /./.exec !== Ke }, { exec: Ke });
    var Ze;
    var Je;
    var et = "process" == I(r.process);
    var tt = de("navigator", "userAgent") || "";
    var it = r.process;
    var nt = it && it.versions;
    var at = nt && nt.v8;
    at ? Je = (Ze = at.split("."))[0] + Ze[1] : tt && (!(Ze = tt.match(/Edge\/(\d+)/)) || Ze[1] >= 74) && (Ze = tt.match(/Chrome\/(\d+)/)) && (Je = Ze[1]);
    var pt = Je && +Je;
    var rt = !!Object.getOwnPropertySymbols && !t(function() {
      return !Symbol.sham && (et ? 38 === pt : pt > 37 && pt < 41);
    });
    var ot = rt && !Symbol.sham && "symbol" == typeof Symbol.iterator;
    var mt = Q("wks");
    var ct = r.Symbol;
    var lt = ot ? ct : ct && ct.withoutSetter || Z;
    var st = function(e2) {
      return F(mt, e2) && (rt || "string" == typeof mt[e2]) || (rt && F(ct, e2) ? mt[e2] = ct[e2] : mt[e2] = lt("Symbol." + e2)), mt[e2];
    };
    var dt = st("species");
    var ut = !t(function() {
      var e2 = /./;
      return e2.exec = function() {
        var e3 = [];
        return e3.groups = { a: "7" }, e3;
      }, "7" !== "".replace(e2, "$<a>");
    });
    var ft = "$0" === "a".replace(/./, "$0");
    var yt = st("replace");
    var vt = !!/./[yt] && "" === /./[yt]("a", "$0");
    var xt = !t(function() {
      var e2 = /(?:)/, t2 = e2.exec;
      e2.exec = function() {
        return t2.apply(this, arguments);
      };
      var i2 = "ab".split(e2);
      return 2 !== i2.length || "a" !== i2[0] || "b" !== i2[1];
    });
    var _t = function(e2, i2, n2, a2) {
      var p2 = st(e2), r2 = !t(function() {
        var t2 = {};
        return t2[p2] = function() {
          return 7;
        }, 7 != ""[e2](t2);
      }), o2 = r2 && !t(function() {
        var t2 = false, i3 = /a/;
        return "split" === e2 && ((i3 = {}).constructor = {}, i3.constructor[dt] = function() {
          return i3;
        }, i3.flags = "", i3[p2] = /./[p2]), i3.exec = function() {
          return t2 = true, null;
        }, i3[p2](""), !t2;
      });
      if (!r2 || !o2 || "replace" === e2 && (!ut || !ft || vt) || "split" === e2 && !xt) {
        var m2 = /./[p2], c2 = n2(p2, ""[e2], function(e3, t2, i3, n3, a3) {
          return t2.exec === Ke ? r2 && !a3 ? { done: true, value: m2.call(t2, i3, n3) } : { done: true, value: e3.call(i3, t2, n3) } : { done: false };
        }, { REPLACE_KEEPS_$0: ft, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: vt }), l2 = c2[0], s2 = c2[1];
        ce(String.prototype, e2, l2), ce(RegExp.prototype, p2, 2 == i2 ? function(e3, t2) {
          return s2.call(e3, this, t2);
        } : function(e3) {
          return s2.call(e3, this);
        });
      }
      a2 && M(RegExp.prototype[p2], "sham", true);
    };
    var ht = function(e2) {
      return function(t2, i2) {
        var n2, a2, p2 = String(U(t2)), r2 = ye(i2), o2 = p2.length;
        return r2 < 0 || r2 >= o2 ? e2 ? "" : void 0 : (n2 = p2.charCodeAt(r2)) < 55296 || n2 > 56319 || r2 + 1 === o2 || (a2 = p2.charCodeAt(r2 + 1)) < 56320 || a2 > 57343 ? e2 ? p2.charAt(r2) : n2 : e2 ? p2.slice(r2, r2 + 2) : a2 - 56320 + (n2 - 55296 << 10) + 65536;
      };
    };
    var gt = { codeAt: ht(false), charAt: ht(true) };
    var bt = gt.charAt;
    var wt = function(e2, t2, i2) {
      return t2 + (i2 ? bt(e2, t2).length : 1);
    };
    var kt = function(e2) {
      return Object(U(e2));
    };
    var At = Math.floor;
    var Et = "".replace;
    var St = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var jt = /\$([$&'`]|\d{1,2})/g;
    var Ot = function(e2, t2, i2, n2, a2, p2) {
      var r2 = i2 + e2.length, o2 = n2.length, m2 = jt;
      return void 0 !== a2 && (a2 = kt(a2), m2 = St), Et.call(p2, m2, function(p3, m3) {
        var c2;
        switch (m3.charAt(0)) {
          case "$":
            return "$";
          case "&":
            return e2;
          case "`":
            return t2.slice(0, i2);
          case "'":
            return t2.slice(r2);
          case "<":
            c2 = a2[m3.slice(1, -1)];
            break;
          default:
            var l2 = +m3;
            if (0 === l2)
              return p3;
            if (l2 > o2) {
              var s2 = At(l2 / 10);
              return 0 === s2 ? p3 : s2 <= o2 ? void 0 === n2[s2 - 1] ? m3.charAt(1) : n2[s2 - 1] + m3.charAt(1) : p3;
            }
            c2 = n2[l2 - 1];
        }
        return void 0 === c2 ? "" : c2;
      });
    };
    var Tt = function(e2, t2) {
      var i2 = e2.exec;
      if ("function" == typeof i2) {
        var n2 = i2.call(e2, t2);
        if ("object" != typeof n2)
          throw TypeError("RegExp exec method returned something other than an Object or null");
        return n2;
      }
      if ("RegExp" !== I(e2))
        throw TypeError("RegExp#exec called on incompatible receiver");
      return Ke.call(e2, t2);
    };
    var It = Math.max;
    var Rt = Math.min;
    _t("replace", 2, function(e2, t2, i2, n2) {
      var a2 = n2.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, p2 = n2.REPLACE_KEEPS_$0, r2 = a2 ? "$" : "$0";
      return [function(i3, n3) {
        var a3 = U(this), p3 = null == i3 ? void 0 : i3[e2];
        return void 0 !== p3 ? p3.call(i3, a3, n3) : t2.call(String(a3), i3, n3);
      }, function(e3, n3) {
        if (!a2 && p2 || "string" == typeof n3 && -1 === n3.indexOf(r2)) {
          var o2 = i2(t2, e3, this, n3);
          if (o2.done)
            return o2.value;
        }
        var m2 = d(e3), c2 = String(this), l2 = "function" == typeof n3;
        l2 || (n3 = String(n3));
        var s2 = m2.global;
        if (s2) {
          var u2 = m2.unicode;
          m2.lastIndex = 0;
        }
        for (var f2 = []; ; ) {
          var y2 = Tt(m2, c2);
          if (null === y2)
            break;
          if (f2.push(y2), !s2)
            break;
          "" === String(y2[0]) && (m2.lastIndex = wt(c2, xe(m2.lastIndex), u2));
        }
        for (var v2, x2 = "", _2 = 0, h2 = 0; h2 < f2.length; h2++) {
          y2 = f2[h2];
          for (var g2 = String(y2[0]), b2 = It(Rt(ye(y2.index), c2.length), 0), w2 = [], k2 = 1; k2 < y2.length; k2++)
            w2.push(void 0 === (v2 = y2[k2]) ? v2 : String(v2));
          var A2 = y2.groups;
          if (l2) {
            var E2 = [g2].concat(w2, b2, c2);
            void 0 !== A2 && E2.push(A2);
            var S2 = String(n3.apply(void 0, E2));
          } else
            S2 = Ot(g2, c2, b2, w2, A2, n3);
          b2 >= _2 && (x2 += c2.slice(_2, b2) + S2, _2 = b2 + g2.length);
        }
        return x2 + c2.slice(_2);
      }];
    });
    var Lt = {};
    Lt[st("toStringTag")] = "z";
    var Ut = "[object z]" === String(Lt);
    var zt = st("toStringTag");
    var Nt = "Arguments" == I(/* @__PURE__ */ function() {
      return arguments;
    }());
    var Ft = Ut ? I : function(e2) {
      var t2, i2, n2;
      return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = function(e3, t3) {
        try {
          return e3[t3];
        } catch (e4) {
        }
      }(t2 = Object(e2), zt)) ? i2 : Nt ? I(t2) : "Object" == (n2 = I(t2)) && "function" == typeof t2.callee ? "Arguments" : n2;
    };
    var Pt = Ut ? {}.toString : function() {
      return "[object " + Ft(this) + "]";
    };
    Ut || ce(Object.prototype, "toString", Pt, { unsafe: true });
    var Ct = RegExp.prototype;
    var Mt = Ct.toString;
    var qt = t(function() {
      return "/a/b" != Mt.call({ source: "a", flags: "b" });
    });
    var Dt = "toString" != Mt.name;
    (qt || Dt) && ce(RegExp.prototype, "toString", function() {
      var e2 = d(this), t2 = String(e2.source), i2 = e2.flags;
      return "/" + t2 + "/" + String(void 0 === i2 && e2 instanceof RegExp && !("flags" in Ct) ? qe.call(e2) : i2);
    }, { unsafe: true });
    var Bt = st("iterator");
    var Vt = false;
    try {
      Gt = 0, $t = { next: function() {
        return { done: !!Gt++ };
      }, return: function() {
        Vt = true;
      } };
      $t[Bt] = function() {
        return this;
      }, Array.from($t, function() {
        throw 2;
      });
    } catch (e2) {
    }
    var Gt;
    var $t;
    var Wt;
    var Yt = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView;
    var Ht = !t(function() {
      function e2() {
      }
      return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
    });
    var Qt = ee("IE_PROTO");
    var Xt = Object.prototype;
    var Kt = Ht ? Object.getPrototypeOf : function(e2) {
      return e2 = kt(e2), F(e2, Qt) ? e2[Qt] : "function" == typeof e2.constructor && e2 instanceof e2.constructor ? e2.constructor.prototype : e2 instanceof Object ? Xt : null;
    };
    var Zt = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var e2, t2 = false, i2 = {};
      try {
        (e2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(i2, []), t2 = i2 instanceof Array;
      } catch (e3) {
      }
      return function(i3, n2) {
        return d(i3), function(e3) {
          if (!o(e3) && null !== e3)
            throw TypeError("Can't set " + String(e3) + " as a prototype");
        }(n2), t2 ? e2.call(i3, n2) : i3.__proto__ = n2, i3;
      };
    }() : void 0);
    var Jt = y.f;
    var ei = r.Int8Array;
    var ti = ei && ei.prototype;
    var ii = r.Uint8ClampedArray;
    var ni = ii && ii.prototype;
    var ai = ei && Kt(ei);
    var pi = ti && Kt(ti);
    var ri = Object.prototype;
    var oi = ri.isPrototypeOf;
    var mi = st("toStringTag");
    var ci = Z("TYPED_ARRAY_TAG");
    var li = Yt && !!Zt && "Opera" !== Ft(r.opera);
    var si = false;
    var di = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 };
    var ui = { BigInt64Array: 8, BigUint64Array: 8 };
    var fi = function(e2) {
      if (!o(e2))
        return false;
      var t2 = Ft(e2);
      return F(di, t2) || F(ui, t2);
    };
    for (Wt in di)
      r[Wt] || (li = false);
    if ((!li || "function" != typeof ai || ai === Function.prototype) && (ai = function() {
      throw TypeError("Incorrect invocation");
    }, li))
      for (Wt in di)
        r[Wt] && Zt(r[Wt], ai);
    if ((!li || !pi || pi === ri) && (pi = ai.prototype, li))
      for (Wt in di)
        r[Wt] && Zt(r[Wt].prototype, pi);
    if (li && Kt(ni) !== pi && Zt(ni, pi), i && !F(pi, mi))
      for (Wt in si = true, Jt(pi, mi, { get: function() {
        return o(this) ? this[ci] : void 0;
      } }), di)
        r[Wt] && M(r[Wt], ci, Wt);
    var yi = { NATIVE_ARRAY_BUFFER_VIEWS: li, TYPED_ARRAY_TAG: si && ci, aTypedArray: function(e2) {
      if (fi(e2))
        return e2;
      throw TypeError("Target is not a typed array");
    }, aTypedArrayConstructor: function(e2) {
      if (Zt) {
        if (oi.call(ai, e2))
          return e2;
      } else
        for (var t2 in di)
          if (F(di, Wt)) {
            var i2 = r[t2];
            if (i2 && (e2 === i2 || oi.call(i2, e2)))
              return e2;
          }
      throw TypeError("Target is not a typed array constructor");
    }, exportTypedArrayMethod: function(e2, t2, n2) {
      if (i) {
        if (n2)
          for (var a2 in di) {
            var p2 = r[a2];
            p2 && F(p2.prototype, e2) && delete p2.prototype[e2];
          }
        pi[e2] && !n2 || ce(pi, e2, n2 ? t2 : li && ti[e2] || t2);
      }
    }, exportTypedArrayStaticMethod: function(e2, t2, n2) {
      var a2, p2;
      if (i) {
        if (Zt) {
          if (n2)
            for (a2 in di)
              (p2 = r[a2]) && F(p2, e2) && delete p2[e2];
          if (ai[e2] && !n2)
            return;
          try {
            return ce(ai, e2, n2 ? t2 : li && ei[e2] || t2);
          } catch (e3) {
          }
        }
        for (a2 in di)
          !(p2 = r[a2]) || p2[e2] && !n2 || ce(p2, e2, t2);
      }
    }, isView: function(e2) {
      if (!o(e2))
        return false;
      var t2 = Ft(e2);
      return "DataView" === t2 || F(di, t2) || F(ui, t2);
    }, isTypedArray: fi, TypedArray: ai, TypedArrayPrototype: pi };
    var vi = yi.NATIVE_ARRAY_BUFFER_VIEWS;
    var xi = r.ArrayBuffer;
    var _i = r.Int8Array;
    var hi = !vi || !t(function() {
      _i(1);
    }) || !t(function() {
      new _i(-1);
    }) || !function(e2, t2) {
      if (!t2 && !Vt)
        return false;
      var i2 = false;
      try {
        var n2 = {};
        n2[Bt] = function() {
          return { next: function() {
            return { done: i2 = true };
          } };
        }, e2(n2);
      } catch (e3) {
      }
      return i2;
    }(function(e2) {
      new _i(), new _i(null), new _i(1.5), new _i(e2);
    }, true) || t(function() {
      return 1 !== new _i(new xi(2), 1, void 0).length;
    });
    var gi = function(e2, t2, i2) {
      for (var n2 in t2)
        ce(e2, n2, t2[n2], i2);
      return e2;
    };
    var bi = function(e2, t2, i2) {
      if (!(e2 instanceof t2))
        throw TypeError("Incorrect " + (i2 ? i2 + " " : "") + "invocation");
      return e2;
    };
    var wi = function(e2) {
      if (void 0 === e2)
        return 0;
      var t2 = ye(e2), i2 = xe(t2);
      if (t2 !== i2)
        throw RangeError("Wrong length or index");
      return i2;
    };
    var ki = Math.abs;
    var Ai = Math.pow;
    var Ei = Math.floor;
    var Si = Math.log;
    var ji = Math.LN2;
    var Oi = function(e2, t2, i2) {
      var n2, a2, p2, r2 = new Array(i2), o2 = 8 * i2 - t2 - 1, m2 = (1 << o2) - 1, c2 = m2 >> 1, l2 = 23 === t2 ? Ai(2, -24) - Ai(2, -77) : 0, s2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0, d2 = 0;
      for ((e2 = ki(e2)) != e2 || e2 === 1 / 0 ? (a2 = e2 != e2 ? 1 : 0, n2 = m2) : (n2 = Ei(Si(e2) / ji), e2 * (p2 = Ai(2, -n2)) < 1 && (n2--, p2 *= 2), (e2 += n2 + c2 >= 1 ? l2 / p2 : l2 * Ai(2, 1 - c2)) * p2 >= 2 && (n2++, p2 /= 2), n2 + c2 >= m2 ? (a2 = 0, n2 = m2) : n2 + c2 >= 1 ? (a2 = (e2 * p2 - 1) * Ai(2, t2), n2 += c2) : (a2 = e2 * Ai(2, c2 - 1) * Ai(2, t2), n2 = 0)); t2 >= 8; r2[d2++] = 255 & a2, a2 /= 256, t2 -= 8)
        ;
      for (n2 = n2 << t2 | a2, o2 += t2; o2 > 0; r2[d2++] = 255 & n2, n2 /= 256, o2 -= 8)
        ;
      return r2[--d2] |= 128 * s2, r2;
    };
    var Ti = function(e2, t2) {
      var i2, n2 = e2.length, a2 = 8 * n2 - t2 - 1, p2 = (1 << a2) - 1, r2 = p2 >> 1, o2 = a2 - 7, m2 = n2 - 1, c2 = e2[m2--], l2 = 127 & c2;
      for (c2 >>= 7; o2 > 0; l2 = 256 * l2 + e2[m2], m2--, o2 -= 8)
        ;
      for (i2 = l2 & (1 << -o2) - 1, l2 >>= -o2, o2 += t2; o2 > 0; i2 = 256 * i2 + e2[m2], m2--, o2 -= 8)
        ;
      if (0 === l2)
        l2 = 1 - r2;
      else {
        if (l2 === p2)
          return i2 ? NaN : c2 ? -1 / 0 : 1 / 0;
        i2 += Ai(2, t2), l2 -= r2;
      }
      return (c2 ? -1 : 1) * i2 * Ai(2, l2 - t2);
    };
    var Ii = function(e2) {
      for (var t2 = kt(this), i2 = xe(t2.length), n2 = arguments.length, a2 = ge(n2 > 1 ? arguments[1] : void 0, i2), p2 = n2 > 2 ? arguments[2] : void 0, r2 = void 0 === p2 ? i2 : ge(p2, i2); r2 > a2; )
        t2[a2++] = e2;
      return t2;
    };
    var Ri = y.f;
    var Li = st("toStringTag");
    var Ui = function(e2, t2, i2) {
      e2 && !F(e2 = i2 ? e2 : e2.prototype, Li) && Ri(e2, Li, { configurable: true, value: t2 });
    };
    var zi = je.f;
    var Ni = y.f;
    var Fi = me.get;
    var Pi = me.set;
    var Ci = r.ArrayBuffer;
    var Mi = Ci;
    var qi = r.DataView;
    var Di = qi && qi.prototype;
    var Bi = Object.prototype;
    var Vi = r.RangeError;
    var Gi = Oi;
    var $i = Ti;
    var Wi = function(e2) {
      return [255 & e2];
    };
    var Yi = function(e2) {
      return [255 & e2, e2 >> 8 & 255];
    };
    var Hi = function(e2) {
      return [255 & e2, e2 >> 8 & 255, e2 >> 16 & 255, e2 >> 24 & 255];
    };
    var Qi = function(e2) {
      return e2[3] << 24 | e2[2] << 16 | e2[1] << 8 | e2[0];
    };
    var Xi = function(e2) {
      return Gi(e2, 23, 4);
    };
    var Ki = function(e2) {
      return Gi(e2, 52, 8);
    };
    var Zi = function(e2, t2) {
      Ni(e2.prototype, t2, { get: function() {
        return Fi(this)[t2];
      } });
    };
    var Ji = function(e2, t2, i2, n2) {
      var a2 = wi(i2), p2 = Fi(e2);
      if (a2 + t2 > p2.byteLength)
        throw Vi("Wrong index");
      var r2 = Fi(p2.buffer).bytes, o2 = a2 + p2.byteOffset, m2 = r2.slice(o2, o2 + t2);
      return n2 ? m2 : m2.reverse();
    };
    var en = function(e2, t2, i2, n2, a2, p2) {
      var r2 = wi(i2), o2 = Fi(e2);
      if (r2 + t2 > o2.byteLength)
        throw Vi("Wrong index");
      for (var m2 = Fi(o2.buffer).bytes, c2 = r2 + o2.byteOffset, l2 = n2(+a2), s2 = 0; s2 < t2; s2++)
        m2[c2 + s2] = l2[p2 ? s2 : t2 - s2 - 1];
    };
    if (Yt) {
      if (!t(function() {
        Ci(1);
      }) || !t(function() {
        new Ci(-1);
      }) || t(function() {
        return new Ci(), new Ci(1.5), new Ci(NaN), "ArrayBuffer" != Ci.name;
      })) {
        for (nn = (Mi = function(e2) {
          return bi(this, Mi), new Ci(wi(e2));
        }).prototype = Ci.prototype, an = zi(Ci), pn = 0; an.length > pn; )
          (tn = an[pn++]) in Mi || M(Mi, tn, Ci[tn]);
        nn.constructor = Mi;
      }
      Zt && Kt(Di) !== Bi && Zt(Di, Bi);
      rn = new qi(new Mi(2)), on = Di.setInt8;
      rn.setInt8(0, 2147483648), rn.setInt8(1, 2147483649), !rn.getInt8(0) && rn.getInt8(1) || gi(Di, { setInt8: function(e2, t2) {
        on.call(this, e2, t2 << 24 >> 24);
      }, setUint8: function(e2, t2) {
        on.call(this, e2, t2 << 24 >> 24);
      } }, { unsafe: true });
    } else
      Mi = function(e2) {
        bi(this, Mi, "ArrayBuffer");
        var t2 = wi(e2);
        Pi(this, { bytes: Ii.call(new Array(t2), 0), byteLength: t2 }), i || (this.byteLength = t2);
      }, qi = function(e2, t2, n2) {
        bi(this, qi, "DataView"), bi(e2, Mi, "DataView");
        var a2 = Fi(e2).byteLength, p2 = ye(t2);
        if (p2 < 0 || p2 > a2)
          throw Vi("Wrong offset");
        if (p2 + (n2 = void 0 === n2 ? a2 - p2 : xe(n2)) > a2)
          throw Vi("Wrong length");
        Pi(this, { buffer: e2, byteLength: n2, byteOffset: p2 }), i || (this.buffer = e2, this.byteLength = n2, this.byteOffset = p2);
      }, i && (Zi(Mi, "byteLength"), Zi(qi, "buffer"), Zi(qi, "byteLength"), Zi(qi, "byteOffset")), gi(qi.prototype, { getInt8: function(e2) {
        return Ji(this, 1, e2)[0] << 24 >> 24;
      }, getUint8: function(e2) {
        return Ji(this, 1, e2)[0];
      }, getInt16: function(e2) {
        var t2 = Ji(this, 2, e2, arguments.length > 1 ? arguments[1] : void 0);
        return (t2[1] << 8 | t2[0]) << 16 >> 16;
      }, getUint16: function(e2) {
        var t2 = Ji(this, 2, e2, arguments.length > 1 ? arguments[1] : void 0);
        return t2[1] << 8 | t2[0];
      }, getInt32: function(e2) {
        return Qi(Ji(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0));
      }, getUint32: function(e2) {
        return Qi(Ji(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
      }, getFloat32: function(e2) {
        return $i(Ji(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0), 23);
      }, getFloat64: function(e2) {
        return $i(Ji(this, 8, e2, arguments.length > 1 ? arguments[1] : void 0), 52);
      }, setInt8: function(e2, t2) {
        en(this, 1, e2, Wi, t2);
      }, setUint8: function(e2, t2) {
        en(this, 1, e2, Wi, t2);
      }, setInt16: function(e2, t2) {
        en(this, 2, e2, Yi, t2, arguments.length > 2 ? arguments[2] : void 0);
      }, setUint16: function(e2, t2) {
        en(this, 2, e2, Yi, t2, arguments.length > 2 ? arguments[2] : void 0);
      }, setInt32: function(e2, t2) {
        en(this, 4, e2, Hi, t2, arguments.length > 2 ? arguments[2] : void 0);
      }, setUint32: function(e2, t2) {
        en(this, 4, e2, Hi, t2, arguments.length > 2 ? arguments[2] : void 0);
      }, setFloat32: function(e2, t2) {
        en(this, 4, e2, Xi, t2, arguments.length > 2 ? arguments[2] : void 0);
      }, setFloat64: function(e2, t2) {
        en(this, 8, e2, Ki, t2, arguments.length > 2 ? arguments[2] : void 0);
      } });
    var tn;
    var nn;
    var an;
    var pn;
    var rn;
    var on;
    Ui(Mi, "ArrayBuffer"), Ui(qi, "DataView");
    var mn;
    var cn = { ArrayBuffer: Mi, DataView: qi };
    var ln = function(e2, t2) {
      var i2 = function(e3) {
        var t3 = ye(e3);
        if (t3 < 0)
          throw RangeError("The argument can't be less than 0");
        return t3;
      }(e2);
      if (i2 % t2)
        throw RangeError("Wrong offset");
      return i2;
    };
    var sn = Object.keys || function(e2) {
      return Ae(e2, Ee);
    };
    var dn = i ? Object.defineProperties : function(e2, t2) {
      d(e2);
      for (var i2, n2 = sn(t2), a2 = n2.length, p2 = 0; a2 > p2; )
        y.f(e2, i2 = n2[p2++], t2[i2]);
      return e2;
    };
    var un = de("document", "documentElement");
    var fn = ee("IE_PROTO");
    var yn = function() {
    };
    var vn = function(e2) {
      return "<script>" + e2 + "<\/script>";
    };
    var xn = function() {
      try {
        mn = document.domain && new ActiveXObject("htmlfile");
      } catch (e3) {
      }
      var e2, t2;
      xn = mn ? function(e3) {
        e3.write(vn("")), e3.close();
        var t3 = e3.parentWindow.Object;
        return e3 = null, t3;
      }(mn) : ((t2 = l("iframe")).style.display = "none", un.appendChild(t2), t2.src = String("javascript:"), (e2 = t2.contentWindow.document).open(), e2.write(vn("document.F=Object")), e2.close(), e2.F);
      for (var i2 = Ee.length; i2--; )
        delete xn.prototype[Ee[i2]];
      return xn();
    };
    te[fn] = true;
    var _n = Object.create || function(e2, t2) {
      var i2;
      return null !== e2 ? (yn.prototype = d(e2), i2 = new yn(), yn.prototype = null, i2[fn] = e2) : i2 = xn(), void 0 === t2 ? i2 : dn(i2, t2);
    };
    var hn = {};
    var gn = st("iterator");
    var bn = function(e2) {
      if (null != e2)
        return e2[gn] || e2["@@iterator"] || hn[Ft(e2)];
    };
    var wn = st("iterator");
    var kn = Array.prototype;
    var An = function(e2) {
      return void 0 !== e2 && (hn.Array === e2 || kn[wn] === e2);
    };
    var En = function(e2) {
      if ("function" != typeof e2)
        throw TypeError(String(e2) + " is not a function");
      return e2;
    };
    var Sn = function(e2, t2, i2) {
      if (En(e2), void 0 === t2)
        return e2;
      switch (i2) {
        case 0:
          return function() {
            return e2.call(t2);
          };
        case 1:
          return function(i3) {
            return e2.call(t2, i3);
          };
        case 2:
          return function(i3, n2) {
            return e2.call(t2, i3, n2);
          };
        case 3:
          return function(i3, n2, a2) {
            return e2.call(t2, i3, n2, a2);
          };
      }
      return function() {
        return e2.apply(t2, arguments);
      };
    };
    var jn = yi.aTypedArrayConstructor;
    var On = function(e2) {
      var t2, i2, n2, a2, p2, r2, o2 = kt(e2), m2 = arguments.length, c2 = m2 > 1 ? arguments[1] : void 0, l2 = void 0 !== c2, s2 = bn(o2);
      if (null != s2 && !An(s2))
        for (r2 = (p2 = s2.call(o2)).next, o2 = []; !(a2 = r2.call(p2)).done; )
          o2.push(a2.value);
      for (l2 && m2 > 2 && (c2 = Sn(c2, arguments[2], 2)), i2 = xe(o2.length), n2 = new (jn(this))(i2), t2 = 0; i2 > t2; t2++)
        n2[t2] = l2 ? c2(o2[t2], t2) : o2[t2];
      return n2;
    };
    var Tn = Array.isArray || function(e2) {
      return "Array" == I(e2);
    };
    var In = st("species");
    var Rn = function(e2, t2) {
      var i2;
      return Tn(e2) && ("function" != typeof (i2 = e2.constructor) || i2 !== Array && !Tn(i2.prototype) ? o(i2) && null === (i2 = i2[In]) && (i2 = void 0) : i2 = void 0), new (void 0 === i2 ? Array : i2)(0 === t2 ? 0 : t2);
    };
    var Ln = [].push;
    var Un = function(e2) {
      var t2 = 1 == e2, i2 = 2 == e2, n2 = 3 == e2, a2 = 4 == e2, p2 = 6 == e2, r2 = 7 == e2, o2 = 5 == e2 || p2;
      return function(m2, c2, l2, s2) {
        for (var d2, u2, f2 = kt(m2), y2 = L(f2), v2 = Sn(c2, l2, 3), x2 = xe(y2.length), _2 = 0, h2 = s2 || Rn, g2 = t2 ? h2(m2, x2) : i2 || r2 ? h2(m2, 0) : void 0; x2 > _2; _2++)
          if ((o2 || _2 in y2) && (u2 = v2(d2 = y2[_2], _2, f2), e2))
            if (t2)
              g2[_2] = u2;
            else if (u2)
              switch (e2) {
                case 3:
                  return true;
                case 5:
                  return d2;
                case 6:
                  return _2;
                case 2:
                  Ln.call(g2, d2);
              }
            else
              switch (e2) {
                case 4:
                  return false;
                case 7:
                  Ln.call(g2, d2);
              }
        return p2 ? -1 : n2 || a2 ? a2 : g2;
      };
    };
    var zn = { forEach: Un(0), map: Un(1), filter: Un(2), some: Un(3), every: Un(4), find: Un(5), findIndex: Un(6), filterOut: Un(7) };
    var Nn = st("species");
    var Fn = function(e2, t2, i2) {
      var n2, a2;
      return Zt && "function" == typeof (n2 = t2.constructor) && n2 !== i2 && o(a2 = n2.prototype) && a2 !== i2.prototype && Zt(e2, a2), e2;
    };
    a(function(e2) {
      var t2 = je.f, n2 = zn.forEach, a2 = me.get, p2 = me.set, m2 = y.f, c2 = C.f, l2 = Math.round, s2 = r.RangeError, d2 = cn.ArrayBuffer, f2 = cn.DataView, v2 = yi.NATIVE_ARRAY_BUFFER_VIEWS, x2 = yi.TYPED_ARRAY_TAG, _2 = yi.TypedArray, h2 = yi.TypedArrayPrototype, g2 = yi.aTypedArrayConstructor, b2 = yi.isTypedArray, w2 = "BYTES_PER_ELEMENT", k2 = "Wrong length", A2 = function(e3, t3) {
        for (var i2 = 0, n3 = t3.length, a3 = new (g2(e3))(n3); n3 > i2; )
          a3[i2] = t3[i2++];
        return a3;
      }, E2 = function(e3, t3) {
        m2(e3, t3, { get: function() {
          return a2(this)[t3];
        } });
      }, S2 = function(e3) {
        var t3;
        return e3 instanceof d2 || "ArrayBuffer" == (t3 = Ft(e3)) || "SharedArrayBuffer" == t3;
      }, j2 = function(e3, t3) {
        return b2(e3) && "symbol" != typeof t3 && t3 in e3 && String(+t3) == String(t3);
      }, T2 = function(e3, t3) {
        return j2(e3, t3 = u(t3, true)) ? O(2, e3[t3]) : c2(e3, t3);
      }, I2 = function(e3, t3, i2) {
        return !(j2(e3, t3 = u(t3, true)) && o(i2) && F(i2, "value")) || F(i2, "get") || F(i2, "set") || i2.configurable || F(i2, "writable") && !i2.writable || F(i2, "enumerable") && !i2.enumerable ? m2(e3, t3, i2) : (e3[t3] = i2.value, e3);
      };
      i ? (v2 || (C.f = T2, y.f = I2, E2(h2, "buffer"), E2(h2, "byteOffset"), E2(h2, "byteLength"), E2(h2, "length")), Me({ target: "Object", stat: true, forced: !v2 }, { getOwnPropertyDescriptor: T2, defineProperty: I2 }), e2.exports = function(e3, c3, u2) {
        var g3 = e3.match(/\d+$/)[0] / 8, E3 = e3 + (u2 ? "Clamped" : "") + "Array", j3 = "get" + e3, O2 = "set" + e3, T3 = r[E3], I3 = T3, R2 = I3 && I3.prototype, L2 = {}, U2 = function(e4, t3) {
          m2(e4, t3, { get: function() {
            return function(e5, t4) {
              var i2 = a2(e5);
              return i2.view[j3](t4 * g3 + i2.byteOffset, true);
            }(this, t3);
          }, set: function(e5) {
            return function(e6, t4, i2) {
              var n3 = a2(e6);
              u2 && (i2 = (i2 = l2(i2)) < 0 ? 0 : i2 > 255 ? 255 : 255 & i2), n3.view[O2](t4 * g3 + n3.byteOffset, i2, true);
            }(this, t3, e5);
          }, enumerable: true });
        };
        v2 ? hi && (I3 = c3(function(e4, t3, i2, n3) {
          return bi(e4, I3, E3), Fn(o(t3) ? S2(t3) ? void 0 !== n3 ? new T3(t3, ln(i2, g3), n3) : void 0 !== i2 ? new T3(t3, ln(i2, g3)) : new T3(t3) : b2(t3) ? A2(I3, t3) : On.call(I3, t3) : new T3(wi(t3)), e4, I3);
        }), Zt && Zt(I3, _2), n2(t2(T3), function(e4) {
          e4 in I3 || M(I3, e4, T3[e4]);
        }), I3.prototype = R2) : (I3 = c3(function(e4, t3, i2, n3) {
          bi(e4, I3, E3);
          var a3, r2, m3, c4 = 0, l3 = 0;
          if (o(t3)) {
            if (!S2(t3))
              return b2(t3) ? A2(I3, t3) : On.call(I3, t3);
            a3 = t3, l3 = ln(i2, g3);
            var u3 = t3.byteLength;
            if (void 0 === n3) {
              if (u3 % g3)
                throw s2(k2);
              if ((r2 = u3 - l3) < 0)
                throw s2(k2);
            } else if ((r2 = xe(n3) * g3) + l3 > u3)
              throw s2(k2);
            m3 = r2 / g3;
          } else
            m3 = wi(t3), a3 = new d2(r2 = m3 * g3);
          for (p2(e4, { buffer: a3, byteOffset: l3, byteLength: r2, length: m3, view: new f2(a3) }); c4 < m3; )
            U2(e4, c4++);
        }), Zt && Zt(I3, _2), R2 = I3.prototype = _n(h2)), R2.constructor !== I3 && M(R2, "constructor", I3), x2 && M(R2, x2, E3), L2[E3] = I3, Me({ global: true, forced: I3 != T3, sham: !v2 }, L2), w2 in I3 || M(I3, w2, g3), w2 in R2 || M(R2, w2, g3), function(e4) {
          var t3 = de(e4), n3 = y.f;
          i && t3 && !t3[Nn] && n3(t3, Nn, { configurable: true, get: function() {
            return this;
          } });
        }(E3);
      }) : e2.exports = function() {
      };
    })("Uint8", function(e2) {
      return function(t2, i2, n2) {
        return e2(this, t2, i2, n2);
      };
    });
    var Pn = Math.min;
    var Cn = [].copyWithin || function(e2, t2) {
      var i2 = kt(this), n2 = xe(i2.length), a2 = ge(e2, n2), p2 = ge(t2, n2), r2 = arguments.length > 2 ? arguments[2] : void 0, o2 = Pn((void 0 === r2 ? n2 : ge(r2, n2)) - p2, n2 - a2), m2 = 1;
      for (p2 < a2 && a2 < p2 + o2 && (m2 = -1, p2 += o2 - 1, a2 += o2 - 1); o2-- > 0; )
        p2 in i2 ? i2[a2] = i2[p2] : delete i2[a2], a2 += m2, p2 += m2;
      return i2;
    };
    var Mn = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("copyWithin", function(e2, t2) {
      return Cn.call(Mn(this), e2, t2, arguments.length > 2 ? arguments[2] : void 0);
    });
    var qn = zn.every;
    var Dn = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("every", function(e2) {
      return qn(Dn(this), e2, arguments.length > 1 ? arguments[1] : void 0);
    });
    var Bn = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("fill", function(e2) {
      return Ii.apply(Bn(this), arguments);
    });
    var Vn = st("species");
    var Gn = function(e2, t2) {
      var i2, n2 = d(e2).constructor;
      return void 0 === n2 || null == (i2 = d(n2)[Vn]) ? t2 : En(i2);
    };
    var $n = yi.aTypedArrayConstructor;
    var Wn = function(e2, t2) {
      for (var i2 = Gn(e2, e2.constructor), n2 = 0, a2 = t2.length, p2 = new ($n(i2))(a2); a2 > n2; )
        p2[n2] = t2[n2++];
      return p2;
    };
    var Yn = zn.filter;
    var Hn = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("filter", function(e2) {
      var t2 = Yn(Hn(this), e2, arguments.length > 1 ? arguments[1] : void 0);
      return Wn(this, t2);
    });
    var Qn = zn.find;
    var Xn = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("find", function(e2) {
      return Qn(Xn(this), e2, arguments.length > 1 ? arguments[1] : void 0);
    });
    var Kn = zn.findIndex;
    var Zn = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("findIndex", function(e2) {
      return Kn(Zn(this), e2, arguments.length > 1 ? arguments[1] : void 0);
    });
    var Jn = zn.forEach;
    var ea = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("forEach", function(e2) {
      Jn(ea(this), e2, arguments.length > 1 ? arguments[1] : void 0);
    });
    var ta = we.includes;
    var ia = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("includes", function(e2) {
      return ta(ia(this), e2, arguments.length > 1 ? arguments[1] : void 0);
    });
    var na = we.indexOf;
    var aa = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("indexOf", function(e2) {
      return na(aa(this), e2, arguments.length > 1 ? arguments[1] : void 0);
    });
    var pa = st("unscopables");
    var ra = Array.prototype;
    null == ra[pa] && y.f(ra, pa, { configurable: true, value: _n(null) });
    var oa;
    var ma;
    var ca;
    var la = function(e2) {
      ra[pa][e2] = true;
    };
    var sa = st("iterator");
    var da = false;
    [].keys && ("next" in (ca = [].keys()) ? (ma = Kt(Kt(ca))) !== Object.prototype && (oa = ma) : da = true), (null == oa || t(function() {
      var e2 = {};
      return oa[sa].call(e2) !== e2;
    })) && (oa = {}), F(oa, sa) || M(oa, sa, function() {
      return this;
    });
    var ua = { IteratorPrototype: oa, BUGGY_SAFARI_ITERATORS: da };
    var fa = ua.IteratorPrototype;
    var ya = function() {
      return this;
    };
    var va = function(e2, t2, i2) {
      var n2 = t2 + " Iterator";
      return e2.prototype = _n(fa, { next: O(1, i2) }), Ui(e2, n2, false), hn[n2] = ya, e2;
    };
    var xa = ua.IteratorPrototype;
    var _a = ua.BUGGY_SAFARI_ITERATORS;
    var ha = st("iterator");
    var ga = function() {
      return this;
    };
    var ba = function(e2, t2, i2, n2, a2, p2, r2) {
      va(i2, t2, n2);
      var o2, m2, c2, l2 = function(e3) {
        if (e3 === a2 && y2)
          return y2;
        if (!_a && e3 in u2)
          return u2[e3];
        switch (e3) {
          case "keys":
          case "values":
          case "entries":
            return function() {
              return new i2(this, e3);
            };
        }
        return function() {
          return new i2(this);
        };
      }, s2 = t2 + " Iterator", d2 = false, u2 = e2.prototype, f2 = u2[ha] || u2["@@iterator"] || a2 && u2[a2], y2 = !_a && f2 || l2(a2), v2 = "Array" == t2 && u2.entries || f2;
      if (v2 && (o2 = Kt(v2.call(new e2())), xa !== Object.prototype && o2.next && (Kt(o2) !== xa && (Zt ? Zt(o2, xa) : "function" != typeof o2[ha] && M(o2, ha, ga)), Ui(o2, s2, true))), "values" == a2 && f2 && "values" !== f2.name && (d2 = true, y2 = function() {
        return f2.call(this);
      }), u2[ha] !== y2 && M(u2, ha, y2), hn[t2] = y2, a2)
        if (m2 = { values: l2("values"), keys: p2 ? y2 : l2("keys"), entries: l2("entries") }, r2)
          for (c2 in m2)
            (_a || d2 || !(c2 in u2)) && ce(u2, c2, m2[c2]);
        else
          Me({ target: t2, proto: true, forced: _a || d2 }, m2);
      return m2;
    };
    var wa = me.set;
    var ka = me.getterFor("Array Iterator");
    var Aa = ba(Array, "Array", function(e2, t2) {
      wa(this, { type: "Array Iterator", target: z(e2), index: 0, kind: t2 });
    }, function() {
      var e2 = ka(this), t2 = e2.target, i2 = e2.kind, n2 = e2.index++;
      return !t2 || n2 >= t2.length ? (e2.target = void 0, { value: void 0, done: true }) : "keys" == i2 ? { value: n2, done: false } : "values" == i2 ? { value: t2[n2], done: false } : { value: [n2, t2[n2]], done: false };
    }, "values");
    hn.Arguments = hn.Array, la("keys"), la("values"), la("entries");
    var Ea = st("iterator");
    var Sa = r.Uint8Array;
    var ja = Aa.values;
    var Oa = Aa.keys;
    var Ta = Aa.entries;
    var Ia = yi.aTypedArray;
    var Ra = yi.exportTypedArrayMethod;
    var La = Sa && Sa.prototype[Ea];
    var Ua = !!La && ("values" == La.name || null == La.name);
    var za = function() {
      return ja.call(Ia(this));
    };
    Ra("entries", function() {
      return Ta.call(Ia(this));
    }), Ra("keys", function() {
      return Oa.call(Ia(this));
    }), Ra("values", za, !Ua), Ra(Ea, za, !Ua);
    var Na = yi.aTypedArray;
    var Fa = [].join;
    (0, yi.exportTypedArrayMethod)("join", function(e2) {
      return Fa.apply(Na(this), arguments);
    });
    var Pa = function(e2, i2) {
      var n2 = [][e2];
      return !!n2 && t(function() {
        n2.call(null, i2 || function() {
          throw 1;
        }, 1);
      });
    };
    var Ca = Math.min;
    var Ma = [].lastIndexOf;
    var qa = !!Ma && 1 / [1].lastIndexOf(1, -0) < 0;
    var Da = Pa("lastIndexOf");
    var Ba = qa || !Da ? function(e2) {
      if (qa)
        return Ma.apply(this, arguments) || 0;
      var t2 = z(this), i2 = xe(t2.length), n2 = i2 - 1;
      for (arguments.length > 1 && (n2 = Ca(n2, ye(arguments[1]))), n2 < 0 && (n2 = i2 + n2); n2 >= 0; n2--)
        if (n2 in t2 && t2[n2] === e2)
          return n2 || 0;
      return -1;
    } : Ma;
    var Va = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("lastIndexOf", function(e2) {
      return Ba.apply(Va(this), arguments);
    });
    var Ga = zn.map;
    var $a = yi.aTypedArray;
    var Wa = yi.aTypedArrayConstructor;
    (0, yi.exportTypedArrayMethod)("map", function(e2) {
      return Ga($a(this), e2, arguments.length > 1 ? arguments[1] : void 0, function(e3, t2) {
        return new (Wa(Gn(e3, e3.constructor)))(t2);
      });
    });
    var Ya = function(e2) {
      return function(t2, i2, n2, a2) {
        En(i2);
        var p2 = kt(t2), r2 = L(p2), o2 = xe(p2.length), m2 = e2 ? o2 - 1 : 0, c2 = e2 ? -1 : 1;
        if (n2 < 2)
          for (; ; ) {
            if (m2 in r2) {
              a2 = r2[m2], m2 += c2;
              break;
            }
            if (m2 += c2, e2 ? m2 < 0 : o2 <= m2)
              throw TypeError("Reduce of empty array with no initial value");
          }
        for (; e2 ? m2 >= 0 : o2 > m2; m2 += c2)
          m2 in r2 && (a2 = i2(a2, r2[m2], m2, p2));
        return a2;
      };
    };
    var Ha = { left: Ya(false), right: Ya(true) };
    var Qa = Ha.left;
    var Xa = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("reduce", function(e2) {
      return Qa(Xa(this), e2, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
    });
    var Ka = Ha.right;
    var Za = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("reduceRight", function(e2) {
      return Ka(Za(this), e2, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
    });
    var Ja = yi.aTypedArray;
    var ep = yi.exportTypedArrayMethod;
    var tp = Math.floor;
    ep("reverse", function() {
      for (var e2, t2 = this, i2 = Ja(t2).length, n2 = tp(i2 / 2), a2 = 0; a2 < n2; )
        e2 = t2[a2], t2[a2++] = t2[--i2], t2[i2] = e2;
      return t2;
    });
    var ip = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("set", function(e2) {
      ip(this);
      var t2 = ln(arguments.length > 1 ? arguments[1] : void 0, 1), i2 = this.length, n2 = kt(e2), a2 = xe(n2.length), p2 = 0;
      if (a2 + t2 > i2)
        throw RangeError("Wrong length");
      for (; p2 < a2; )
        this[t2 + p2] = n2[p2++];
    }, t(function() {
      new Int8Array(1).set({});
    }));
    var np = yi.aTypedArray;
    var ap = yi.aTypedArrayConstructor;
    var pp = [].slice;
    (0, yi.exportTypedArrayMethod)("slice", function(e2, t2) {
      for (var i2 = pp.call(np(this), e2, t2), n2 = Gn(this, this.constructor), a2 = 0, p2 = i2.length, r2 = new (ap(n2))(p2); p2 > a2; )
        r2[a2] = i2[a2++];
      return r2;
    }, t(function() {
      new Int8Array(1).slice();
    }));
    var rp = zn.some;
    var op = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("some", function(e2) {
      return rp(op(this), e2, arguments.length > 1 ? arguments[1] : void 0);
    });
    var mp = yi.aTypedArray;
    var cp = [].sort;
    (0, yi.exportTypedArrayMethod)("sort", function(e2) {
      return cp.call(mp(this), e2);
    });
    var lp = yi.aTypedArray;
    (0, yi.exportTypedArrayMethod)("subarray", function(e2, t2) {
      var i2 = lp(this), n2 = i2.length, a2 = ge(e2, n2);
      return new (Gn(i2, i2.constructor))(i2.buffer, i2.byteOffset + a2 * i2.BYTES_PER_ELEMENT, xe((void 0 === t2 ? n2 : ge(t2, n2)) - a2));
    });
    var sp = r.Int8Array;
    var dp = yi.aTypedArray;
    var up = yi.exportTypedArrayMethod;
    var fp = [].toLocaleString;
    var yp = [].slice;
    var vp = !!sp && t(function() {
      fp.call(new sp(1));
    });
    up("toLocaleString", function() {
      return fp.apply(vp ? yp.call(dp(this)) : dp(this), arguments);
    }, t(function() {
      return [1, 2].toLocaleString() != new sp([1, 2]).toLocaleString();
    }) || !t(function() {
      sp.prototype.toLocaleString.call([1, 2]);
    }));
    var xp = yi.exportTypedArrayMethod;
    var _p = r.Uint8Array;
    var hp = _p && _p.prototype || {};
    var gp = [].toString;
    var bp = [].join;
    t(function() {
      gp.call({});
    }) && (gp = function() {
      return bp.call(this);
    });
    var wp = hp.toString != gp;
    xp("toString", gp, wp);
    var kp = gt.charAt;
    var Ap = me.set;
    var Ep = me.getterFor("String Iterator");
    ba(String, "String", function(e2) {
      Ap(this, { type: "String Iterator", string: String(e2), index: 0 });
    }, function() {
      var e2, t2 = Ep(this), i2 = t2.string, n2 = t2.index;
      return n2 >= i2.length ? { value: void 0, done: true } : (e2 = kp(i2, n2), t2.index += e2.length, { value: e2, done: false });
    });
    var Sp = st("iterator");
    var jp = !t(function() {
      var e2 = new URL("b?a=1&b=2&c=3", "http://a"), t2 = e2.searchParams, i2 = "";
      return e2.pathname = "c%20d", t2.forEach(function(e3, n2) {
        t2.delete("b"), i2 += n2 + e3;
      }), !t2.sort || "http://a/c%20d?a=1&c=3" !== e2.href || "3" !== t2.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t2[Sp] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://тест").host || "#%D0%B1" !== new URL("http://a#б").hash || "a1c3" !== i2 || "x" !== new URL("http://x", void 0).host;
    });
    var Op = Object.assign;
    var Tp = Object.defineProperty;
    var Ip = !Op || t(function() {
      if (i && 1 !== Op({ b: 1 }, Op(Tp({}, "a", { enumerable: true, get: function() {
        Tp(this, "b", { value: 3, enumerable: false });
      } }), { b: 2 })).b)
        return true;
      var e2 = {}, t2 = {}, n2 = Symbol(), a2 = "abcdefghijklmnopqrst";
      return e2[n2] = 7, a2.split("").forEach(function(e3) {
        t2[e3] = e3;
      }), 7 != Op({}, e2)[n2] || sn(Op({}, t2)).join("") != a2;
    }) ? function(e2, t2) {
      for (var n2 = kt(e2), a2 = arguments.length, p2 = 1, r2 = Oe.f, o2 = j.f; a2 > p2; )
        for (var m2, c2 = L(arguments[p2++]), l2 = r2 ? sn(c2).concat(r2(c2)) : sn(c2), s2 = l2.length, d2 = 0; s2 > d2; )
          m2 = l2[d2++], i && !o2.call(c2, m2) || (n2[m2] = c2[m2]);
      return n2;
    } : Op;
    var Rp = function(e2, t2, i2, n2) {
      try {
        return n2 ? t2(d(i2)[0], i2[1]) : t2(i2);
      } catch (t3) {
        throw function(e3) {
          var t4 = e3.return;
          if (void 0 !== t4)
            d(t4.call(e3)).value;
        }(e2), t3;
      }
    };
    var Lp = function(e2, t2, i2) {
      var n2 = u(t2);
      n2 in e2 ? y.f(e2, n2, O(0, i2)) : e2[n2] = i2;
    };
    var Up = function(e2) {
      var t2, i2, n2, a2, p2, r2, o2 = kt(e2), m2 = "function" == typeof this ? this : Array, c2 = arguments.length, l2 = c2 > 1 ? arguments[1] : void 0, s2 = void 0 !== l2, d2 = bn(o2), u2 = 0;
      if (s2 && (l2 = Sn(l2, c2 > 2 ? arguments[2] : void 0, 2)), null == d2 || m2 == Array && An(d2))
        for (i2 = new m2(t2 = xe(o2.length)); t2 > u2; u2++)
          r2 = s2 ? l2(o2[u2], u2) : o2[u2], Lp(i2, u2, r2);
      else
        for (p2 = (a2 = d2.call(o2)).next, i2 = new m2(); !(n2 = p2.call(a2)).done; u2++)
          r2 = s2 ? Rp(a2, l2, [n2.value, u2], true) : n2.value, Lp(i2, u2, r2);
      return i2.length = u2, i2;
    };
    var zp = /[^\0-\u007E]/;
    var Np = /[.\u3002\uFF0E\uFF61]/g;
    var Fp = "Overflow: input needs wider integers to process";
    var Pp = Math.floor;
    var Cp = String.fromCharCode;
    var Mp = function(e2) {
      return e2 + 22 + 75 * (e2 < 26);
    };
    var qp = function(e2, t2, i2) {
      var n2 = 0;
      for (e2 = i2 ? Pp(e2 / 700) : e2 >> 1, e2 += Pp(e2 / t2); e2 > 455; n2 += 36)
        e2 = Pp(e2 / 35);
      return Pp(n2 + 36 * e2 / (e2 + 38));
    };
    var Dp = function(e2) {
      var t2, i2, n2 = [], a2 = (e2 = function(e3) {
        for (var t3 = [], i3 = 0, n3 = e3.length; i3 < n3; ) {
          var a3 = e3.charCodeAt(i3++);
          if (a3 >= 55296 && a3 <= 56319 && i3 < n3) {
            var p3 = e3.charCodeAt(i3++);
            56320 == (64512 & p3) ? t3.push(((1023 & a3) << 10) + (1023 & p3) + 65536) : (t3.push(a3), i3--);
          } else
            t3.push(a3);
        }
        return t3;
      }(e2)).length, p2 = 128, r2 = 0, o2 = 72;
      for (t2 = 0; t2 < e2.length; t2++)
        (i2 = e2[t2]) < 128 && n2.push(Cp(i2));
      var m2 = n2.length, c2 = m2;
      for (m2 && n2.push("-"); c2 < a2; ) {
        var l2 = 2147483647;
        for (t2 = 0; t2 < e2.length; t2++)
          (i2 = e2[t2]) >= p2 && i2 < l2 && (l2 = i2);
        var s2 = c2 + 1;
        if (l2 - p2 > Pp((2147483647 - r2) / s2))
          throw RangeError(Fp);
        for (r2 += (l2 - p2) * s2, p2 = l2, t2 = 0; t2 < e2.length; t2++) {
          if ((i2 = e2[t2]) < p2 && ++r2 > 2147483647)
            throw RangeError(Fp);
          if (i2 == p2) {
            for (var d2 = r2, u2 = 36; ; u2 += 36) {
              var f2 = u2 <= o2 ? 1 : u2 >= o2 + 26 ? 26 : u2 - o2;
              if (d2 < f2)
                break;
              var y2 = d2 - f2, v2 = 36 - f2;
              n2.push(Cp(Mp(f2 + y2 % v2))), d2 = Pp(y2 / v2);
            }
            n2.push(Cp(Mp(d2))), o2 = qp(r2, s2, c2 == m2), r2 = 0, ++c2;
          }
        }
        ++r2, ++p2;
      }
      return n2.join("");
    };
    var Bp = function(e2) {
      var t2 = bn(e2);
      if ("function" != typeof t2)
        throw TypeError(String(e2) + " is not iterable");
      return d(t2.call(e2));
    };
    var Vp = de("fetch");
    var Gp = de("Headers");
    var $p = st("iterator");
    var Wp = me.set;
    var Yp = me.getterFor("URLSearchParams");
    var Hp = me.getterFor("URLSearchParamsIterator");
    var Qp = /\+/g;
    var Xp = Array(4);
    var Kp = function(e2) {
      return Xp[e2 - 1] || (Xp[e2 - 1] = RegExp("((?:%[\\da-f]{2}){" + e2 + "})", "gi"));
    };
    var Zp = function(e2) {
      try {
        return decodeURIComponent(e2);
      } catch (t2) {
        return e2;
      }
    };
    var Jp = function(e2) {
      var t2 = e2.replace(Qp, " "), i2 = 4;
      try {
        return decodeURIComponent(t2);
      } catch (e3) {
        for (; i2; )
          t2 = t2.replace(Kp(i2--), Zp);
        return t2;
      }
    };
    var er = /[!'()~]|%20/g;
    var tr = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" };
    var ir = function(e2) {
      return tr[e2];
    };
    var nr = function(e2) {
      return encodeURIComponent(e2).replace(er, ir);
    };
    var ar = function(e2, t2) {
      if (t2)
        for (var i2, n2, a2 = t2.split("&"), p2 = 0; p2 < a2.length; )
          (i2 = a2[p2++]).length && (n2 = i2.split("="), e2.push({ key: Jp(n2.shift()), value: Jp(n2.join("=")) }));
    };
    var pr = function(e2) {
      this.entries.length = 0, ar(this.entries, e2);
    };
    var rr = function(e2, t2) {
      if (e2 < t2)
        throw TypeError("Not enough arguments");
    };
    var or = va(function(e2, t2) {
      Wp(this, { type: "URLSearchParamsIterator", iterator: Bp(Yp(e2).entries), kind: t2 });
    }, "Iterator", function() {
      var e2 = Hp(this), t2 = e2.kind, i2 = e2.iterator.next(), n2 = i2.value;
      return i2.done || (i2.value = "keys" === t2 ? n2.key : "values" === t2 ? n2.value : [n2.key, n2.value]), i2;
    });
    var mr = function() {
      bi(this, mr, "URLSearchParams");
      var e2, t2, i2, n2, a2, p2, r2, m2, c2, l2 = arguments.length > 0 ? arguments[0] : void 0, s2 = this, u2 = [];
      if (Wp(s2, { type: "URLSearchParams", entries: u2, updateURL: function() {
      }, updateSearchParams: pr }), void 0 !== l2)
        if (o(l2))
          if ("function" == typeof (e2 = bn(l2)))
            for (i2 = (t2 = e2.call(l2)).next; !(n2 = i2.call(t2)).done; ) {
              if ((r2 = (p2 = (a2 = Bp(d(n2.value))).next).call(a2)).done || (m2 = p2.call(a2)).done || !p2.call(a2).done)
                throw TypeError("Expected sequence with length 2");
              u2.push({ key: r2.value + "", value: m2.value + "" });
            }
          else
            for (c2 in l2)
              F(l2, c2) && u2.push({ key: c2, value: l2[c2] + "" });
        else
          ar(u2, "string" == typeof l2 ? "?" === l2.charAt(0) ? l2.slice(1) : l2 : l2 + "");
    };
    var cr = mr.prototype;
    gi(cr, { append: function(e2, t2) {
      rr(arguments.length, 2);
      var i2 = Yp(this);
      i2.entries.push({ key: e2 + "", value: t2 + "" }), i2.updateURL();
    }, delete: function(e2) {
      rr(arguments.length, 1);
      for (var t2 = Yp(this), i2 = t2.entries, n2 = e2 + "", a2 = 0; a2 < i2.length; )
        i2[a2].key === n2 ? i2.splice(a2, 1) : a2++;
      t2.updateURL();
    }, get: function(e2) {
      rr(arguments.length, 1);
      for (var t2 = Yp(this).entries, i2 = e2 + "", n2 = 0; n2 < t2.length; n2++)
        if (t2[n2].key === i2)
          return t2[n2].value;
      return null;
    }, getAll: function(e2) {
      rr(arguments.length, 1);
      for (var t2 = Yp(this).entries, i2 = e2 + "", n2 = [], a2 = 0; a2 < t2.length; a2++)
        t2[a2].key === i2 && n2.push(t2[a2].value);
      return n2;
    }, has: function(e2) {
      rr(arguments.length, 1);
      for (var t2 = Yp(this).entries, i2 = e2 + "", n2 = 0; n2 < t2.length; )
        if (t2[n2++].key === i2)
          return true;
      return false;
    }, set: function(e2, t2) {
      rr(arguments.length, 1);
      for (var i2, n2 = Yp(this), a2 = n2.entries, p2 = false, r2 = e2 + "", o2 = t2 + "", m2 = 0; m2 < a2.length; m2++)
        (i2 = a2[m2]).key === r2 && (p2 ? a2.splice(m2--, 1) : (p2 = true, i2.value = o2));
      p2 || a2.push({ key: r2, value: o2 }), n2.updateURL();
    }, sort: function() {
      var e2, t2, i2, n2 = Yp(this), a2 = n2.entries, p2 = a2.slice();
      for (a2.length = 0, i2 = 0; i2 < p2.length; i2++) {
        for (e2 = p2[i2], t2 = 0; t2 < i2; t2++)
          if (a2[t2].key > e2.key) {
            a2.splice(t2, 0, e2);
            break;
          }
        t2 === i2 && a2.push(e2);
      }
      n2.updateURL();
    }, forEach: function(e2) {
      for (var t2, i2 = Yp(this).entries, n2 = Sn(e2, arguments.length > 1 ? arguments[1] : void 0, 3), a2 = 0; a2 < i2.length; )
        n2((t2 = i2[a2++]).value, t2.key, this);
    }, keys: function() {
      return new or(this, "keys");
    }, values: function() {
      return new or(this, "values");
    }, entries: function() {
      return new or(this, "entries");
    } }, { enumerable: true }), ce(cr, $p, cr.entries), ce(cr, "toString", function() {
      for (var e2, t2 = Yp(this).entries, i2 = [], n2 = 0; n2 < t2.length; )
        e2 = t2[n2++], i2.push(nr(e2.key) + "=" + nr(e2.value));
      return i2.join("&");
    }, { enumerable: true }), Ui(mr, "URLSearchParams"), Me({ global: true, forced: !jp }, { URLSearchParams: mr }), jp || "function" != typeof Vp || "function" != typeof Gp || Me({ global: true, enumerable: true, forced: true }, { fetch: function(e2) {
      var t2, i2, n2, a2 = [e2];
      return arguments.length > 1 && (o(t2 = arguments[1]) && (i2 = t2.body, "URLSearchParams" === Ft(i2) && ((n2 = t2.headers ? new Gp(t2.headers) : new Gp()).has("content-type") || n2.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), t2 = _n(t2, { body: O(0, String(i2)), headers: O(0, n2) }))), a2.push(t2)), Vp.apply(this, a2);
    } });
    var lr;
    var sr = { URLSearchParams: mr, getState: Yp };
    var dr = gt.codeAt;
    var ur = r.URL;
    var fr = sr.URLSearchParams;
    var yr = sr.getState;
    var vr = me.set;
    var xr = me.getterFor("URL");
    var _r = Math.floor;
    var hr = Math.pow;
    var gr = /[A-Za-z]/;
    var br = /[\d+-.A-Za-z]/;
    var wr = /\d/;
    var kr = /^(0x|0X)/;
    var Ar = /^[0-7]+$/;
    var Er = /^\d+$/;
    var Sr = /^[\dA-Fa-f]+$/;
    var jr = /[\u0000\t\u000A\u000D #%/:?@[\\]]/;
    var Or = /[\u0000\t\u000A\u000D #/:?@[\\]]/;
    var Tr = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
    var Ir = /[\t\u000A\u000D]/g;
    var Rr = function(e2, t2) {
      var i2, n2, a2;
      if ("[" == t2.charAt(0)) {
        if ("]" != t2.charAt(t2.length - 1))
          return "Invalid host";
        if (!(i2 = Ur(t2.slice(1, -1))))
          return "Invalid host";
        e2.host = i2;
      } else if (Dr(e2)) {
        if (t2 = function(e3) {
          var t3, i3, n3 = [], a3 = e3.toLowerCase().replace(Np, ".").split(".");
          for (t3 = 0; t3 < a3.length; t3++)
            i3 = a3[t3], n3.push(zp.test(i3) ? "xn--" + Dp(i3) : i3);
          return n3.join(".");
        }(t2), jr.test(t2))
          return "Invalid host";
        if (null === (i2 = Lr(t2)))
          return "Invalid host";
        e2.host = i2;
      } else {
        if (Or.test(t2))
          return "Invalid host";
        for (i2 = "", n2 = Up(t2), a2 = 0; a2 < n2.length; a2++)
          i2 += Mr(n2[a2], Nr);
        e2.host = i2;
      }
    };
    var Lr = function(e2) {
      var t2, i2, n2, a2, p2, r2, o2, m2 = e2.split(".");
      if (m2.length && "" == m2[m2.length - 1] && m2.pop(), (t2 = m2.length) > 4)
        return e2;
      for (i2 = [], n2 = 0; n2 < t2; n2++) {
        if ("" == (a2 = m2[n2]))
          return e2;
        if (p2 = 10, a2.length > 1 && "0" == a2.charAt(0) && (p2 = kr.test(a2) ? 16 : 8, a2 = a2.slice(8 == p2 ? 1 : 2)), "" === a2)
          r2 = 0;
        else {
          if (!(10 == p2 ? Er : 8 == p2 ? Ar : Sr).test(a2))
            return e2;
          r2 = parseInt(a2, p2);
        }
        i2.push(r2);
      }
      for (n2 = 0; n2 < t2; n2++)
        if (r2 = i2[n2], n2 == t2 - 1) {
          if (r2 >= hr(256, 5 - t2))
            return null;
        } else if (r2 > 255)
          return null;
      for (o2 = i2.pop(), n2 = 0; n2 < i2.length; n2++)
        o2 += i2[n2] * hr(256, 3 - n2);
      return o2;
    };
    var Ur = function(e2) {
      var t2, i2, n2, a2, p2, r2, o2, m2 = [0, 0, 0, 0, 0, 0, 0, 0], c2 = 0, l2 = null, s2 = 0, d2 = function() {
        return e2.charAt(s2);
      };
      if (":" == d2()) {
        if (":" != e2.charAt(1))
          return;
        s2 += 2, l2 = ++c2;
      }
      for (; d2(); ) {
        if (8 == c2)
          return;
        if (":" != d2()) {
          for (t2 = i2 = 0; i2 < 4 && Sr.test(d2()); )
            t2 = 16 * t2 + parseInt(d2(), 16), s2++, i2++;
          if ("." == d2()) {
            if (0 == i2)
              return;
            if (s2 -= i2, c2 > 6)
              return;
            for (n2 = 0; d2(); ) {
              if (a2 = null, n2 > 0) {
                if (!("." == d2() && n2 < 4))
                  return;
                s2++;
              }
              if (!wr.test(d2()))
                return;
              for (; wr.test(d2()); ) {
                if (p2 = parseInt(d2(), 10), null === a2)
                  a2 = p2;
                else {
                  if (0 == a2)
                    return;
                  a2 = 10 * a2 + p2;
                }
                if (a2 > 255)
                  return;
                s2++;
              }
              m2[c2] = 256 * m2[c2] + a2, 2 != ++n2 && 4 != n2 || c2++;
            }
            if (4 != n2)
              return;
            break;
          }
          if (":" == d2()) {
            if (s2++, !d2())
              return;
          } else if (d2())
            return;
          m2[c2++] = t2;
        } else {
          if (null !== l2)
            return;
          s2++, l2 = ++c2;
        }
      }
      if (null !== l2)
        for (r2 = c2 - l2, c2 = 7; 0 != c2 && r2 > 0; )
          o2 = m2[c2], m2[c2--] = m2[l2 + r2 - 1], m2[l2 + --r2] = o2;
      else if (8 != c2)
        return;
      return m2;
    };
    var zr = function(e2) {
      var t2, i2, n2, a2;
      if ("number" == typeof e2) {
        for (t2 = [], i2 = 0; i2 < 4; i2++)
          t2.unshift(e2 % 256), e2 = _r(e2 / 256);
        return t2.join(".");
      }
      if ("object" == typeof e2) {
        for (t2 = "", n2 = function(e3) {
          for (var t3 = null, i3 = 1, n3 = null, a3 = 0, p2 = 0; p2 < 8; p2++)
            0 !== e3[p2] ? (a3 > i3 && (t3 = n3, i3 = a3), n3 = null, a3 = 0) : (null === n3 && (n3 = p2), ++a3);
          return a3 > i3 && (t3 = n3, i3 = a3), t3;
        }(e2), i2 = 0; i2 < 8; i2++)
          a2 && 0 === e2[i2] || (a2 && (a2 = false), n2 === i2 ? (t2 += i2 ? ":" : "::", a2 = true) : (t2 += e2[i2].toString(16), i2 < 7 && (t2 += ":")));
        return "[" + t2 + "]";
      }
      return e2;
    };
    var Nr = {};
    var Fr = Ip({}, Nr, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 });
    var Pr = Ip({}, Fr, { "#": 1, "?": 1, "{": 1, "}": 1 });
    var Cr = Ip({}, Pr, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 });
    var Mr = function(e2, t2) {
      var i2 = dr(e2, 0);
      return i2 > 32 && i2 < 127 && !F(t2, e2) ? e2 : encodeURIComponent(e2);
    };
    var qr = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 };
    var Dr = function(e2) {
      return F(qr, e2.scheme);
    };
    var Br = function(e2) {
      return "" != e2.username || "" != e2.password;
    };
    var Vr = function(e2) {
      return !e2.host || e2.cannotBeABaseURL || "file" == e2.scheme;
    };
    var Gr = function(e2, t2) {
      var i2;
      return 2 == e2.length && gr.test(e2.charAt(0)) && (":" == (i2 = e2.charAt(1)) || !t2 && "|" == i2);
    };
    var $r = function(e2) {
      var t2;
      return e2.length > 1 && Gr(e2.slice(0, 2)) && (2 == e2.length || "/" === (t2 = e2.charAt(2)) || "\\" === t2 || "?" === t2 || "#" === t2);
    };
    var Wr = function(e2) {
      var t2 = e2.path, i2 = t2.length;
      !i2 || "file" == e2.scheme && 1 == i2 && Gr(t2[0], true) || t2.pop();
    };
    var Yr = function(e2) {
      return "." === e2 || "%2e" === e2.toLowerCase();
    };
    var Hr = {};
    var Qr = {};
    var Xr = {};
    var Kr = {};
    var Zr = {};
    var Jr = {};
    var eo = {};
    var to = {};
    var io = {};
    var no = {};
    var ao = {};
    var po = {};
    var ro = {};
    var oo = {};
    var mo = {};
    var co = {};
    var lo = {};
    var so = {};
    var uo = {};
    var fo = {};
    var yo = {};
    var vo = function(e2, t2, i2, n2) {
      var a2, p2, r2, o2, m2, c2 = i2 || Hr, l2 = 0, s2 = "", d2 = false, u2 = false, f2 = false;
      for (i2 || (e2.scheme = "", e2.username = "", e2.password = "", e2.host = null, e2.port = null, e2.path = [], e2.query = null, e2.fragment = null, e2.cannotBeABaseURL = false, t2 = t2.replace(Tr, "")), t2 = t2.replace(Ir, ""), a2 = Up(t2); l2 <= a2.length; ) {
        switch (p2 = a2[l2], c2) {
          case Hr:
            if (!p2 || !gr.test(p2)) {
              if (i2)
                return "Invalid scheme";
              c2 = Xr;
              continue;
            }
            s2 += p2.toLowerCase(), c2 = Qr;
            break;
          case Qr:
            if (p2 && (br.test(p2) || "+" == p2 || "-" == p2 || "." == p2))
              s2 += p2.toLowerCase();
            else {
              if (":" != p2) {
                if (i2)
                  return "Invalid scheme";
                s2 = "", c2 = Xr, l2 = 0;
                continue;
              }
              if (i2 && (Dr(e2) != F(qr, s2) || "file" == s2 && (Br(e2) || null !== e2.port) || "file" == e2.scheme && !e2.host))
                return;
              if (e2.scheme = s2, i2)
                return void (Dr(e2) && qr[e2.scheme] == e2.port && (e2.port = null));
              s2 = "", "file" == e2.scheme ? c2 = oo : Dr(e2) && n2 && n2.scheme == e2.scheme ? c2 = Kr : Dr(e2) ? c2 = to : "/" == a2[l2 + 1] ? (c2 = Zr, l2++) : (e2.cannotBeABaseURL = true, e2.path.push(""), c2 = uo);
            }
            break;
          case Xr:
            if (!n2 || n2.cannotBeABaseURL && "#" != p2)
              return "Invalid scheme";
            if (n2.cannotBeABaseURL && "#" == p2) {
              e2.scheme = n2.scheme, e2.path = n2.path.slice(), e2.query = n2.query, e2.fragment = "", e2.cannotBeABaseURL = true, c2 = yo;
              break;
            }
            c2 = "file" == n2.scheme ? oo : Jr;
            continue;
          case Kr:
            if ("/" != p2 || "/" != a2[l2 + 1]) {
              c2 = Jr;
              continue;
            }
            c2 = io, l2++;
            break;
          case Zr:
            if ("/" == p2) {
              c2 = no;
              break;
            }
            c2 = so;
            continue;
          case Jr:
            if (e2.scheme = n2.scheme, p2 == lr)
              e2.username = n2.username, e2.password = n2.password, e2.host = n2.host, e2.port = n2.port, e2.path = n2.path.slice(), e2.query = n2.query;
            else if ("/" == p2 || "\\" == p2 && Dr(e2))
              c2 = eo;
            else if ("?" == p2)
              e2.username = n2.username, e2.password = n2.password, e2.host = n2.host, e2.port = n2.port, e2.path = n2.path.slice(), e2.query = "", c2 = fo;
            else {
              if ("#" != p2) {
                e2.username = n2.username, e2.password = n2.password, e2.host = n2.host, e2.port = n2.port, e2.path = n2.path.slice(), e2.path.pop(), c2 = so;
                continue;
              }
              e2.username = n2.username, e2.password = n2.password, e2.host = n2.host, e2.port = n2.port, e2.path = n2.path.slice(), e2.query = n2.query, e2.fragment = "", c2 = yo;
            }
            break;
          case eo:
            if (!Dr(e2) || "/" != p2 && "\\" != p2) {
              if ("/" != p2) {
                e2.username = n2.username, e2.password = n2.password, e2.host = n2.host, e2.port = n2.port, c2 = so;
                continue;
              }
              c2 = no;
            } else
              c2 = io;
            break;
          case to:
            if (c2 = io, "/" != p2 || "/" != s2.charAt(l2 + 1))
              continue;
            l2++;
            break;
          case io:
            if ("/" != p2 && "\\" != p2) {
              c2 = no;
              continue;
            }
            break;
          case no:
            if ("@" == p2) {
              d2 && (s2 = "%40" + s2), d2 = true, r2 = Up(s2);
              for (var y2 = 0; y2 < r2.length; y2++) {
                var v2 = r2[y2];
                if (":" != v2 || f2) {
                  var x2 = Mr(v2, Cr);
                  f2 ? e2.password += x2 : e2.username += x2;
                } else
                  f2 = true;
              }
              s2 = "";
            } else if (p2 == lr || "/" == p2 || "?" == p2 || "#" == p2 || "\\" == p2 && Dr(e2)) {
              if (d2 && "" == s2)
                return "Invalid authority";
              l2 -= Up(s2).length + 1, s2 = "", c2 = ao;
            } else
              s2 += p2;
            break;
          case ao:
          case po:
            if (i2 && "file" == e2.scheme) {
              c2 = co;
              continue;
            }
            if (":" != p2 || u2) {
              if (p2 == lr || "/" == p2 || "?" == p2 || "#" == p2 || "\\" == p2 && Dr(e2)) {
                if (Dr(e2) && "" == s2)
                  return "Invalid host";
                if (i2 && "" == s2 && (Br(e2) || null !== e2.port))
                  return;
                if (o2 = Rr(e2, s2))
                  return o2;
                if (s2 = "", c2 = lo, i2)
                  return;
                continue;
              }
              "[" == p2 ? u2 = true : "]" == p2 && (u2 = false), s2 += p2;
            } else {
              if ("" == s2)
                return "Invalid host";
              if (o2 = Rr(e2, s2))
                return o2;
              if (s2 = "", c2 = ro, i2 == po)
                return;
            }
            break;
          case ro:
            if (!wr.test(p2)) {
              if (p2 == lr || "/" == p2 || "?" == p2 || "#" == p2 || "\\" == p2 && Dr(e2) || i2) {
                if ("" != s2) {
                  var _2 = parseInt(s2, 10);
                  if (_2 > 65535)
                    return "Invalid port";
                  e2.port = Dr(e2) && _2 === qr[e2.scheme] ? null : _2, s2 = "";
                }
                if (i2)
                  return;
                c2 = lo;
                continue;
              }
              return "Invalid port";
            }
            s2 += p2;
            break;
          case oo:
            if (e2.scheme = "file", "/" == p2 || "\\" == p2)
              c2 = mo;
            else {
              if (!n2 || "file" != n2.scheme) {
                c2 = so;
                continue;
              }
              if (p2 == lr)
                e2.host = n2.host, e2.path = n2.path.slice(), e2.query = n2.query;
              else if ("?" == p2)
                e2.host = n2.host, e2.path = n2.path.slice(), e2.query = "", c2 = fo;
              else {
                if ("#" != p2) {
                  $r(a2.slice(l2).join("")) || (e2.host = n2.host, e2.path = n2.path.slice(), Wr(e2)), c2 = so;
                  continue;
                }
                e2.host = n2.host, e2.path = n2.path.slice(), e2.query = n2.query, e2.fragment = "", c2 = yo;
              }
            }
            break;
          case mo:
            if ("/" == p2 || "\\" == p2) {
              c2 = co;
              break;
            }
            n2 && "file" == n2.scheme && !$r(a2.slice(l2).join("")) && (Gr(n2.path[0], true) ? e2.path.push(n2.path[0]) : e2.host = n2.host), c2 = so;
            continue;
          case co:
            if (p2 == lr || "/" == p2 || "\\" == p2 || "?" == p2 || "#" == p2) {
              if (!i2 && Gr(s2))
                c2 = so;
              else if ("" == s2) {
                if (e2.host = "", i2)
                  return;
                c2 = lo;
              } else {
                if (o2 = Rr(e2, s2))
                  return o2;
                if ("localhost" == e2.host && (e2.host = ""), i2)
                  return;
                s2 = "", c2 = lo;
              }
              continue;
            }
            s2 += p2;
            break;
          case lo:
            if (Dr(e2)) {
              if (c2 = so, "/" != p2 && "\\" != p2)
                continue;
            } else if (i2 || "?" != p2)
              if (i2 || "#" != p2) {
                if (p2 != lr && (c2 = so, "/" != p2))
                  continue;
              } else
                e2.fragment = "", c2 = yo;
            else
              e2.query = "", c2 = fo;
            break;
          case so:
            if (p2 == lr || "/" == p2 || "\\" == p2 && Dr(e2) || !i2 && ("?" == p2 || "#" == p2)) {
              if (".." === (m2 = (m2 = s2).toLowerCase()) || "%2e." === m2 || ".%2e" === m2 || "%2e%2e" === m2 ? (Wr(e2), "/" == p2 || "\\" == p2 && Dr(e2) || e2.path.push("")) : Yr(s2) ? "/" == p2 || "\\" == p2 && Dr(e2) || e2.path.push("") : ("file" == e2.scheme && !e2.path.length && Gr(s2) && (e2.host && (e2.host = ""), s2 = s2.charAt(0) + ":"), e2.path.push(s2)), s2 = "", "file" == e2.scheme && (p2 == lr || "?" == p2 || "#" == p2))
                for (; e2.path.length > 1 && "" === e2.path[0]; )
                  e2.path.shift();
              "?" == p2 ? (e2.query = "", c2 = fo) : "#" == p2 && (e2.fragment = "", c2 = yo);
            } else
              s2 += Mr(p2, Pr);
            break;
          case uo:
            "?" == p2 ? (e2.query = "", c2 = fo) : "#" == p2 ? (e2.fragment = "", c2 = yo) : p2 != lr && (e2.path[0] += Mr(p2, Nr));
            break;
          case fo:
            i2 || "#" != p2 ? p2 != lr && ("'" == p2 && Dr(e2) ? e2.query += "%27" : e2.query += "#" == p2 ? "%23" : Mr(p2, Nr)) : (e2.fragment = "", c2 = yo);
            break;
          case yo:
            p2 != lr && (e2.fragment += Mr(p2, Fr));
        }
        l2++;
      }
    };
    var xo = function(e2) {
      var t2, n2, a2 = bi(this, xo, "URL"), p2 = arguments.length > 1 ? arguments[1] : void 0, r2 = String(e2), o2 = vr(a2, { type: "URL" });
      if (void 0 !== p2) {
        if (p2 instanceof xo)
          t2 = xr(p2);
        else if (n2 = vo(t2 = {}, String(p2)))
          throw TypeError(n2);
      }
      if (n2 = vo(o2, r2, null, t2))
        throw TypeError(n2);
      var m2 = o2.searchParams = new fr(), c2 = yr(m2);
      c2.updateSearchParams(o2.query), c2.updateURL = function() {
        o2.query = String(m2) || null;
      }, i || (a2.href = ho.call(a2), a2.origin = go.call(a2), a2.protocol = bo.call(a2), a2.username = wo.call(a2), a2.password = ko.call(a2), a2.host = Ao.call(a2), a2.hostname = Eo.call(a2), a2.port = So.call(a2), a2.pathname = jo.call(a2), a2.search = Oo.call(a2), a2.searchParams = To.call(a2), a2.hash = Io.call(a2));
    };
    var _o = xo.prototype;
    var ho = function() {
      var e2 = xr(this), t2 = e2.scheme, i2 = e2.username, n2 = e2.password, a2 = e2.host, p2 = e2.port, r2 = e2.path, o2 = e2.query, m2 = e2.fragment, c2 = t2 + ":";
      return null !== a2 ? (c2 += "//", Br(e2) && (c2 += i2 + (n2 ? ":" + n2 : "") + "@"), c2 += zr(a2), null !== p2 && (c2 += ":" + p2)) : "file" == t2 && (c2 += "//"), c2 += e2.cannotBeABaseURL ? r2[0] : r2.length ? "/" + r2.join("/") : "", null !== o2 && (c2 += "?" + o2), null !== m2 && (c2 += "#" + m2), c2;
    };
    var go = function() {
      var e2 = xr(this), t2 = e2.scheme, i2 = e2.port;
      if ("blob" == t2)
        try {
          return new URL(t2.path[0]).origin;
        } catch (e3) {
          return "null";
        }
      return "file" != t2 && Dr(e2) ? t2 + "://" + zr(e2.host) + (null !== i2 ? ":" + i2 : "") : "null";
    };
    var bo = function() {
      return xr(this).scheme + ":";
    };
    var wo = function() {
      return xr(this).username;
    };
    var ko = function() {
      return xr(this).password;
    };
    var Ao = function() {
      var e2 = xr(this), t2 = e2.host, i2 = e2.port;
      return null === t2 ? "" : null === i2 ? zr(t2) : zr(t2) + ":" + i2;
    };
    var Eo = function() {
      var e2 = xr(this).host;
      return null === e2 ? "" : zr(e2);
    };
    var So = function() {
      var e2 = xr(this).port;
      return null === e2 ? "" : String(e2);
    };
    var jo = function() {
      var e2 = xr(this), t2 = e2.path;
      return e2.cannotBeABaseURL ? t2[0] : t2.length ? "/" + t2.join("/") : "";
    };
    var Oo = function() {
      var e2 = xr(this).query;
      return e2 ? "?" + e2 : "";
    };
    var To = function() {
      return xr(this).searchParams;
    };
    var Io = function() {
      var e2 = xr(this).fragment;
      return e2 ? "#" + e2 : "";
    };
    var Ro = function(e2, t2) {
      return { get: e2, set: t2, configurable: true, enumerable: true };
    };
    if (i && dn(_o, { href: Ro(ho, function(e2) {
      var t2 = xr(this), i2 = String(e2), n2 = vo(t2, i2);
      if (n2)
        throw TypeError(n2);
      yr(t2.searchParams).updateSearchParams(t2.query);
    }), origin: Ro(go), protocol: Ro(bo, function(e2) {
      var t2 = xr(this);
      vo(t2, String(e2) + ":", Hr);
    }), username: Ro(wo, function(e2) {
      var t2 = xr(this), i2 = Up(String(e2));
      if (!Vr(t2)) {
        t2.username = "";
        for (var n2 = 0; n2 < i2.length; n2++)
          t2.username += Mr(i2[n2], Cr);
      }
    }), password: Ro(ko, function(e2) {
      var t2 = xr(this), i2 = Up(String(e2));
      if (!Vr(t2)) {
        t2.password = "";
        for (var n2 = 0; n2 < i2.length; n2++)
          t2.password += Mr(i2[n2], Cr);
      }
    }), host: Ro(Ao, function(e2) {
      var t2 = xr(this);
      t2.cannotBeABaseURL || vo(t2, String(e2), ao);
    }), hostname: Ro(Eo, function(e2) {
      var t2 = xr(this);
      t2.cannotBeABaseURL || vo(t2, String(e2), po);
    }), port: Ro(So, function(e2) {
      var t2 = xr(this);
      Vr(t2) || ("" == (e2 = String(e2)) ? t2.port = null : vo(t2, e2, ro));
    }), pathname: Ro(jo, function(e2) {
      var t2 = xr(this);
      t2.cannotBeABaseURL || (t2.path = [], vo(t2, e2 + "", lo));
    }), search: Ro(Oo, function(e2) {
      var t2 = xr(this);
      "" == (e2 = String(e2)) ? t2.query = null : ("?" == e2.charAt(0) && (e2 = e2.slice(1)), t2.query = "", vo(t2, e2, fo)), yr(t2.searchParams).updateSearchParams(t2.query);
    }), searchParams: Ro(To), hash: Ro(Io, function(e2) {
      var t2 = xr(this);
      "" != (e2 = String(e2)) ? ("#" == e2.charAt(0) && (e2 = e2.slice(1)), t2.fragment = "", vo(t2, e2, yo)) : t2.fragment = null;
    }) }), ce(_o, "toJSON", function() {
      return ho.call(this);
    }, { enumerable: true }), ce(_o, "toString", function() {
      return ho.call(this);
    }, { enumerable: true }), ur) {
      Lo = ur.createObjectURL, Uo = ur.revokeObjectURL;
      Lo && ce(xo, "createObjectURL", function(e2) {
        return Lo.apply(ur, arguments);
      }), Uo && ce(xo, "revokeObjectURL", function(e2) {
        return Uo.apply(ur, arguments);
      });
    }
    var Lo;
    var Uo;
    Ui(xo, "URL"), Me({ global: true, forced: !jp, sham: !i }, { URL: xo });
    var zo = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
    var No = st("iterator");
    var Fo = st("toStringTag");
    var Po = Aa.values;
    for (Co in zo) {
      Mo = r[Co], qo = Mo && Mo.prototype;
      if (qo) {
        if (qo[No] !== Po)
          try {
            M(qo, No, Po);
          } catch (e2) {
            qo[No] = Po;
          }
        if (qo[Fo] || M(qo, Fo, Co), zo[Co]) {
          for (Do in Aa)
            if (qo[Do] !== Aa[Do])
              try {
                M(qo, Do, Aa[Do]);
              } catch (e2) {
                qo[Do] = Aa[Do];
              }
        }
      }
    }
    var Mo;
    var qo;
    var Do;
    var Co;
    var Bo = zn.forEach;
    var Vo = Pa("forEach") ? [].forEach : function(e2) {
      return Bo(this, e2, arguments.length > 1 ? arguments[1] : void 0);
    };
    for (Go in zo) {
      $o = r[Go], Wo = $o && $o.prototype;
      if (Wo && Wo.forEach !== Vo)
        try {
          M(Wo, "forEach", Vo);
        } catch (e2) {
          Wo.forEach = Vo;
        }
    }
    var $o;
    var Wo;
    var Go;
    var Yo = j.f;
    var Ho = function(e2) {
      return function(t2) {
        for (var n2, a2 = z(t2), p2 = sn(a2), r2 = p2.length, o2 = 0, m2 = []; r2 > o2; )
          n2 = p2[o2++], i && !Yo.call(a2, n2) || m2.push(e2 ? [n2, a2[n2]] : a2[n2]);
        return m2;
      };
    };
    var Qo = { entries: Ho(true), values: Ho(false) }.values;
    Me({ target: "Object", stat: true }, { values: function(e2) {
      return Qo(e2);
    } });
    var Xo = st("species");
    var Ko = function(e2) {
      return pt >= 51 || !t(function() {
        var t2 = [];
        return (t2.constructor = {})[Xo] = function() {
          return { foo: 1 };
        }, 1 !== t2[e2](Boolean).foo;
      });
    };
    var Zo = st("isConcatSpreadable");
    var Jo = pt >= 51 || !t(function() {
      var e2 = [];
      return e2[Zo] = false, e2.concat()[0] !== e2;
    });
    var em = Ko("concat");
    var tm = function(e2) {
      if (!o(e2))
        return false;
      var t2 = e2[Zo];
      return void 0 !== t2 ? !!t2 : Tn(e2);
    };
    Me({ target: "Array", proto: true, forced: !Jo || !em }, { concat: function(e2) {
      var t2, i2, n2, a2, p2, r2 = kt(this), o2 = Rn(r2, 0), m2 = 0;
      for (t2 = -1, n2 = arguments.length; t2 < n2; t2++)
        if (tm(p2 = -1 === t2 ? r2 : arguments[t2])) {
          if (m2 + (a2 = xe(p2.length)) > 9007199254740991)
            throw TypeError("Maximum allowed index exceeded");
          for (i2 = 0; i2 < a2; i2++, m2++)
            i2 in p2 && Lp(o2, m2, p2[i2]);
        } else {
          if (m2 >= 9007199254740991)
            throw TypeError("Maximum allowed index exceeded");
          Lp(o2, m2++, p2);
        }
      return o2.length = m2, o2;
    } });
    var im = function() {
      return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, function(e2) {
        return (e2 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> e2 / 4).toString(16);
      });
    };
    var nm = function(e2, t2) {
      var i2;
      if ("string" == typeof e2 ? i2 = document.querySelector(e2) : null != e2.nodeType && (i2 = e2), null == i2)
        throw new Error("Invalid `".concat(t2, "` option provided. Please provide a CSS selector or a plain HTML element."));
      return i2;
    };
    var am = function e2(t2) {
      var i2 = [];
      return null !== t2.nodeType && Object.values(t2.children).forEach(function(t3) {
        i2.push(t3);
        var n2 = e2(t3);
        n2.length > 0 && i2.push.apply(i2, A(n2));
      }), i2;
    };
    var pm = function(e2) {
      (function(e3) {
        if (e3.dataTransfer.types) {
          for (var t2 = 0; t2 < e3.dataTransfer.types.length; t2++)
            if ("Files" === e3.dataTransfer.types[t2])
              return true;
        }
        return false;
      })(e2) && (e2.stopPropagation(), e2.preventDefault ? e2.preventDefault() : e2.returnValue = false);
    };
    var rm = { tb: "TB", gb: "GB", mb: "MB", kb: "KB", b: "b" };
    var om = function(e2) {
      var t2 = 0, i2 = "b";
      if (e2 > 0) {
        for (var n2 = ["tb", "gb", "mb", "kb", "b"], a2 = 0; a2 < n2.length; a2 += 1) {
          var p2 = n2[a2];
          if (e2 >= Math.pow(1024, 4 - a2) / 10) {
            t2 = e2 / Math.pow(1024, 4 - a2), i2 = p2;
            break;
          }
        }
        t2 = Math.round(10 * t2) / 10;
      }
      return "<strong>".concat(t2, "</strong> ").concat(rm[i2]);
    };
    function mm(e2) {
      var t2 = e2.itemManager, i2 = function e3(i3, n3, a2) {
        var p2 = i3.createReader(), r2 = function(e4) {
        };
        return function i4() {
          return p2.readEntries(function(a3) {
            if (a3.length > 0) {
              for (var p3 = function(i5) {
                var p4 = a3[i5];
                p4.isFile ? p4.file(function(e4) {
                  e4.fullPath = "".concat(n3, "/").concat(e4.name), t2.addFile(im(), e4);
                }) : p4.isDirectory && e3(p4, "".concat(n3, "/").concat(p4.name));
              }, r3 = 0; r3 < a3.length; r3 += 1)
                p3(r3);
              i4();
            }
            return null;
          }, r2);
        }();
      }, n2 = function(e3, n3) {
        e3.forEach(function(e4) {
          var a2 = null;
          null != e4.webkitGetAsEntry ? (a2 = e4.webkitGetAsEntry()).isFile && n3 ? t2.addFile(im(), e4.getAsFile()) : a2.isDirectory && i2(a2, a2.name) : null != e4.getAsFile && (null != e4.kind && "file" !== e4.kind || t2.addFile(im(), e4.getAsFile()));
        });
      };
      return { handleDragOver: function(e3) {
        var t3;
        try {
          t3 = e3.dataTransfer.effectAllowed;
        } catch (e4) {
        }
        pm(e3), e3.dataTransfer.dropEffect = "move" === t3 || "linkMove" === t3 ? "move" : "copy";
      }, onDrop: function(e3) {
        if (pm(e3), e3.dataTransfer.items) {
          var i3 = e3.dataTransfer.items;
          i3 && i3.length && null != i3[0].webkitGetAsEntry && n2(i3, true);
        } else
          for (var a2 = 0; a2 < e3.dataTransfer.files.length; a2 += 1) {
            var p2 = im(), r2 = e3.dataTransfer.files[a2];
            t2.addFile(p2, r2);
          }
      } };
    }
    var cm = zn.findIndex;
    var lm = true;
    "findIndex" in [] && Array(1).findIndex(function() {
      lm = false;
    }), Me({ target: "Array", proto: true, forced: lm }, { findIndex: function(e2) {
      return cm(this, e2, arguments.length > 1 ? arguments[1] : void 0);
    } }), la("findIndex");
    var sm = [].join;
    var dm = L != Object;
    var um = Pa("join", ",");
    function fm() {
      var e2, t2 = [], i2 = function(i3) {
        return (!i3.detail || 1 === i3.detail) && (-1 !== t2.findIndex(function(e3) {
          return e3 === i3.target;
        }) && (i3.stopPropagation(), e2.click()), true);
      }, n2 = function(t3) {
        e2 && t3 ? e2.setAttribute("multiple", "multiple") : e2 && !t3 && e2.removeAttribute("multiple");
      }, a2 = function t3(i3) {
        var a3 = i3.config, p2 = i3.itemManager;
        e2 && e2.parentNode.removeChild(e2), (e2 = document.createElement("input")).setAttribute("type", "file"), (null === a3.maxFiles || a3.maxFiles > 1) && n2(true), a3.accepts.length > 0 && e2.setAttribute("accept", a3.accepts.join(",")), e2.setAttribute("tabindex", "-1"), e2.style.visibility = "hidden", e2.style.position = "absolute", e2.style.top = "0", e2.style.left = "0", e2.style.height = "0", e2.style.width = "0", nm(a3.hiddenInputContainer, "hiddenInputContainer").appendChild(e2), e2.addEventListener("change", function() {
          e2.files.forEach(function(e3) {
            p2.addFile(im(), e3);
          }), t3({ config: a3, itemManager: p2 });
        });
      };
      return { initHiddenFileInput: function(e3) {
        var n3 = e3.config, p2 = e3.dropzone, r2 = e3.itemManager;
        if (n3.clickable) {
          var o2, m2 = nm(".".concat(n3.dropzoneMessageClassName), n3.dropzoneMessageClassName), c2 = am(m2);
          if ((t2 = [p2.value]).push(m2), c2.length > 0)
            (o2 = t2).push.apply(o2, A(c2));
          a2({ config: n3, itemManager: r2 }), t2.forEach(function(e4) {
            e4.classList.add("dropzone-clickable"), e4.addEventListener("click", i2);
          });
        }
      }, destroyHiddenFileInput: function() {
        t2.forEach(function(e3) {
          e3.removeEventListener("click", i2);
        }), e2 && (e2.parentElement.removeChild(e2), e2 = null);
      }, setMultiple: n2 };
    }
    Me({ target: "Array", proto: true, forced: dm || !um }, { join: function(e2) {
      return sm.call(z(this), void 0 === e2 ? "," : e2);
    } });
    var ym = zn.find;
    var vm = true;
    "find" in [] && Array(1).find(function() {
      vm = false;
    }), Me({ target: "Array", proto: true, forced: vm }, { find: function(e2) {
      return ym(this, e2, arguments.length > 1 ? arguments[1] : void 0);
    } }), la("find");
    var xm = "	\n\v\f\r                　\u2028\u2029\uFEFF";
    var _m = "[" + xm + "]";
    var hm = RegExp("^" + _m + _m + "*");
    var gm = RegExp(_m + _m + "*$");
    var bm = function(e2) {
      return function(t2) {
        var i2 = String(U(t2));
        return 1 & e2 && (i2 = i2.replace(hm, "")), 2 & e2 && (i2 = i2.replace(gm, "")), i2;
      };
    };
    var wm = { start: bm(1), end: bm(2), trim: bm(3) };
    var km = je.f;
    var Am = C.f;
    var Em = y.f;
    var Sm = wm.trim;
    var jm = r.Number;
    var Om = jm.prototype;
    var Tm = "Number" == I(_n(Om));
    var Im = function(e2) {
      var t2, i2, n2, a2, p2, r2, o2, m2, c2 = u(e2, false);
      if ("string" == typeof c2 && c2.length > 2) {
        if (43 === (t2 = (c2 = Sm(c2)).charCodeAt(0)) || 45 === t2) {
          if (88 === (i2 = c2.charCodeAt(2)) || 120 === i2)
            return NaN;
        } else if (48 === t2) {
          switch (c2.charCodeAt(1)) {
            case 66:
            case 98:
              n2 = 2, a2 = 49;
              break;
            case 79:
            case 111:
              n2 = 8, a2 = 55;
              break;
            default:
              return +c2;
          }
          for (r2 = (p2 = c2.slice(2)).length, o2 = 0; o2 < r2; o2++)
            if ((m2 = p2.charCodeAt(o2)) < 48 || m2 > a2)
              return NaN;
          return parseInt(p2, n2);
        }
      }
      return +c2;
    };
    if (Pe("Number", !jm(" 0o1") || !jm("0b1") || jm("+0x1"))) {
      for (Lm = function(e2) {
        var i2 = arguments.length < 1 ? 0 : e2, n2 = this;
        return n2 instanceof Lm && (Tm ? t(function() {
          Om.valueOf.call(n2);
        }) : "Number" != I(n2)) ? Fn(new jm(Im(i2)), n2, Lm) : Im(i2);
      }, Um = i ? km(jm) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","), zm = 0; Um.length > zm; zm++)
        F(jm, Rm = Um[zm]) && !F(Lm, Rm) && Em(Lm, Rm, Am(jm, Rm));
      Lm.prototype = Om, Om.constructor = Lm, ce(r, "Number", Lm);
    }
    var Rm;
    var Lm;
    var Um;
    var zm;
    var Nm = { url: { type: String, default: null, validator: function(e2) {
      if (null === e2)
        return true;
      try {
        return void 0 !== new URL(e2);
      } catch (e3) {
        return false;
      }
    } }, method: { type: String, default: "POST", validator: function(e2) {
      return "POST" === e2.toUpperCase() || "PUT" === e2.toUpperCase();
    } }, paramName: { type: String, default: "file" }, headers: { type: Object, default: null, validator: function(e2) {
      return !Object.values(e2).find(function(e3) {
        return "string" != typeof e3 && "number" != typeof e3;
      });
    } }, xhrTimeout: { type: Number, default: 6e4, validator: function(e2) {
      return e2 >= 0;
    } }, withCredentials: { type: Boolean, default: false }, uploadOnDrop: { type: Boolean, default: true }, retryOnError: { type: Boolean, default: false }, multipleUpload: { type: Boolean, default: false }, parallelUpload: { type: Number, default: 3 }, maxFiles: { type: Number, default: null }, maxFileSize: { type: Number, default: 1e6 }, hiddenInputContainer: { default: "body" }, clickable: { type: Boolean, default: true }, acceptedFiles: { type: Array, default: null }, chunking: { type: Boolean, default: false }, numberOfChunks: { type: Number, default: 10 } };
    var Fm = zn.filter;
    var Pm = Ko("filter");
    Me({ target: "Array", proto: true, forced: !Pm }, { filter: function(e2) {
      return Fm(this, e2, arguments.length > 1 ? arguments[1] : void 0);
    } });
    var Cm = st("match");
    var Mm = function(e2) {
      var t2;
      return o(e2) && (void 0 !== (t2 = e2[Cm]) ? !!t2 : "RegExp" == I(e2));
    };
    var qm = [].push;
    var Dm = Math.min;
    var Bm = !t(function() {
      return !RegExp(4294967295, "y");
    });
    _t("split", 2, function(e2, t2, i2) {
      var n2;
      return n2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e3, i3) {
        var n3 = String(U(this)), a2 = void 0 === i3 ? 4294967295 : i3 >>> 0;
        if (0 === a2)
          return [];
        if (void 0 === e3)
          return [n3];
        if (!Mm(e3))
          return t2.call(n3, e3, a2);
        for (var p2, r2, o2, m2 = [], c2 = (e3.ignoreCase ? "i" : "") + (e3.multiline ? "m" : "") + (e3.unicode ? "u" : "") + (e3.sticky ? "y" : ""), l2 = 0, s2 = new RegExp(e3.source, c2 + "g"); (p2 = Ke.call(s2, n3)) && !((r2 = s2.lastIndex) > l2 && (m2.push(n3.slice(l2, p2.index)), p2.length > 1 && p2.index < n3.length && qm.apply(m2, p2.slice(1)), o2 = p2[0].length, l2 = r2, m2.length >= a2)); )
          s2.lastIndex === p2.index && s2.lastIndex++;
        return l2 === n3.length ? !o2 && s2.test("") || m2.push("") : m2.push(n3.slice(l2)), m2.length > a2 ? m2.slice(0, a2) : m2;
      } : "0".split(void 0, 0).length ? function(e3, i3) {
        return void 0 === e3 && 0 === i3 ? [] : t2.call(this, e3, i3);
      } : t2, [function(t3, i3) {
        var a2 = U(this), p2 = null == t3 ? void 0 : t3[e2];
        return void 0 !== p2 ? p2.call(t3, a2, i3) : n2.call(String(a2), t3, i3);
      }, function(e3, a2) {
        var p2 = i2(n2, e3, this, a2, n2 !== t2);
        if (p2.done)
          return p2.value;
        var r2 = d(e3), o2 = String(this), m2 = Gn(r2, RegExp), c2 = r2.unicode, l2 = (r2.ignoreCase ? "i" : "") + (r2.multiline ? "m" : "") + (r2.unicode ? "u" : "") + (Bm ? "y" : "g"), s2 = new m2(Bm ? r2 : "^(?:" + r2.source + ")", l2), u2 = void 0 === a2 ? 4294967295 : a2 >>> 0;
        if (0 === u2)
          return [];
        if (0 === o2.length)
          return null === Tt(s2, o2) ? [o2] : [];
        for (var f2 = 0, y2 = 0, v2 = []; y2 < o2.length; ) {
          s2.lastIndex = Bm ? y2 : 0;
          var x2, _2 = Tt(s2, Bm ? o2 : o2.slice(y2));
          if (null === _2 || (x2 = Dm(xe(s2.lastIndex + (Bm ? 0 : y2)), o2.length)) === f2)
            y2 = wt(o2, y2, c2);
          else {
            if (v2.push(o2.slice(f2, y2)), v2.length === u2)
              return v2;
            for (var h2 = 1; h2 <= _2.length - 1; h2++)
              if (v2.push(_2[h2]), v2.length === u2)
                return v2;
            y2 = f2 = x2;
          }
        }
        return v2.push(o2.slice(f2)), v2;
      }];
    }, !Bm);
    var Vm;
    var Gm = function(e2) {
      if (Mm(e2))
        throw TypeError("The method doesn't accept regular expressions");
      return e2;
    };
    var $m = st("match");
    var Wm = function(e2) {
      var t2 = /./;
      try {
        "/./"[e2](t2);
      } catch (i2) {
        try {
          return t2[$m] = false, "/./"[e2](t2);
        } catch (e3) {
        }
      }
      return false;
    };
    var Ym = C.f;
    var Hm = "".startsWith;
    var Qm = Math.min;
    var Xm = Wm("startsWith");
    var Km = !(Xm || (Vm = Ym(String.prototype, "startsWith"), !Vm || Vm.writable));
    Me({ target: "String", proto: true, forced: !Km && !Xm }, { startsWith: function(e2) {
      var t2 = String(U(this));
      Gm(e2);
      var i2 = xe(Qm(arguments.length > 1 ? arguments[1] : void 0, t2.length)), n2 = String(e2);
      return Hm ? Hm.call(t2, n2, i2) : t2.slice(i2, i2 + n2.length) === n2;
    } });
    var Zm = zn.map;
    var Jm = Ko("map");
    Me({ target: "Array", proto: true, forced: !Jm }, { map: function(e2) {
      return Zm(this, e2, arguments.length > 1 ? arguments[1] : void 0);
    } });
    var ec = we.includes;
    Me({ target: "Array", proto: true }, { includes: function(e2) {
      return ec(this, e2, arguments.length > 1 ? arguments[1] : void 0);
    } }), la("includes"), Me({ target: "String", proto: true, forced: !Wm("includes") }, { includes: function(e2) {
      return !!~String(U(this)).indexOf(Gm(e2), arguments.length > 1 ? arguments[1] : void 0);
    } });
    var tc = { data: [{ mime_type: "application/activemessage" }, { mime_type: "application/andrew-inset", ext: "ez" }, { mime_type: "application/applefile" }, { mime_type: "application/applixware", ext: "aw" }, { mime_type: "application/atom+xml", ext: "atom" }, { mime_type: "application/atomcat+xml", ext: "atomcat" }, { mime_type: "application/atomicmail" }, { mime_type: "application/atomsvc+xml", ext: "atomsvc" }, { mime_type: "application/auth-policy+xml" }, { mime_type: "application/batch-smtp" }, { mime_type: "application/beep+xml" }, { mime_type: "application/cals-1840" }, { mime_type: "application/ccxml+xml", ext: "ccxml" }, { mime_type: "application/cea-2018+xml" }, { mime_type: "application/cellml+xml" }, { mime_type: "application/cnrp+xml" }, { mime_type: "application/commonground" }, { mime_type: "application/conference-info+xml" }, { mime_type: "application/cpl+xml" }, { mime_type: "application/csta+xml" }, { mime_type: "application/cstadata+xml" }, { mime_type: "application/cu-seeme", ext: "cu" }, { mime_type: "application/cybercash" }, { mime_type: "application/davmount+xml", ext: "davmount" }, { mime_type: "application/dca-rft" }, { mime_type: "application/dec-dx" }, { mime_type: "application/dialog-info+xml" }, { mime_type: "application/dicom" }, { mime_type: "application/dns" }, { mime_type: "application/dvcs" }, { mime_type: "application/ecmascript", ext: "ecma" }, { mime_type: "application/edi-consent" }, { mime_type: "application/edi-x12" }, { mime_type: "application/edifact" }, { mime_type: "application/emma+xml", ext: "emma" }, { mime_type: "application/epp+xml" }, { mime_type: "application/epub+zip", ext: "epub" }, { mime_type: "application/eshop" }, { mime_type: "application/example" }, { mime_type: "application/fastinfoset" }, { mime_type: "application/fastsoap" }, { mime_type: "application/fits" }, { mime_type: "application/font-tdpfr", ext: "pfr" }, { mime_type: "application/h224" }, { mime_type: "application/http" }, { mime_type: "application/hyperstudio", ext: "stk" }, { mime_type: "application/ibe-key-request+xml" }, { mime_type: "application/ibe-pkg-reply+xml" }, { mime_type: "application/ibe-pp-data" }, { mime_type: "application/iges" }, { mime_type: "application/im-iscomposing+xml" }, { mime_type: "application/index" }, { mime_type: "application/index.cmd" }, { mime_type: "application/index.obj" }, { mime_type: "application/index.response" }, { mime_type: "application/index.vnd" }, { mime_type: "application/iotp" }, { mime_type: "application/ipp" }, { mime_type: "application/isup" }, { mime_type: "application/java-archive", ext: "jar" }, { mime_type: "application/java-serialized-object", ext: "ser" }, { mime_type: "application/java-vm", ext: "class" }, { mime_type: "application/javascript", ext: "js" }, { mime_type: "application/json", ext: "json" }, { mime_type: "application/kpml-request+xml" }, { mime_type: "application/kpml-response+xml" }, { mime_type: "application/lost+xml", ext: "lostxml" }, { mime_type: "application/mac-binhex40", ext: "hqx" }, { mime_type: "application/mac-compactpro", ext: "cpt" }, { mime_type: "application/macwriteii" }, { mime_type: "application/marc", ext: "mrc" }, { mime_type: "application/mathematica", ext: "ma nb mb" }, { mime_type: "application/mathml+xml", ext: "mathml" }, { mime_type: "application/mbms-associated-procedure-description+xml" }, { mime_type: "application/mbms-deregister+xml" }, { mime_type: "application/mbms-envelope+xml" }, { mime_type: "application/mbms-msk+xml" }, { mime_type: "application/mbms-msk-response+xml" }, { mime_type: "application/mbms-protection-description+xml" }, { mime_type: "application/mbms-reception-report+xml" }, { mime_type: "application/mbms-register+xml" }, { mime_type: "application/mbms-register-response+xml" }, { mime_type: "application/mbms-user-service-description+xml" }, { mime_type: "application/mbox", ext: "mbox" }, { mime_type: "application/media_control+xml" }, { mime_type: "application/mediaservercontrol+xml", ext: "mscml" }, { mime_type: "application/mikey" }, { mime_type: "application/moss-keys" }, { mime_type: "application/moss-signature" }, { mime_type: "application/mosskey-data" }, { mime_type: "application/mosskey-request" }, { mime_type: "application/mp4", ext: "mp4s" }, { mime_type: "application/mpeg4-generic" }, { mime_type: "application/mpeg4-iod" }, { mime_type: "application/mpeg4-iod-xmt" }, { mime_type: "application/msword", ext: "doc dot" }, { mime_type: "application/mxf", ext: "mxf" }, { mime_type: "application/nasdata" }, { mime_type: "application/news-checkgroups" }, { mime_type: "application/news-groupinfo" }, { mime_type: "application/news-transmission" }, { mime_type: "application/nss" }, { mime_type: "application/ocsp-request" }, { mime_type: "application/ocsp-response" }, { mime_type: "application/octet-stream bin dms lha lrf lzh so iso dmg dist distz pkg bpk dump elc deploy scpt dmgpart" }, { mime_type: "application/oda", ext: "oda" }, { mime_type: "application/oebps-package+xml", ext: "opf" }, { mime_type: "application/ogg", ext: "ogx" }, { mime_type: "application/onenote", ext: "onetoc onetoc2 onetmp onepkg" }, { mime_type: "application/parityfec" }, { mime_type: "application/patch-ops-error+xml", ext: "xer" }, { mime_type: "application/pdf", ext: "pdf" }, { mime_type: "application/pgp-encrypted", ext: "pgp" }, { mime_type: "application/pgp-keys" }, { mime_type: "application/pgp-signature", ext: "asc sig" }, { mime_type: "application/pics-rules", ext: "prf" }, { mime_type: "application/pidf+xml" }, { mime_type: "application/pidf-diff+xml" }, { mime_type: "application/pkcs10", ext: "p10" }, { mime_type: "application/pkcs7-mime", ext: "p7m p7c" }, { mime_type: "application/pkcs7-signature", ext: "p7s" }, { mime_type: "application/pkix-cert", ext: "cer" }, { mime_type: "application/pkix-crl", ext: "crl" }, { mime_type: "application/pkix-pkipath", ext: "pkipath" }, { mime_type: "application/pkixcmp", ext: "pki" }, { mime_type: "application/pls+xml", ext: "pls" }, { mime_type: "application/poc-settings+xml" }, { mime_type: "application/postscript", ext: "ai eps ps" }, { mime_type: "application/prs.alvestrand.titrax-sheet" }, { mime_type: "application/prs.cww", ext: "cww" }, { mime_type: "application/prs.nprend" }, { mime_type: "application/prs.plucker" }, { mime_type: "application/qsig" }, { mime_type: "application/rdf+xml", ext: "rdf" }, { mime_type: "application/reginfo+xml", ext: "rif" }, { mime_type: "application/relax-ng-compact-syntax", ext: "rnc" }, { mime_type: "application/remote-printing" }, { mime_type: "application/resource-lists+xml", ext: "rl" }, { mime_type: "application/resource-lists-diff+xml", ext: "rld" }, { mime_type: "application/riscos" }, { mime_type: "application/rlmi+xml" }, { mime_type: "application/rls-services+xml", ext: "rs" }, { mime_type: "application/rsd+xml", ext: "rsd" }, { mime_type: "application/rss+xml", ext: "rss" }, { mime_type: "application/rtf", ext: "rtf" }, { mime_type: "application/rtx" }, { mime_type: "application/samlassertion+xml" }, { mime_type: "application/samlmetadata+xml" }, { mime_type: "application/sbml+xml", ext: "sbml" }, { mime_type: "application/scvp-cv-request", ext: "scq" }, { mime_type: "application/scvp-cv-response", ext: "scs" }, { mime_type: "application/scvp-vp-request", ext: "spq" }, { mime_type: "application/scvp-vp-response", ext: "spp" }, { mime_type: "application/sdp", ext: "sdp" }, { mime_type: "application/set-payment" }, { mime_type: "application/set-payment-initiation", ext: "setpay" }, { mime_type: "application/set-registration" }, { mime_type: "application/set-registration-initiation", ext: "setreg" }, { mime_type: "application/sgml" }, { mime_type: "application/sgml-open-catalog" }, { mime_type: "application/shf+xml", ext: "shf" }, { mime_type: "application/sieve" }, { mime_type: "application/simple-filter+xml" }, { mime_type: "application/simple-message-summary" }, { mime_type: "application/simplesymbolcontainer" }, { mime_type: "application/slate" }, { mime_type: "application/smil" }, { mime_type: "application/smil+xml", ext: "smi smil" }, { mime_type: "application/soap+fastinfoset" }, { mime_type: "application/soap+xml" }, { mime_type: "application/sparql-query", ext: "rq" }, { mime_type: "application/sparql-results+xml", ext: "srx" }, { mime_type: "application/spirits-event+xml" }, { mime_type: "application/srgs", ext: "gram" }, { mime_type: "application/srgs+xml", ext: "grxml" }, { mime_type: "application/ssml+xml", ext: "ssml" }, { mime_type: "application/timestamp-query" }, { mime_type: "application/timestamp-reply" }, { mime_type: "application/tve-trigger" }, { mime_type: "application/ulpfec" }, { mime_type: "application/vemmi" }, { mime_type: "application/vividence.scriptfile" }, { mime_type: "application/vnd.3gpp.bsf+xml" }, { mime_type: "application/vnd.3gpp.pic-bw-large", ext: "plb" }, { mime_type: "application/vnd.3gpp.pic-bw-small", ext: "psb" }, { mime_type: "application/vnd.3gpp.pic-bw-var", ext: "pvb" }, { mime_type: "application/vnd.3gpp.sms" }, { mime_type: "application/vnd.3gpp2.bcmcsinfo+xml" }, { mime_type: "application/vnd.3gpp2.sms" }, { mime_type: "application/vnd.3gpp2.tcap", ext: "tcap" }, { mime_type: "application/vnd.3m.post-it-notes", ext: "pwn" }, { mime_type: "application/vnd.accpac.simply.aso", ext: "aso" }, { mime_type: "application/vnd.accpac.simply.imp", ext: "imp" }, { mime_type: "application/vnd.acucobol", ext: "acu" }, { mime_type: "application/vnd.acucorp", ext: "atc acutc" }, { mime_type: "application/vnd.adobe.air-application-installer-package+zip", ext: "air" }, { mime_type: "application/vnd.adobe.xdp+xml", ext: "xdp" }, { mime_type: "application/vnd.adobe.xfdf", ext: "xfdf" }, { mime_type: "application/vnd.aether.imp" }, { mime_type: "application/vnd.airzip.filesecure.azf", ext: "azf" }, { mime_type: "application/vnd.airzip.filesecure.azs", ext: "azs" }, { mime_type: "application/vnd.amazon.ebook", ext: "azw" }, { mime_type: "application/vnd.americandynamics.acc", ext: "acc" }, { mime_type: "application/vnd.amiga.ami", ext: "ami" }, { mime_type: "application/vnd.android.package-archive", ext: "apk" }, { mime_type: "application/vnd.anser-web-certificate-issue-initiation", ext: "cii" }, { mime_type: "application/vnd.anser-web-funds-transfer-initiation", ext: "fti" }, { mime_type: "application/vnd.antix.game-component", ext: "atx" }, { mime_type: "application/vnd.apple.installer+xml", ext: "mpkg" }, { mime_type: "application/vnd.arastra.swi", ext: "swi" }, { mime_type: "application/vnd.audiograph", ext: "aep" }, { mime_type: "application/vnd.autopackage" }, { mime_type: "application/vnd.avistar+xml" }, { mime_type: "application/vnd.blueice.multipass", ext: "mpm" }, { mime_type: "application/vnd.bluetooth.ep.oob" }, { mime_type: "application/vnd.bmi", ext: "bmi" }, { mime_type: "application/vnd.businessobjects", ext: "rep" }, { mime_type: "application/vnd.cab-jscript" }, { mime_type: "application/vnd.canon-cpdl" }, { mime_type: "application/vnd.canon-lips" }, { mime_type: "application/vnd.cendio.thinlinc.clientconf" }, { mime_type: "application/vnd.chemdraw+xml", ext: "cdxml" }, { mime_type: "application/vnd.chipnuts.karaoke-mmd", ext: "mmd" }, { mime_type: "application/vnd.cinderella", ext: "cdy" }, { mime_type: "application/vnd.cirpack.isdn-ext" }, { mime_type: "application/vnd.claymore", ext: "cla" }, { mime_type: "application/vnd.clonk.c4group", ext: "c4g c4d c4f c4p c4u" }, { mime_type: "application/vnd.commerce-battelle" }, { mime_type: "application/vnd.commonspace", ext: "csp" }, { mime_type: "application/vnd.contact.cmsg", ext: "cdbcmsg" }, { mime_type: "application/vnd.cosmocaller", ext: "cmc" }, { mime_type: "application/vnd.crick.clicker", ext: "clkx" }, { mime_type: "application/vnd.crick.clicker.keyboard", ext: "clkk" }, { mime_type: "application/vnd.crick.clicker.palette", ext: "clkp" }, { mime_type: "application/vnd.crick.clicker.template", ext: "clkt" }, { mime_type: "application/vnd.crick.clicker.wordbank", ext: "clkw" }, { mime_type: "application/vnd.criticaltools.wbs+xml", ext: "wbs" }, { mime_type: "application/vnd.ctc-posml", ext: "pml" }, { mime_type: "application/vnd.ctct.ws+xml" }, { mime_type: "application/vnd.cups-pdf" }, { mime_type: "application/vnd.cups-postscript" }, { mime_type: "application/vnd.cups-ppd", ext: "ppd" }, { mime_type: "application/vnd.cups-raster" }, { mime_type: "application/vnd.cups-raw" }, { mime_type: "application/vnd.curl.car", ext: "car" }, { mime_type: "application/vnd.curl.pcurl", ext: "pcurl" }, { mime_type: "application/vnd.cybank" }, { mime_type: "application/vnd.data-vision.rdz", ext: "rdz" }, { mime_type: "application/vnd.denovo.fcselayout-link", ext: "fe_launch" }, { mime_type: "application/vnd.dir-bi.plate-dl-nosuffix" }, { mime_type: "application/vnd.dna", ext: "dna" }, { mime_type: "application/vnd.dolby.mlp", ext: "mlp" }, { mime_type: "application/vnd.dolby.mobile.1" }, { mime_type: "application/vnd.dolby.mobile.2" }, { mime_type: "application/vnd.dpgraph", ext: "dpg" }, { mime_type: "application/vnd.dreamfactory", ext: "dfac" }, { mime_type: "application/vnd.dvb.esgcontainer" }, { mime_type: "application/vnd.dvb.ipdcdftnotifaccess" }, { mime_type: "application/vnd.dvb.ipdcesgaccess" }, { mime_type: "application/vnd.dvb.ipdcroaming" }, { mime_type: "application/vnd.dvb.iptv.alfec-base" }, { mime_type: "application/vnd.dvb.iptv.alfec-enhancement" }, { mime_type: "application/vnd.dvb.notif-aggregate-root+xml" }, { mime_type: "application/vnd.dvb.notif-container+xml" }, { mime_type: "application/vnd.dvb.notif-generic+xml" }, { mime_type: "application/vnd.dvb.notif-ia-msglist+xml" }, { mime_type: "application/vnd.dvb.notif-ia-registration-request+xml" }, { mime_type: "application/vnd.dvb.notif-ia-registration-response+xml" }, { mime_type: "application/vnd.dvb.notif-init+xml" }, { mime_type: "application/vnd.dxr" }, { mime_type: "application/vnd.dynageo", ext: "geo" }, { mime_type: "application/vnd.ecdis-update" }, { mime_type: "application/vnd.ecowin.chart", ext: "mag" }, { mime_type: "application/vnd.ecowin.filerequest" }, { mime_type: "application/vnd.ecowin.fileupdate" }, { mime_type: "application/vnd.ecowin.series" }, { mime_type: "application/vnd.ecowin.seriesrequest" }, { mime_type: "application/vnd.ecowin.seriesupdate" }, { mime_type: "application/vnd.emclient.accessrequest+xml" }, { mime_type: "application/vnd.enliven", ext: "nml" }, { mime_type: "application/vnd.epson.esf", ext: "esf" }, { mime_type: "application/vnd.epson.msf", ext: "msf" }, { mime_type: "application/vnd.epson.quickanime", ext: "qam" }, { mime_type: "application/vnd.epson.salt", ext: "slt" }, { mime_type: "application/vnd.epson.ssf", ext: "ssf" }, { mime_type: "application/vnd.ericsson.quickcall" }, { mime_type: "application/vnd.eszigno3+xml", ext: "es3 et3" }, { mime_type: "application/vnd.etsi.aoc+xml" }, { mime_type: "application/vnd.etsi.cug+xml" }, { mime_type: "application/vnd.etsi.iptvcommand+xml" }, { mime_type: "application/vnd.etsi.iptvdiscovery+xml" }, { mime_type: "application/vnd.etsi.iptvprofile+xml" }, { mime_type: "application/vnd.etsi.iptvsad-bc+xml" }, { mime_type: "application/vnd.etsi.iptvsad-cod+xml" }, { mime_type: "application/vnd.etsi.iptvsad-npvr+xml" }, { mime_type: "application/vnd.etsi.iptvueprofile+xml" }, { mime_type: "application/vnd.etsi.mcid+xml" }, { mime_type: "application/vnd.etsi.sci+xml" }, { mime_type: "application/vnd.etsi.simservs+xml" }, { mime_type: "application/vnd.eudora.data" }, { mime_type: "application/vnd.ezpix-album", ext: "ez2" }, { mime_type: "application/vnd.ezpix-package", ext: "ez3" }, { mime_type: "application/vnd.f-secure.mobile" }, { mime_type: "application/vnd.fdf", ext: "fdf" }, { mime_type: "application/vnd.fdsn.mseed", ext: "mseed" }, { mime_type: "application/vnd.fdsn.seed", ext: "seed dataless" }, { mime_type: "application/vnd.ffsns" }, { mime_type: "application/vnd.fints" }, { mime_type: "application/vnd.flographit", ext: "gph" }, { mime_type: "application/vnd.fluxtime.clip", ext: "ftc" }, { mime_type: "application/vnd.font-fontforge-sfd" }, { mime_type: "application/vnd.framemaker", ext: "fm frame maker book" }, { mime_type: "application/vnd.frogans.fnc", ext: "fnc" }, { mime_type: "application/vnd.frogans.ltf", ext: "ltf" }, { mime_type: "application/vnd.fsc.weblaunch", ext: "fsc" }, { mime_type: "application/vnd.fujitsu.oasys", ext: "oas" }, { mime_type: "application/vnd.fujitsu.oasys2", ext: "oa2" }, { mime_type: "application/vnd.fujitsu.oasys3", ext: "oa3" }, { mime_type: "application/vnd.fujitsu.oasysgp", ext: "fg5" }, { mime_type: "application/vnd.fujitsu.oasysprs", ext: "bh2" }, { mime_type: "application/vnd.fujixerox.art-ex" }, { mime_type: "application/vnd.fujixerox.art4" }, { mime_type: "application/vnd.fujixerox.hbpl" }, { mime_type: "application/vnd.fujixerox.ddd", ext: "ddd" }, { mime_type: "application/vnd.fujixerox.docuworks", ext: "xdw" }, { mime_type: "application/vnd.fujixerox.docuworks.binder", ext: "xbd" }, { mime_type: "application/vnd.fut-misnet" }, { mime_type: "application/vnd.fuzzysheet", ext: "fzs" }, { mime_type: "application/vnd.genomatix.tuxedo", ext: "txd" }, { mime_type: "application/vnd.geogebra.file", ext: "ggb" }, { mime_type: "application/vnd.geogebra.tool", ext: "ggt" }, { mime_type: "application/vnd.geometry-explorer", ext: "gex gre" }, { mime_type: "application/vnd.gmx", ext: "gmx" }, { mime_type: "application/vnd.google-earth.kml+xml", ext: "kml" }, { mime_type: "application/vnd.google-earth.kmz", ext: "kmz" }, { mime_type: "application/vnd.grafeq", ext: "gqf gqs" }, { mime_type: "application/vnd.gridmp" }, { mime_type: "application/vnd.groove-account", ext: "gac" }, { mime_type: "application/vnd.groove-help", ext: "ghf" }, { mime_type: "application/vnd.groove-identity-message", ext: "gim" }, { mime_type: "application/vnd.groove-injector", ext: "grv" }, { mime_type: "application/vnd.groove-tool-message", ext: "gtm" }, { mime_type: "application/vnd.groove-tool-template", ext: "tpl" }, { mime_type: "application/vnd.groove-vcard", ext: "vcg" }, { mime_type: "application/vnd.handheld-entertainment+xml", ext: "zmm" }, { mime_type: "application/vnd.hbci", ext: "hbci" }, { mime_type: "application/vnd.hcl-bireports" }, { mime_type: "application/vnd.hhe.lesson-player", ext: "les" }, { mime_type: "application/vnd.hp-hpgl", ext: "hpgl" }, { mime_type: "application/vnd.hp-hpid", ext: "hpid" }, { mime_type: "application/vnd.hp-hps", ext: "hps" }, { mime_type: "application/vnd.hp-jlyt", ext: "jlt" }, { mime_type: "application/vnd.hp-pcl", ext: "pcl" }, { mime_type: "application/vnd.hp-pclxl", ext: "pclxl" }, { mime_type: "application/vnd.httphone" }, { mime_type: "application/vnd.hydrostatix.sof-data", ext: "sfd-hdstx" }, { mime_type: "application/vnd.hzn-3d-crossword", ext: "x3d" }, { mime_type: "application/vnd.ibm.afplinedata" }, { mime_type: "application/vnd.ibm.electronic-media" }, { mime_type: "application/vnd.ibm.minipay", ext: "mpy" }, { mime_type: "application/vnd.ibm.modcap", ext: "afp listafp list3820" }, { mime_type: "application/vnd.ibm.rights-management", ext: "irm" }, { mime_type: "application/vnd.ibm.secure-container", ext: "sc" }, { mime_type: "application/vnd.iccprofile", ext: "icc icm" }, { mime_type: "application/vnd.igloader", ext: "igl" }, { mime_type: "application/vnd.immervision-ivp", ext: "ivp" }, { mime_type: "application/vnd.immervision-ivu", ext: "ivu" }, { mime_type: "application/vnd.informedcontrol.rms+xml" }, { mime_type: "application/vnd.informix-visionary" }, { mime_type: "application/vnd.intercon.formnet", ext: "xpw xpx" }, { mime_type: "application/vnd.intertrust.digibox" }, { mime_type: "application/vnd.intertrust.nncp" }, { mime_type: "application/vnd.intu.qbo", ext: "qbo" }, { mime_type: "application/vnd.intu.qfx", ext: "qfx" }, { mime_type: "application/vnd.iptc.g2.conceptitem+xml" }, { mime_type: "application/vnd.iptc.g2.knowledgeitem+xml" }, { mime_type: "application/vnd.iptc.g2.newsitem+xml" }, { mime_type: "application/vnd.iptc.g2.packageitem+xml" }, { mime_type: "application/vnd.ipunplugged.rcprofile", ext: "rcprofile" }, { mime_type: "application/vnd.irepository.package+xml", ext: "irp" }, { mime_type: "application/vnd.is-xpr", ext: "xpr" }, { mime_type: "application/vnd.jam", ext: "jam" }, { mime_type: "application/vnd.japannet-directory-service" }, { mime_type: "application/vnd.japannet-jpnstore-wakeup" }, { mime_type: "application/vnd.japannet-payment-wakeup" }, { mime_type: "application/vnd.japannet-registration" }, { mime_type: "application/vnd.japannet-registration-wakeup" }, { mime_type: "application/vnd.japannet-setstore-wakeup" }, { mime_type: "application/vnd.japannet-verification" }, { mime_type: "application/vnd.japannet-verification-wakeup" }, { mime_type: "application/vnd.jcp.javame.midlet-rms", ext: "rms" }, { mime_type: "application/vnd.jisp", ext: "jisp" }, { mime_type: "application/vnd.joost.joda-archive", ext: "joda" }, { mime_type: "application/vnd.kahootz", ext: "ktz ktr" }, { mime_type: "application/vnd.kde.karbon", ext: "karbon" }, { mime_type: "application/vnd.kde.kchart", ext: "chrt" }, { mime_type: "application/vnd.kde.kformula", ext: "kfo" }, { mime_type: "application/vnd.kde.kivio", ext: "flw" }, { mime_type: "application/vnd.kde.kontour", ext: "kon" }, { mime_type: "application/vnd.kde.kpresenter", ext: "kpr kpt" }, { mime_type: "application/vnd.kde.kspread", ext: "ksp" }, { mime_type: "application/vnd.kde.kword", ext: "kwd kwt" }, { mime_type: "application/vnd.kenameaapp", ext: "htke" }, { mime_type: "application/vnd.kidspiration", ext: "kia" }, { mime_type: "application/vnd.kinar", ext: "kne knp" }, { mime_type: "application/vnd.koan", ext: "skp skd skt skm" }, { mime_type: "application/vnd.kodak-descriptor", ext: "sse" }, { mime_type: "application/vnd.liberty-request+xml" }, { mime_type: "application/vnd.llamagraphics.life-balance.desktop", ext: "lbd" }, { mime_type: "application/vnd.llamagraphics.life-balance.exchange+xml", ext: "lbe" }, { mime_type: "application/vnd.lotus-1-2-3", ext: "123" }, { mime_type: "application/vnd.lotus-approach", ext: "apr" }, { mime_type: "application/vnd.lotus-freelance", ext: "pre" }, { mime_type: "application/vnd.lotus-notes", ext: "nsf" }, { mime_type: "application/vnd.lotus-organizer", ext: "org" }, { mime_type: "application/vnd.lotus-screencam", ext: "scm" }, { mime_type: "application/vnd.lotus-wordpro", ext: "lwp" }, { mime_type: "application/vnd.macports.portpkg", ext: "portpkg" }, { mime_type: "application/vnd.marlin.drm.actiontoken+xml" }, { mime_type: "application/vnd.marlin.drm.conftoken+xml" }, { mime_type: "application/vnd.marlin.drm.license+xml" }, { mime_type: "application/vnd.marlin.drm.mdcf" }, { mime_type: "application/vnd.mcd", ext: "mcd" }, { mime_type: "application/vnd.medcalcdata", ext: "mc1" }, { mime_type: "application/vnd.mediastation.cdkey", ext: "cdkey" }, { mime_type: "application/vnd.meridian-slingshot" }, { mime_type: "application/vnd.mfer", ext: "mwf" }, { mime_type: "application/vnd.mfmp", ext: "mfm" }, { mime_type: "application/vnd.micrografx.flo", ext: "flo" }, { mime_type: "application/vnd.micrografx.igx", ext: "igx" }, { mime_type: "application/vnd.mif", ext: "mif" }, { mime_type: "application/vnd.minisoft-hp3000-save" }, { mime_type: "application/vnd.mitsubishi.misty-guard.trustweb" }, { mime_type: "application/vnd.mobius.daf", ext: "daf" }, { mime_type: "application/vnd.mobius.dis", ext: "dis" }, { mime_type: "application/vnd.mobius.mbk", ext: "mbk" }, { mime_type: "application/vnd.mobius.mqy", ext: "mqy" }, { mime_type: "application/vnd.mobius.msl", ext: "msl" }, { mime_type: "application/vnd.mobius.plc", ext: "plc" }, { mime_type: "application/vnd.mobius.txf", ext: "txf" }, { mime_type: "application/vnd.mophun.application", ext: "mpn" }, { mime_type: "application/vnd.mophun.certificate", ext: "mpc" }, { mime_type: "application/vnd.motorola.flexsuite" }, { mime_type: "application/vnd.motorola.flexsuite.adsi" }, { mime_type: "application/vnd.motorola.flexsuite.fis" }, { mime_type: "application/vnd.motorola.flexsuite.gotap" }, { mime_type: "application/vnd.motorola.flexsuite.kmr" }, { mime_type: "application/vnd.motorola.flexsuite.ttc" }, { mime_type: "application/vnd.motorola.flexsuite.wem" }, { mime_type: "application/vnd.motorola.iprm" }, { mime_type: "application/vnd.mozilla.xul+xml", ext: "xul" }, { mime_type: "application/vnd.ms-artgalry", ext: "cil" }, { mime_type: "application/vnd.ms-asf" }, { mime_type: "application/vnd.ms-cab-compressed", ext: "cab" }, { mime_type: "application/vnd.ms-excel", ext: "xls xlm xla xlc xlt xlw" }, { mime_type: "application/vnd.ms-excel.addin.macroenabled.12", ext: "xlam" }, { mime_type: "application/vnd.ms-excel.sheet.binary.macroenabled.12", ext: "xlsb" }, { mime_type: "application/vnd.ms-excel.sheet.macroenabled.12", ext: "xlsm" }, { mime_type: "application/vnd.ms-excel.template.macroenabled.12", ext: "xltm" }, { mime_type: "application/vnd.ms-fontobject", ext: "eot" }, { mime_type: "application/vnd.ms-htmlhelp", ext: "chm" }, { mime_type: "application/vnd.ms-ims", ext: "ims" }, { mime_type: "application/vnd.ms-lrm", ext: "lrm" }, { mime_type: "application/vnd.ms-pki.seccat", ext: "cat" }, { mime_type: "application/vnd.ms-pki.stl", ext: "stl" }, { mime_type: "application/vnd.ms-playready.initiator+xml" }, { mime_type: "application/vnd.ms-powerpoint", ext: "ppt pps pot" }, { mime_type: "application/vnd.ms-powerpoint.addin.macroenabled.12", ext: "ppam" }, { mime_type: "application/vnd.ms-powerpoint.presentation.macroenabled.12", ext: "pptm" }, { mime_type: "application/vnd.ms-powerpoint.slide.macroenabled.12", ext: "sldm" }, { mime_type: "application/vnd.ms-powerpoint.slideshow.macroenabled.12", ext: "ppsm" }, { mime_type: "application/vnd.ms-powerpoint.template.macroenabled.12", ext: "potm" }, { mime_type: "application/vnd.ms-project", ext: "mpp mpt" }, { mime_type: "application/vnd.ms-tnef" }, { mime_type: "application/vnd.ms-wmdrm.lic-chlg-req" }, { mime_type: "application/vnd.ms-wmdrm.lic-resp" }, { mime_type: "application/vnd.ms-wmdrm.meter-chlg-req" }, { mime_type: "application/vnd.ms-wmdrm.meter-resp" }, { mime_type: "application/vnd.ms-word.document.macroenabled.12", ext: "docm" }, { mime_type: "application/vnd.ms-word.template.macroenabled.12", ext: "dotm" }, { mime_type: "application/vnd.ms-works", ext: "wps wks wcm wdb" }, { mime_type: "application/vnd.ms-wpl", ext: "wpl" }, { mime_type: "application/vnd.ms-xpsdocument", ext: "xps" }, { mime_type: "application/vnd.mseq", ext: "mseq" }, { mime_type: "application/vnd.msign" }, { mime_type: "application/vnd.multiad.creator" }, { mime_type: "application/vnd.multiad.creator.cif" }, { mime_type: "application/vnd.music-niff" }, { mime_type: "application/vnd.musician", ext: "mus" }, { mime_type: "application/vnd.muvee.style", ext: "msty" }, { mime_type: "application/vnd.ncd.control" }, { mime_type: "application/vnd.ncd.reference" }, { mime_type: "application/vnd.nervana" }, { mime_type: "application/vnd.netfpx" }, { mime_type: "application/vnd.neurolanguage.nlu", ext: "nlu" }, { mime_type: "application/vnd.noblenet-directory", ext: "nnd" }, { mime_type: "application/vnd.noblenet-sealer", ext: "nns" }, { mime_type: "application/vnd.noblenet-web", ext: "nnw" }, { mime_type: "application/vnd.nokia.catalogs" }, { mime_type: "application/vnd.nokia.conml+wbxml" }, { mime_type: "application/vnd.nokia.conml+xml" }, { mime_type: "application/vnd.nokia.isds-radio-presets" }, { mime_type: "application/vnd.nokia.iptv.config+xml" }, { mime_type: "application/vnd.nokia.landmark+wbxml" }, { mime_type: "application/vnd.nokia.landmark+xml" }, { mime_type: "application/vnd.nokia.landmarkcollection+xml" }, { mime_type: "application/vnd.nokia.n-gage.ac+xml" }, { mime_type: "application/vnd.nokia.n-gage.data", ext: "ngdat" }, { mime_type: "application/vnd.nokia.n-gage.symbian.install", ext: "n-gage" }, { mime_type: "application/vnd.nokia.ncd" }, { mime_type: "application/vnd.nokia.pcd+wbxml" }, { mime_type: "application/vnd.nokia.pcd+xml" }, { mime_type: "application/vnd.nokia.radio-preset", ext: "rpst" }, { mime_type: "application/vnd.nokia.radio-presets", ext: "rpss" }, { mime_type: "application/vnd.novadigm.edm", ext: "edm" }, { mime_type: "application/vnd.novadigm.edx", ext: "edx" }, { mime_type: "application/vnd.novadigm.ext", ext: "ext" }, { mime_type: "application/vnd.oasis.opendocument.chart", ext: "odc" }, { mime_type: "application/vnd.oasis.opendocument.chart-template", ext: "otc" }, { mime_type: "application/vnd.oasis.opendocument.database", ext: "odb" }, { mime_type: "application/vnd.oasis.opendocument.formula", ext: "odf" }, { mime_type: "application/vnd.oasis.opendocument.formula-template", ext: "odft" }, { mime_type: "application/vnd.oasis.opendocument.graphics", ext: "odg" }, { mime_type: "application/vnd.oasis.opendocument.graphics-template", ext: "otg" }, { mime_type: "application/vnd.oasis.opendocument.image", ext: "odi" }, { mime_type: "application/vnd.oasis.opendocument.image-template", ext: "oti" }, { mime_type: "application/vnd.oasis.opendocument.presentation", ext: "odp" }, { mime_type: "application/vnd.oasis.opendocument.presentation-template otp" }, { mime_type: "application/vnd.oasis.opendocument.spreadsheet", ext: "ods" }, { mime_type: "application/vnd.oasis.opendocument.spreadsheet-template", ext: "ots" }, { mime_type: "application/vnd.oasis.opendocument.text", ext: "odt" }, { mime_type: "application/vnd.oasis.opendocument.text-master", ext: "otm" }, { mime_type: "application/vnd.oasis.opendocument.text-template", ext: "ott" }, { mime_type: "application/vnd.oasis.opendocument.text-web", ext: "oth" }, { mime_type: "application/vnd.obn" }, { mime_type: "application/vnd.olpc-sugar", ext: "xo" }, { mime_type: "application/vnd.oma-scws-config" }, { mime_type: "application/vnd.oma-scws-http-request" }, { mime_type: "application/vnd.oma-scws-http-response" }, { mime_type: "application/vnd.oma.bcast.associated-procedure-parameter+xml" }, { mime_type: "application/vnd.oma.bcast.drm-trigger+xml" }, { mime_type: "application/vnd.oma.bcast.imd+xml" }, { mime_type: "application/vnd.oma.bcast.ltkm" }, { mime_type: "application/vnd.oma.bcast.notification+xml" }, { mime_type: "application/vnd.oma.bcast.provisioningtrigger" }, { mime_type: "application/vnd.oma.bcast.sgboot" }, { mime_type: "application/vnd.oma.bcast.sgdd+xml" }, { mime_type: "application/vnd.oma.bcast.sgdu" }, { mime_type: "application/vnd.oma.bcast.simple-symbol-container" }, { mime_type: "application/vnd.oma.bcast.smartcard-trigger+xml" }, { mime_type: "application/vnd.oma.bcast.sprov+xml" }, { mime_type: "application/vnd.oma.bcast.stkm" }, { mime_type: "application/vnd.oma.dcd" }, { mime_type: "application/vnd.oma.dcdc" }, { mime_type: "application/vnd.oma.dd2+xml", ext: "dd2" }, { mime_type: "application/vnd.oma.drm.risd+xml" }, { mime_type: "application/vnd.oma.group-usage-list+xml" }, { mime_type: "application/vnd.oma.poc.detailed-progress-report+xml" }, { mime_type: "application/vnd.oma.poc.final-report+xml" }, { mime_type: "application/vnd.oma.poc.groups+xml" }, { mime_type: "application/vnd.oma.poc.invocation-descriptor+xml" }, { mime_type: "application/vnd.oma.poc.optimized-progress-report+xml" }, { mime_type: "application/vnd.oma.xcap-directory+xml" }, { mime_type: "application/vnd.omads-email+xml" }, { mime_type: "application/vnd.omads-file+xml" }, { mime_type: "application/vnd.omads-folder+xml" }, { mime_type: "application/vnd.omaloc-supl-init" }, { mime_type: "application/vnd.openofficeorg.extension", ext: "oxt" }, { mime_type: "application/vnd.openxmlformats-officedocument.presentationml.presentation", ext: "pptx" }, { mime_type: "application/vnd.openxmlformats-officedocument.presentationml.slide", ext: "sldx" }, { mime_type: "application/vnd.openxmlformats-officedocument.presentationml.slideshow", ext: "ppsx" }, { mime_type: "application/vnd.openxmlformats-officedocument.presentationml.template", ext: "potx" }, { mime_type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", ext: "xlsx" }, { mime_type: "application/vnd.openxmlformats-officedocument.spreadsheetml.template", ext: "xltx" }, { mime_type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document", ext: "docx" }, { mime_type: "application/vnd.openxmlformats-officedocument.wordprocessingml.template", ext: "dotx" }, { mime_type: "application/vnd.osa.netdeploy" }, { mime_type: "application/vnd.osgi.bundle" }, { mime_type: "application/vnd.osgi.dp", ext: "dp" }, { mime_type: "application/vnd.otps.ct-kip+xml" }, { mime_type: "application/vnd.palm", ext: "pdb pqa oprc" }, { mime_type: "application/vnd.paos.xml" }, { mime_type: "application/vnd.pg.format", ext: "str" }, { mime_type: "application/vnd.pg.osasli", ext: "ei6" }, { mime_type: "application/vnd.piaccess.application-licence" }, { mime_type: "application/vnd.picsel", ext: "efif" }, { mime_type: "application/vnd.poc.group-advertisement+xml" }, { mime_type: "application/vnd.pocketlearn", ext: "plf" }, { mime_type: "application/vnd.powerbuilder6", ext: "pbd" }, { mime_type: "application/vnd.powerbuilder6-s" }, { mime_type: "application/vnd.powerbuilder7" }, { mime_type: "application/vnd.powerbuilder7-s" }, { mime_type: "application/vnd.powerbuilder75" }, { mime_type: "application/vnd.powerbuilder75-s" }, { mime_type: "application/vnd.preminet" }, { mime_type: "application/vnd.previewsystems.box", ext: "box" }, { mime_type: "application/vnd.proteus.magazine", ext: "mgz" }, { mime_type: "application/vnd.publishare-delta-tree", ext: "qps" }, { mime_type: "application/vnd.pvi.ptid1", ext: "ptid" }, { mime_type: "application/vnd.pwg-multiplexed" }, { mime_type: "application/vnd.pwg-xhtml-print+xml" }, { mime_type: "application/vnd.qualcomm.brew-app-res" }, { mime_type: "application/vnd.quark.quarkxpress", ext: "qxd qxt qwd qwt qxl qxb" }, { mime_type: "application/vnd.rapid" }, { mime_type: "application/vnd.recordare.musicxml", ext: "mxl" }, { mime_type: "application/vnd.recordare.musicxml+xml", ext: "musicxml" }, { mime_type: "application/vnd.renlearn.rlprint" }, { mime_type: "application/vnd.rim.cod", ext: "cod" }, { mime_type: "application/vnd.rn-realmedia", ext: "rm" }, { mime_type: "application/vnd.route66.link66+xml", ext: "link66" }, { mime_type: "application/vnd.ruckus.download" }, { mime_type: "application/vnd.s3sms" }, { mime_type: "application/vnd.sbm.cid" }, { mime_type: "application/vnd.sbm.mid2" }, { mime_type: "application/vnd.scribus" }, { mime_type: "application/vnd.sealed.3df" }, { mime_type: "application/vnd.sealed.csf" }, { mime_type: "application/vnd.sealed.doc" }, { mime_type: "application/vnd.sealed.eml" }, { mime_type: "application/vnd.sealed.mht" }, { mime_type: "application/vnd.sealed.net" }, { mime_type: "application/vnd.sealed.ppt" }, { mime_type: "application/vnd.sealed.tiff" }, { mime_type: "application/vnd.sealed.xls" }, { mime_type: "application/vnd.sealedmedia.softseal.html" }, { mime_type: "application/vnd.sealedmedia.softseal.pdf" }, { mime_type: "application/vnd.seemail", ext: "see" }, { mime_type: "application/vnd.sema", ext: "sema" }, { mime_type: "application/vnd.semd", ext: "semd" }, { mime_type: "application/vnd.semf", ext: "semf" }, { mime_type: "application/vnd.shana.informed.formdata", ext: "ifm" }, { mime_type: "application/vnd.shana.informed.formtemplate", ext: "itp" }, { mime_type: "application/vnd.shana.informed.interchange", ext: "iif" }, { mime_type: "application/vnd.shana.informed.package", ext: "ipk" }, { mime_type: "application/vnd.simtech-mindmapper", ext: "twd twds" }, { mime_type: "application/vnd.smaf", ext: "mmf" }, { mime_type: "application/vnd.smart.teacher", ext: "teacher" }, { mime_type: "application/vnd.software602.filler.form+xml" }, { mime_type: "application/vnd.software602.filler.form-xml-zip" }, { mime_type: "application/vnd.solent.sdkm+xml", ext: "sdkm sdkd" }, { mime_type: "application/vnd.spotfire.dxp", ext: "dxp" }, { mime_type: "application/vnd.spotfire.sfs", ext: "sfs" }, { mime_type: "application/vnd.sss-cod" }, { mime_type: "application/vnd.sss-dtf" }, { mime_type: "application/vnd.sss-ntf" }, { mime_type: "application/vnd.stardivision.calc", ext: "sdc" }, { mime_type: "application/vnd.stardivision.draw", ext: "sda" }, { mime_type: "application/vnd.stardivision.impress", ext: "sdd" }, { mime_type: "application/vnd.stardivision.math", ext: "smf" }, { mime_type: "application/vnd.stardivision.writer", ext: "sdw" }, { mime_type: "application/vnd.stardivision.writer", ext: "vor" }, { mime_type: "application/vnd.stardivision.writer-global", ext: "sgl" }, { mime_type: "application/vnd.street-stream" }, { mime_type: "application/vnd.sun.xml.calc", ext: "sxc" }, { mime_type: "application/vnd.sun.xml.calc.template", ext: "stc" }, { mime_type: "application/vnd.sun.xml.draw", ext: "sxd" }, { mime_type: "application/vnd.sun.xml.draw.template", ext: "std" }, { mime_type: "application/vnd.sun.xml.impress", ext: "sxi" }, { mime_type: "application/vnd.sun.xml.impress.template", ext: "sti" }, { mime_type: "application/vnd.sun.xml.math", ext: "sxm" }, { mime_type: "application/vnd.sun.xml.writer", ext: "sxw" }, { mime_type: "application/vnd.sun.xml.writer.global", ext: "sxg" }, { mime_type: "application/vnd.sun.xml.writer.template", ext: "stw" }, { mime_type: "application/vnd.sun.wadl+xml" }, { mime_type: "application/vnd.sus-calendar", ext: "sus susp" }, { mime_type: "application/vnd.svd", ext: "svd" }, { mime_type: "application/vnd.swiftview-ics" }, { mime_type: "application/vnd.symbian.install", ext: "sis sisx" }, { mime_type: "application/vnd.syncml+xml", ext: "xsm" }, { mime_type: "application/vnd.syncml.dm+wbxml", ext: "bdm" }, { mime_type: "application/vnd.syncml.dm+xml", ext: "xdm" }, { mime_type: "application/vnd.syncml.dm.notification" }, { mime_type: "application/vnd.syncml.ds.notification" }, { mime_type: "application/vnd.tao.intent-module-archive", ext: "tao" }, { mime_type: "application/vnd.tmobile-livetv", ext: "tmo" }, { mime_type: "application/vnd.trid.tpt", ext: "tpt" }, { mime_type: "application/vnd.triscape.mxs", ext: "mxs" }, { mime_type: "application/vnd.trueapp", ext: "tra" }, { mime_type: "application/vnd.truedoc" }, { mime_type: "application/vnd.ufdl", ext: "ufd ufdl" }, { mime_type: "application/vnd.uiq.theme", ext: "utz" }, { mime_type: "application/vnd.umajin", ext: "umj" }, { mime_type: "application/vnd.unity", ext: "unityweb" }, { mime_type: "application/vnd.uoml+xml", ext: "uoml" }, { mime_type: "application/vnd.uplanet.alert" }, { mime_type: "application/vnd.uplanet.alert-wbxml" }, { mime_type: "application/vnd.uplanet.bearer-choice" }, { mime_type: "application/vnd.uplanet.bearer-choice-wbxml" }, { mime_type: "application/vnd.uplanet.cacheop" }, { mime_type: "application/vnd.uplanet.cacheop-wbxml" }, { mime_type: "application/vnd.uplanet.channel" }, { mime_type: "application/vnd.uplanet.channel-wbxml" }, { mime_type: "application/vnd.uplanet.list" }, { mime_type: "application/vnd.uplanet.list-wbxml" }, { mime_type: "application/vnd.uplanet.listcmd" }, { mime_type: "application/vnd.uplanet.listcmd-wbxml" }, { mime_type: "application/vnd.uplanet.signal" }, { mime_type: "application/vnd.vcx", ext: "vcx" }, { mime_type: "application/vnd.vd-study" }, { mime_type: "application/vnd.vectorworks" }, { mime_type: "application/vnd.vidsoft.vidconference" }, { mime_type: "application/vnd.visio", ext: "vsd vst vss vsw" }, { mime_type: "application/vnd.visionary", ext: "vis" }, { mime_type: "application/vnd.vividence.scriptfile" }, { mime_type: "application/vnd.vsf", ext: "vsf" }, { mime_type: "application/vnd.wap.sic" }, { mime_type: "application/vnd.wap.slc" }, { mime_type: "application/vnd.wap.wbxml", ext: "wbxml" }, { mime_type: "application/vnd.wap.wmlc", ext: "wmlc" }, { mime_type: "application/vnd.wap.wmlscriptc", ext: "wmlsc" }, { mime_type: "application/vnd.webturbo", ext: "wtb" }, { mime_type: "application/vnd.wfa.wsc" }, { mime_type: "application/vnd.wmc" }, { mime_type: "application/vnd.wmf.bootstrap" }, { mime_type: "application/vnd.wordperfect", ext: "wpd" }, { mime_type: "application/vnd.wqd", ext: "wqd" }, { mime_type: "application/vnd.wrq-hp3000-labelled" }, { mime_type: "application/vnd.wt.stf", ext: "stf" }, { mime_type: "application/vnd.wv.csp+wbxml" }, { mime_type: "application/vnd.wv.csp+xml" }, { mime_type: "application/vnd.wv.ssp+xml" }, { mime_type: "application/vnd.xara", ext: "xar" }, { mime_type: "application/vnd.xfdl", ext: "xfdl" }, { mime_type: "application/vnd.xfdl.webform" }, { mime_type: "application/vnd.xmi+xml" }, { mime_type: "application/vnd.xmpie.cpkg" }, { mime_type: "application/vnd.xmpie.dpkg" }, { mime_type: "application/vnd.xmpie.plan" }, { mime_type: "application/vnd.xmpie.ppkg" }, { mime_type: "application/vnd.xmpie.xlim" }, { mime_type: "application/vnd.yamaha.hv-dic", ext: "hvd" }, { mime_type: "application/vnd.yamaha.hv-script", ext: "hvs" }, { mime_type: "application/vnd.yamaha.hv-voice", ext: "hvp" }, { mime_type: "application/vnd.yamaha.openscoreformat", ext: "osf" }, { mime_type: "application/vnd.yamaha.openscoreformat.osfpvg+xml", ext: "osfpvg" }, { mime_type: "application/vnd.yamaha.smaf-audio", ext: "saf" }, { mime_type: "application/vnd.yamaha.smaf-phrase", ext: "spf" }, { mime_type: "application/vnd.yellowriver-custom-menu", ext: "cmp" }, { mime_type: "application/vnd.zul", ext: "zir zirz" }, { mime_type: "application/vnd.zzazz.deck+xml", ext: "zaz" }, { mime_type: "application/voicexml+xml", ext: "vxml" }, { mime_type: "application/watcherinfo+xml" }, { mime_type: "application/whoispp-query" }, { mime_type: "application/whoispp-response" }, { mime_type: "application/winhlp", ext: "hlp" }, { mime_type: "application/wita" }, { mime_type: "application/wordperfect5.1" }, { mime_type: "application/wsdl+xml", ext: "wsdl" }, { mime_type: "application/wspolicy+xml", ext: "wspolicy" }, { mime_type: "application/x-abiword", ext: "abw" }, { mime_type: "application/x-ace-compressed", ext: "ace" }, { mime_type: "application/x-authorware-bin", ext: "aab x32 u32 vox" }, { mime_type: "application/x-authorware-map", ext: "aam" }, { mime_type: "application/x-authorware-seg", ext: "aas" }, { mime_type: "application/x-bcpio", ext: "bcpio" }, { mime_type: "application/x-bittorrent", ext: "torrent" }, { mime_type: "application/x-bzip", ext: "bz" }, { mime_type: "application/x-bzip2", ext: "bz2 boz" }, { mime_type: "application/x-cdlink", ext: "vcd" }, { mime_type: "application/x-chat", ext: "chat" }, { mime_type: "application/x-chess-pgn", ext: "pgn" }, { mime_type: "application/x-compress" }, { mime_type: "application/x-cpio", ext: "cpio" }, { mime_type: "application/x-csh", ext: "csh" }, { mime_type: "application/x-debian-package", ext: "deb udeb" }, { mime_type: "application/x-director", ext: "dir dcr dxr cst cct cxt w3d fgd swa" }, { mime_type: "application/x-doom", ext: "wad" }, { mime_type: "application/x-dtbncx+xml", ext: "ncx" }, { mime_type: "application/x-dtbook+xml", ext: "dtb" }, { mime_type: "application/x-dtbresource+xml", ext: "res" }, { mime_type: "application/x-dvi", ext: "dvi" }, { mime_type: "application/x-font-bdf", ext: "bdf" }, { mime_type: "application/x-font-dos" }, { mime_type: "application/x-font-framemaker" }, { mime_type: "application/x-font-ghostscript", ext: "gsf" }, { mime_type: "application/x-font-libgrx" }, { mime_type: "application/x-font-linux-psf", ext: "psf" }, { mime_type: "application/x-font-otf", ext: "otf" }, { mime_type: "application/x-font-pcf", ext: "pcf" }, { mime_type: "application/x-font-snf", ext: "snf" }, { mime_type: "application/x-font-speedo" }, { mime_type: "application/x-font-sunos-news" }, { mime_type: "application/x-font-ttf", ext: "ttf ttc" }, { mime_type: "application/x-font-type1", ext: "pfa pfb pfm afm" }, { mime_type: "application/x-font-vfont" }, { mime_type: "application/x-futuresplash", ext: "spl" }, { mime_type: "application/x-gnumeric", ext: "gnumeric" }, { mime_type: "application/x-gtar", ext: "gtar" }, { mime_type: "application/x-gzip" }, { mime_type: "application/x-hdf", ext: "hdf" }, { mime_type: "application/x-java-jnlp-file", ext: "jnlp" }, { mime_type: "application/x-latex", ext: "latex" }, { mime_type: "application/x-mobipocket-ebook", ext: "prc mobi" }, { mime_type: "application/x-ms-application", ext: "application" }, { mime_type: "application/x-ms-wmd", ext: "wmd" }, { mime_type: "application/x-ms-wmz", ext: "wmz" }, { mime_type: "application/x-ms-xbap", ext: "xbap" }, { mime_type: "application/x-msaccess", ext: "mdb" }, { mime_type: "application/x-msbinder", ext: "obd" }, { mime_type: "application/x-mscardfile", ext: "crd" }, { mime_type: "application/x-msclip", ext: "clp" }, { mime_type: "application/x-msdownload", ext: "exe dll com bat msi" }, { mime_type: "application/x-msmediaview", ext: "mvb m13 m14" }, { mime_type: "application/x-msmetafile", ext: "wmf" }, { mime_type: "application/x-msmoney", ext: "mny" }, { mime_type: "application/x-mspublisher", ext: "pub" }, { mime_type: "application/x-msschedule", ext: "scd" }, { mime_type: "application/x-msterminal", ext: "trm" }, { mime_type: "application/x-mswrite", ext: "wri" }, { mime_type: "application/x-netcdf", ext: "nc cdf" }, { mime_type: "application/x-pkcs12", ext: "p12 pfx" }, { mime_type: "application/x-pkcs7-certificates", ext: "p7b spc" }, { mime_type: "application/x-pkcs7-certreqresp", ext: "p7r" }, { mime_type: "application/x-rar-compressed", ext: "rar" }, { mime_type: "application/x-sh", ext: "sh" }, { mime_type: "application/x-shar", ext: "shar" }, { mime_type: "application/x-shockwave-flash", ext: "swf" }, { mime_type: "application/x-silverlight-app", ext: "xap" }, { mime_type: "application/x-stuffit", ext: "sit" }, { mime_type: "application/x-stuffitx", ext: "sitx" }, { mime_type: "application/x-sv4cpio", ext: "sv4cpio" }, { mime_type: "application/x-sv4crc", ext: "sv4crc" }, { mime_type: "application/x-tar", ext: "tar" }, { mime_type: "application/x-tcl", ext: "tcl" }, { mime_type: "application/x-tex", ext: "tex" }, { mime_type: "application/x-tex-tfm", ext: "tfm" }, { mime_type: "application/x-texinfo", ext: "texinfo texi" }, { mime_type: "application/x-ustar", ext: "ustar" }, { mime_type: "application/x-wais-source", ext: "src" }, { mime_type: "application/x-x509-ca-cert", ext: "der crt" }, { mime_type: "application/x-xfig", ext: "fig" }, { mime_type: "application/x-xpinstall", ext: "xpi" }, { mime_type: "application/x400-bp" }, { mime_type: "application/xcap-att+xml" }, { mime_type: "application/xcap-caps+xml" }, { mime_type: "application/xcap-el+xml" }, { mime_type: "application/xcap-error+xml" }, { mime_type: "application/xcap-ns+xml" }, { mime_type: "application/xcon-conference-info-diff+xml" }, { mime_type: "application/xcon-conference-info+xml" }, { mime_type: "application/xenc+xml", ext: "xenc" }, { mime_type: "application/xhtml+xml", ext: "xhtml xht" }, { mime_type: "application/xhtml-voice+xml" }, { mime_type: "application/xml", ext: "xml xsl" }, { mime_type: "application/xml-dtd", ext: "dtd" }, { mime_type: "application/xml-external-parsed-entity" }, { mime_type: "application/xmpp+xml" }, { mime_type: "application/xop+xml", ext: "xop" }, { mime_type: "application/xslt+xml", ext: "xslt" }, { mime_type: "application/xspf+xml", ext: "xspf" }, { mime_type: "application/xv+xml", ext: "mxml xhvml xvml xvm" }, { mime_type: "application/zip", ext: "zip" }, { mime_type: "audio/32kadpcm" }, { mime_type: "audio/3gpp" }, { mime_type: "audio/3gpp2" }, { mime_type: "audio/ac3" }, { mime_type: "audio/adpcm", ext: "adp" }, { mime_type: "audio/amr" }, { mime_type: "audio/amr-wb" }, { mime_type: "audio/amr-wb+" }, { mime_type: "audio/asc" }, { mime_type: "audio/basic", ext: "au snd" }, { mime_type: "audio/bv16" }, { mime_type: "audio/bv32" }, { mime_type: "audio/clearmode" }, { mime_type: "audio/cn" }, { mime_type: "audio/dat12" }, { mime_type: "audio/dls" }, { mime_type: "audio/dsr-es201108" }, { mime_type: "audio/dsr-es202050" }, { mime_type: "audio/dsr-es202211" }, { mime_type: "audio/dsr-es202212" }, { mime_type: "audio/dvi4" }, { mime_type: "audio/eac3" }, { mime_type: "audio/evrc" }, { mime_type: "audio/evrc-qcp" }, { mime_type: "audio/evrc0" }, { mime_type: "audio/evrc1" }, { mime_type: "audio/evrcb" }, { mime_type: "audio/evrcb0" }, { mime_type: "audio/evrcb1" }, { mime_type: "audio/evrcwb" }, { mime_type: "audio/evrcwb0" }, { mime_type: "audio/evrcwb1" }, { mime_type: "audio/example" }, { mime_type: "audio/g719" }, { mime_type: "audio/g722" }, { mime_type: "audio/g7221" }, { mime_type: "audio/g723" }, { mime_type: "audio/g726-16" }, { mime_type: "audio/g726-24" }, { mime_type: "audio/g726-32" }, { mime_type: "audio/g726-40" }, { mime_type: "audio/g728" }, { mime_type: "audio/g729" }, { mime_type: "audio/g7291" }, { mime_type: "audio/g729d" }, { mime_type: "audio/g729e" }, { mime_type: "audio/gsm" }, { mime_type: "audio/gsm-efr" }, { mime_type: "audio/ilbc" }, { mime_type: "audio/l16" }, { mime_type: "audio/l20" }, { mime_type: "audio/l24" }, { mime_type: "audio/l8" }, { mime_type: "audio/lpc" }, { mime_type: "audio/midi", ext: "mid midi kar rmi" }, { mime_type: "audio/mobile-xmf" }, { mime_type: "audio/mp4", ext: "mp4a" }, { mime_type: "audio/mp4a-latm", ext: "m4a m4p" }, { mime_type: "audio/mpa" }, { mime_type: "audio/mpa-robust" }, { mime_type: "audio/mpeg", ext: "mpga mp2 mp2a mp3 m2a m3a" }, { mime_type: "audio/mpeg4-generic" }, { mime_type: "audio/ogg", ext: "oga ogg spx" }, { mime_type: "audio/parityfec" }, { mime_type: "audio/pcma" }, { mime_type: "audio/pcma-wb" }, { mime_type: "audio/pcmu-wb" }, { mime_type: "audio/pcmu" }, { mime_type: "audio/prs.sid" }, { mime_type: "audio/qcelp" }, { mime_type: "audio/red" }, { mime_type: "audio/rtp-enc-aescm128" }, { mime_type: "audio/rtp-midi" }, { mime_type: "audio/rtx" }, { mime_type: "audio/smv" }, { mime_type: "audio/smv0" }, { mime_type: "audio/smv-qcp" }, { mime_type: "audio/sp-midi" }, { mime_type: "audio/t140c" }, { mime_type: "audio/t38" }, { mime_type: "audio/telephone-event" }, { mime_type: "audio/tone" }, { mime_type: "audio/ulpfec" }, { mime_type: "audio/vdvi" }, { mime_type: "audio/vmr-wb" }, { mime_type: "audio/vnd.3gpp.iufp" }, { mime_type: "audio/vnd.4sb" }, { mime_type: "audio/vnd.audiokoz" }, { mime_type: "audio/vnd.celp" }, { mime_type: "audio/vnd.cisco.nse" }, { mime_type: "audio/vnd.cmles.radio-events" }, { mime_type: "audio/vnd.cns.anp1" }, { mime_type: "audio/vnd.cns.inf1" }, { mime_type: "audio/vnd.digital-winds", ext: "eol" }, { mime_type: "audio/vnd.dlna.adts" }, { mime_type: "audio/vnd.dolby.heaac.1" }, { mime_type: "audio/vnd.dolby.heaac.2" }, { mime_type: "audio/vnd.dolby.mlp" }, { mime_type: "audio/vnd.dolby.mps" }, { mime_type: "audio/vnd.dolby.pl2" }, { mime_type: "audio/vnd.dolby.pl2x" }, { mime_type: "audio/vnd.dolby.pl2z" }, { mime_type: "audio/vnd.dts", ext: "dts" }, { mime_type: "audio/vnd.dts.hd", ext: "dtshd" }, { mime_type: "audio/vnd.everad.plj" }, { mime_type: "audio/vnd.hns.audio" }, { mime_type: "audio/vnd.lucent.voice", ext: "lvp" }, { mime_type: "audio/vnd.ms-playready.media.pya", ext: "pya" }, { mime_type: "audio/vnd.nokia.mobile-xmf" }, { mime_type: "audio/vnd.nortel.vbk" }, { mime_type: "audio/vnd.nuera.ecelp4800", ext: "ecelp4800" }, { mime_type: "audio/vnd.nuera.ecelp7470", ext: "ecelp7470" }, { mime_type: "audio/vnd.nuera.ecelp9600", ext: "ecelp9600" }, { mime_type: "audio/vnd.octel.sbc" }, { mime_type: "audio/vnd.qcelp" }, { mime_type: "audio/vnd.rhetorex.32kadpcm" }, { mime_type: "audio/vnd.sealedmedia.softseal.mpeg" }, { mime_type: "audio/vnd.vmx.cvsd" }, { mime_type: "audio/vorbis" }, { mime_type: "audio/vorbis-config" }, { mime_type: "audio/x-aac", ext: "aac" }, { mime_type: "audio/x-aiff", ext: "aif aiff aifc" }, { mime_type: "audio/x-mpegurl", ext: "m3u" }, { mime_type: "audio/x-ms-wax", ext: "wax" }, { mime_type: "audio/x-ms-wma", ext: "wma" }, { mime_type: "audio/x-pn-realaudio", ext: "ram ra" }, { mime_type: "audio/x-pn-realaudio-plugin", ext: "rmp" }, { mime_type: "audio/x-wav", ext: "wav" }, { mime_type: "chemical/x-cdx", ext: "cdx" }, { mime_type: "chemical/x-cif", ext: "cif" }, { mime_type: "chemical/x-cmdf", ext: "cmdf" }, { mime_type: "chemical/x-cml", ext: "cml" }, { mime_type: "chemical/x-csml", ext: "csml" }, { mime_type: "chemical/x-pdb" }, { mime_type: "chemical/x-xyz", ext: "xyz" }, { mime_type: "image/bmp", ext: "bmp" }, { mime_type: "image/cgm", ext: "cgm" }, { mime_type: "image/example" }, { mime_type: "image/fits" }, { mime_type: "image/g3fax", ext: "g3" }, { mime_type: "image/gif", ext: "gif" }, { mime_type: "image/ief", ext: "ief" }, { mime_type: "image/jp2", ext: "jp2" }, { mime_type: "image/jpeg", ext: "jpeg jpg jpe" }, { mime_type: "image/jpm" }, { mime_type: "image/jpx" }, { mime_type: "image/naplps" }, { mime_type: "image/pict", ext: "pict pic pct" }, { mime_type: "image/png", ext: "png" }, { mime_type: "image/prs.btif", ext: "btif" }, { mime_type: "image/prs.pti" }, { mime_type: "image/svg+xml", ext: "svg svgz" }, { mime_type: "image/t38" }, { mime_type: "image/tiff", ext: "tiff tif" }, { mime_type: "image/tiff-fx" }, { mime_type: "image/vnd.adobe.photoshop", ext: "psd" }, { mime_type: "image/vnd.cns.inf2" }, { mime_type: "image/vnd.djvu", ext: "djvu djv" }, { mime_type: "image/vnd.dwg", ext: "dwg" }, { mime_type: "image/vnd.dxf", ext: "dxf" }, { mime_type: "image/vnd.fastbidsheet", ext: "fbs" }, { mime_type: "image/vnd.fpx", ext: "fpx" }, { mime_type: "image/vnd.fst", ext: "fst" }, { mime_type: "image/vnd.fujixerox.edmics-mmr", ext: "mmr" }, { mime_type: "image/vnd.fujixerox.edmics-rlc", ext: "rlc" }, { mime_type: "image/vnd.globalgraphics.pgb" }, { mime_type: "image/vnd.microsoft.icon" }, { mime_type: "image/vnd.mix" }, { mime_type: "image/vnd.ms-modi", ext: "mdi" }, { mime_type: "image/vnd.net-fpx", ext: "npx" }, { mime_type: "image/vnd.radiance" }, { mime_type: "image/vnd.sealed.png" }, { mime_type: "image/vnd.sealedmedia.softseal.gif" }, { mime_type: "image/vnd.sealedmedia.softseal.jpg" }, { mime_type: "image/vnd.svf" }, { mime_type: "image/vnd.wap.wbmp", ext: "wbmp" }, { mime_type: "image/vnd.xiff", ext: "xif" }, { mime_type: "image/x-cmu-raster", ext: "ras" }, { mime_type: "image/x-cmx", ext: "cmx" }, { mime_type: "image/x-freehand", ext: "fh fhc fh4 fh5 fh7" }, { mime_type: "image/x-icon", ext: "ico" }, { mime_type: "image/x-macpaint", ext: "pntg pnt mac" }, { mime_type: "image/x-pcx", ext: "pcx" }, { mime_type: "image/x-portable-anymap", ext: "pnm" }, { mime_type: "image/x-portable-bitmap", ext: "pbm" }, { mime_type: "image/x-portable-graymap", ext: "pgm" }, { mime_type: "image/x-portable-pixmap", ext: "ppm" }, { mime_type: "image/x-quicktime", ext: "qtif qti" }, { mime_type: "image/x-rgb", ext: "rgb" }, { mime_type: "image/x-xbitmap", ext: "xbm" }, { mime_type: "image/x-xpixmap", ext: "xpm" }, { mime_type: "image/x-xwindowdump", ext: "xwd" }, { mime_type: "message/cpim" }, { mime_type: "message/delivery-status" }, { mime_type: "message/disposition-notification" }, { mime_type: "message/example" }, { mime_type: "message/external-body" }, { mime_type: "message/global" }, { mime_type: "message/global-delivery-status" }, { mime_type: "message/global-disposition-notification" }, { mime_type: "message/global-headers" }, { mime_type: "message/http" }, { mime_type: "message/imdn+xml" }, { mime_type: "message/news" }, { mime_type: "message/partial" }, { mime_type: "message/rfc822", ext: "eml mime" }, { mime_type: "message/s-http" }, { mime_type: "message/sip" }, { mime_type: "message/sipfrag" }, { mime_type: "message/tracking-status" }, { mime_type: "message/vnd.si.simp" }, { mime_type: "model/example" }, { mime_type: "model/iges", ext: "igs iges" }, { mime_type: "model/mesh", ext: "msh mesh silo" }, { mime_type: "model/vnd.dwf", ext: "dwf" }, { mime_type: "model/vnd.flatland.3dml" }, { mime_type: "model/vnd.gdl", ext: "gdl" }, { mime_type: "model/vnd.gs-gdl" }, { mime_type: "model/vnd.gs.gdl" }, { mime_type: "model/vnd.gtw", ext: "gtw" }, { mime_type: "model/vnd.moml+xml" }, { mime_type: "model/vnd.mts", ext: "mts" }, { mime_type: "model/vnd.parasolid.transmit.binary" }, { mime_type: "model/vnd.parasolid.transmit.text" }, { mime_type: "model/vnd.vtu", ext: "vtu" }, { mime_type: "model/vrml", ext: "wrl vrml" }, { mime_type: "multipart/alternative" }, { mime_type: "multipart/appledouble" }, { mime_type: "multipart/byteranges" }, { mime_type: "multipart/digest" }, { mime_type: "multipart/encrypted" }, { mime_type: "multipart/example" }, { mime_type: "multipart/form-data" }, { mime_type: "multipart/header-set" }, { mime_type: "multipart/mixed" }, { mime_type: "multipart/parallel" }, { mime_type: "multipart/related" }, { mime_type: "multipart/report" }, { mime_type: "multipart/signed" }, { mime_type: "multipart/voice-message" }, { mime_type: "text/calendar", ext: "ics ifb" }, { mime_type: "text/css", ext: "css" }, { mime_type: "text/csv", ext: "csv" }, { mime_type: "text/directory" }, { mime_type: "text/dns" }, { mime_type: "text/ecmascript" }, { mime_type: "text/enriched" }, { mime_type: "text/example" }, { mime_type: "text/html", ext: "html htm" }, { mime_type: "text/javascript" }, { mime_type: "text/parityfec" }, { mime_type: "text/plain", ext: "txt text conf def list log in" }, { mime_type: "text/prs.fallenstein.rst" }, { mime_type: "text/prs.lines.tag", ext: "dsc" }, { mime_type: "text/red" }, { mime_type: "text/rfc822-headers" }, { mime_type: "text/richtext", ext: "rtx" }, { mime_type: "text/rtf" }, { mime_type: "text/rtp-enc-aescm128" }, { mime_type: "text/rtx" }, { mime_type: "text/sgml", ext: "sgml sgm" }, { mime_type: "text/t140" }, { mime_type: "text/tab-separated-values", ext: "tsv" }, { mime_type: "text/troff", ext: "t tr roff man me ms" }, { mime_type: "text/ulpfec" }, { mime_type: "text/uri-list", ext: "uri uris urls" }, { mime_type: "text/vnd.abc" }, { mime_type: "text/vnd.curl", ext: "curl" }, { mime_type: "text/vnd.curl.dcurl", ext: "dcurl" }, { mime_type: "text/vnd.curl.scurl", ext: "scurl" }, { mime_type: "text/vnd.curl.mcurl", ext: "mcurl" }, { mime_type: "text/vnd.dmclientscript" }, { mime_type: "text/vnd.esmertec.theme-descriptor" }, { mime_type: "text/vnd.fly", ext: "fly" }, { mime_type: "text/vnd.fmi.flexstor", ext: "flx" }, { mime_type: "text/vnd.graphviz", ext: "gv" }, { mime_type: "text/vnd.in3d.3dml", ext: "3dml" }, { mime_type: "text/vnd.in3d.spot", ext: "spot" }, { mime_type: "text/vnd.iptc.newsml" }, { mime_type: "text/vnd.iptc.nitf" }, { mime_type: "text/vnd.latex-z" }, { mime_type: "text/vnd.motorola.reflex" }, { mime_type: "text/vnd.ms-mediapackage" }, { mime_type: "text/vnd.net2phone.commcenter.command" }, { mime_type: "text/vnd.si.uricatalogue" }, { mime_type: "text/vnd.sun.j2me.app-descriptor", ext: "jad" }, { mime_type: "text/vnd.trolltech.linguist" }, { mime_type: "text/vnd.wap.si" }, { mime_type: "text/vnd.wap.sl" }, { mime_type: "text/vnd.wap.wml", ext: "wml" }, { mime_type: "text/vnd.wap.wmlscript", ext: "wmls" }, { mime_type: "text/x-asm", ext: "s asm" }, { mime_type: "text/x-c", ext: "c cc cxx cpp h hh dic" }, { mime_type: "text/x-fortran", ext: "f for f77 f90" }, { mime_type: "text/x-pascal", ext: "p pas" }, { mime_type: "text/x-java-source", ext: "java" }, { mime_type: "text/x-setext", ext: "etx" }, { mime_type: "text/x-uuencode", ext: "uu" }, { mime_type: "text/x-vcalendar", ext: "vcs" }, { mime_type: "text/x-vcard", ext: "vcf" }, { mime_type: "text/xml" }, { mime_type: "text/xml-external-parsed-entity" }, { mime_type: "video/3gpp", ext: "3gp" }, { mime_type: "video/3gpp-tt" }, { mime_type: "video/3gpp2", ext: "3g2" }, { mime_type: "video/bmpeg" }, { mime_type: "video/bt656" }, { mime_type: "video/celb" }, { mime_type: "video/dv" }, { mime_type: "video/example" }, { mime_type: "video/h261", ext: "h261" }, { mime_type: "video/h263", ext: "h263" }, { mime_type: "video/h263-1998" }, { mime_type: "video/h263-2000" }, { mime_type: "video/h264", ext: "h264" }, { mime_type: "video/jpeg", ext: "jpgv" }, { mime_type: "video/jpeg2000" }, { mime_type: "video/jpm", ext: "jpm jpgm" }, { mime_type: "video/mj2", ext: "mj2 mjp2" }, { mime_type: "video/mp1s" }, { mime_type: "video/mp2p" }, { mime_type: "video/mp2t" }, { mime_type: "video/mp4", ext: "mp4 mp4v mpg4 m4v" }, { mime_type: "video/mp4v-es" }, { mime_type: "video/mpeg", ext: "mpeg mpg mpe m1v m2v" }, { mime_type: "video/mpeg4-generic" }, { mime_type: "video/mpv" }, { mime_type: "video/nv" }, { mime_type: "video/ogg", ext: "ogv" }, { mime_type: "video/parityfec" }, { mime_type: "video/pointer" }, { mime_type: "video/quicktime", ext: "qt mov" }, { mime_type: "video/raw" }, { mime_type: "video/rtp-enc-aescm128" }, { mime_type: "video/rtx" }, { mime_type: "video/smpte292m" }, { mime_type: "video/ulpfec" }, { mime_type: "video/vc1" }, { mime_type: "video/vnd.cctv" }, { mime_type: "video/vnd.dlna.mpeg-tts" }, { mime_type: "video/vnd.fvt", ext: "fvt" }, { mime_type: "video/vnd.hns.video" }, { mime_type: "video/vnd.iptvforum.1dparityfec-1010" }, { mime_type: "video/vnd.iptvforum.1dparityfec-2005" }, { mime_type: "video/vnd.iptvforum.2dparityfec-1010" }, { mime_type: "video/vnd.iptvforum.2dparityfec-2005" }, { mime_type: "video/vnd.iptvforum.ttsavc" }, { mime_type: "video/vnd.iptvforum.ttsmpeg2" }, { mime_type: "video/vnd.motorola.video" }, { mime_type: "video/vnd.motorola.videop" }, { mime_type: "video/vnd.mpegurl", ext: "mxu m4u" }, { mime_type: "video/vnd.ms-playready.media.pyv", ext: "pyv" }, { mime_type: "video/vnd.nokia.interleaved-multimedia" }, { mime_type: "video/vnd.nokia.videovoip" }, { mime_type: "video/vnd.objectvideo" }, { mime_type: "video/vnd.sealed.mpeg1" }, { mime_type: "video/vnd.sealed.mpeg4" }, { mime_type: "video/vnd.sealed.swf" }, { mime_type: "video/vnd.sealedmedia.softseal.mov" }, { mime_type: "video/vnd.vivo", ext: "viv" }, { mime_type: "video/x-dv", ext: "dv dif" }, { mime_type: "video/x-f4v", ext: "f4v" }, { mime_type: "video/x-fli", ext: "fli" }, { mime_type: "video/x-flv", ext: "flv" }, { mime_type: "video/x-ms-asf", ext: "asf asx" }, { mime_type: "video/x-ms-wm", ext: "wm" }, { mime_type: "video/x-ms-wmv", ext: "wmv" }, { mime_type: "video/x-ms-wmx", ext: "wmx" }, { mime_type: "video/x-ms-wvx", ext: "wvx" }, { mime_type: "video/x-msvideo", ext: "avi" }, { mime_type: "video/x-sgi-movie", ext: "movie" }, { mime_type: "x-conference/x-cooltalk", ext: "ice" }] };
    var ic = Ko("splice");
    var nc = Math.max;
    var ac = Math.min;
    Me({ target: "Array", proto: true, forced: !ic }, { splice: function(e2, t2) {
      var i2, n2, a2, p2, r2, o2, m2 = kt(this), c2 = xe(m2.length), l2 = ge(e2, c2), s2 = arguments.length;
      if (0 === s2 ? i2 = n2 = 0 : 1 === s2 ? (i2 = 0, n2 = c2 - l2) : (i2 = s2 - 2, n2 = ac(nc(ye(t2), 0), c2 - l2)), c2 + i2 - n2 > 9007199254740991)
        throw TypeError("Maximum allowed length exceeded");
      for (a2 = Rn(m2, n2), p2 = 0; p2 < n2; p2++)
        (r2 = l2 + p2) in m2 && Lp(a2, p2, m2[r2]);
      if (a2.length = n2, i2 < n2) {
        for (p2 = l2; p2 < c2 - n2; p2++)
          o2 = p2 + i2, (r2 = p2 + n2) in m2 ? m2[o2] = m2[r2] : delete m2[o2];
        for (p2 = c2; p2 > c2 - n2 + i2; p2--)
          delete m2[p2 - 1];
      } else if (i2 > n2)
        for (p2 = c2 - n2; p2 > l2; p2--)
          o2 = p2 + i2 - 1, (r2 = p2 + n2 - 1) in m2 ? m2[o2] = m2[r2] : delete m2[o2];
      for (p2 = 0; p2 < i2; p2++)
        m2[p2 + l2] = arguments[p2 + 2];
      return m2.length = c2 - n2 + i2, a2;
    } });
    var pc = wm.trim;
    Me({ target: "String", proto: true, forced: function(e2) {
      return t(function() {
        return !!xm[e2]() || "​᠎" != "​᠎"[e2]() || xm[e2].name !== e2;
      });
    }("trim") }, { trim: function() {
      return pc(this);
    } });
    var rc = !t(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
    var oc = a(function(e2) {
      var t2 = y.f, i2 = Z("meta"), n2 = 0, a2 = Object.isExtensible || function() {
        return true;
      }, p2 = function(e3) {
        t2(e3, i2, { value: { objectID: "O" + ++n2, weakData: {} } });
      }, r2 = e2.exports = { REQUIRED: false, fastKey: function(e3, t3) {
        if (!o(e3))
          return "symbol" == typeof e3 ? e3 : ("string" == typeof e3 ? "S" : "P") + e3;
        if (!F(e3, i2)) {
          if (!a2(e3))
            return "F";
          if (!t3)
            return "E";
          p2(e3);
        }
        return e3[i2].objectID;
      }, getWeakData: function(e3, t3) {
        if (!F(e3, i2)) {
          if (!a2(e3))
            return true;
          if (!t3)
            return false;
          p2(e3);
        }
        return e3[i2].weakData;
      }, onFreeze: function(e3) {
        return rc && r2.REQUIRED && a2(e3) && !F(e3, i2) && p2(e3), e3;
      } };
      te[i2] = true;
    }).onFreeze;
    var mc = Object.freeze;
    var cc = t(function() {
      mc(1);
    });
    Me({ target: "Object", stat: true, forced: cc, sham: !rc }, { freeze: function(e2) {
      return mc && o(e2) ? mc(oc(e2)) : e2;
    } });
    var lc = Object.freeze({ ADDED: "ADDED", QUEUED: "QUEUED", UPLOADING: "UPLOADING", ERROR: "ERROR", DONE: "DONE" });
    var sc = Ko("slice");
    var dc = st("species");
    var uc = [].slice;
    var fc = Math.max;
    function yc(e2, t2, i2, n2, a2, p2, r2) {
      try {
        var o2 = e2[p2](r2), m2 = o2.value;
      } catch (e3) {
        return void i2(e3);
      }
      o2.done ? t2(m2) : Promise.resolve(m2).then(n2, a2);
    }
    Me({ target: "Array", proto: true, forced: !sc }, { slice: function(e2, t2) {
      var i2, n2, a2, p2 = z(this), r2 = xe(p2.length), m2 = ge(e2, r2), c2 = ge(void 0 === t2 ? r2 : t2, r2);
      if (Tn(p2) && ("function" != typeof (i2 = p2.constructor) || i2 !== Array && !Tn(i2.prototype) ? o(i2) && null === (i2 = i2[dc]) && (i2 = void 0) : i2 = void 0, i2 === Array || void 0 === i2))
        return uc.call(p2, m2, c2);
      for (n2 = new (void 0 === i2 ? Array : i2)(fc(c2 - m2, 0)), a2 = 0; m2 < c2; m2++, a2++)
        m2 in p2 && Lp(n2, a2, p2[m2]);
      return n2.length = a2, n2;
    } }), a(function(e2) {
      !function(t2) {
        var i2, n2 = Object.prototype, a2 = n2.hasOwnProperty, p2 = "function" == typeof Symbol ? Symbol : {}, r2 = p2.iterator || "@@iterator", o2 = p2.asyncIterator || "@@asyncIterator", m2 = p2.toStringTag || "@@toStringTag", c2 = t2.regeneratorRuntime;
        if (c2)
          e2.exports = c2;
        else {
          (c2 = t2.regeneratorRuntime = e2.exports).wrap = h2;
          var l2 = "suspendedStart", s2 = "suspendedYield", d2 = "executing", u2 = "completed", f2 = {}, y2 = {};
          y2[r2] = function() {
            return this;
          };
          var v2 = Object.getPrototypeOf, x2 = v2 && v2(v2(I2([])));
          x2 && x2 !== n2 && a2.call(x2, r2) && (y2 = x2);
          var _2 = k2.prototype = b2.prototype = Object.create(y2);
          w2.prototype = _2.constructor = k2, k2.constructor = w2, k2[m2] = w2.displayName = "GeneratorFunction", c2.isGeneratorFunction = function(e3) {
            var t3 = "function" == typeof e3 && e3.constructor;
            return !!t3 && (t3 === w2 || "GeneratorFunction" === (t3.displayName || t3.name));
          }, c2.mark = function(e3) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e3, k2) : (e3.__proto__ = k2, m2 in e3 || (e3[m2] = "GeneratorFunction")), e3.prototype = Object.create(_2), e3;
          }, c2.awrap = function(e3) {
            return { __await: e3 };
          }, A2(E2.prototype), E2.prototype[o2] = function() {
            return this;
          }, c2.AsyncIterator = E2, c2.async = function(e3, t3, i3, n3) {
            var a3 = new E2(h2(e3, t3, i3, n3));
            return c2.isGeneratorFunction(t3) ? a3 : a3.next().then(function(e4) {
              return e4.done ? e4.value : a3.next();
            });
          }, A2(_2), _2[m2] = "Generator", _2[r2] = function() {
            return this;
          }, _2.toString = function() {
            return "[object Generator]";
          }, c2.keys = function(e3) {
            var t3 = [];
            for (var i3 in e3)
              t3.push(i3);
            return t3.reverse(), function i4() {
              for (; t3.length; ) {
                var n3 = t3.pop();
                if (n3 in e3)
                  return i4.value = n3, i4.done = false, i4;
              }
              return i4.done = true, i4;
            };
          }, c2.values = I2, T2.prototype = { constructor: T2, reset: function(e3) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = i2, this.done = false, this.delegate = null, this.method = "next", this.arg = i2, this.tryEntries.forEach(O2), !e3)
              for (var t3 in this)
                "t" === t3.charAt(0) && a2.call(this, t3) && !isNaN(+t3.slice(1)) && (this[t3] = i2);
          }, stop: function() {
            this.done = true;
            var e3 = this.tryEntries[0].completion;
            if ("throw" === e3.type)
              throw e3.arg;
            return this.rval;
          }, dispatchException: function(e3) {
            if (this.done)
              throw e3;
            var t3 = this;
            function n3(n4, a3) {
              return o3.type = "throw", o3.arg = e3, t3.next = n4, a3 && (t3.method = "next", t3.arg = i2), !!a3;
            }
            for (var p3 = this.tryEntries.length - 1; p3 >= 0; --p3) {
              var r3 = this.tryEntries[p3], o3 = r3.completion;
              if ("root" === r3.tryLoc)
                return n3("end");
              if (r3.tryLoc <= this.prev) {
                var m3 = a2.call(r3, "catchLoc"), c3 = a2.call(r3, "finallyLoc");
                if (m3 && c3) {
                  if (this.prev < r3.catchLoc)
                    return n3(r3.catchLoc, true);
                  if (this.prev < r3.finallyLoc)
                    return n3(r3.finallyLoc);
                } else if (m3) {
                  if (this.prev < r3.catchLoc)
                    return n3(r3.catchLoc, true);
                } else {
                  if (!c3)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < r3.finallyLoc)
                    return n3(r3.finallyLoc);
                }
              }
            }
          }, abrupt: function(e3, t3) {
            for (var i3 = this.tryEntries.length - 1; i3 >= 0; --i3) {
              var n3 = this.tryEntries[i3];
              if (n3.tryLoc <= this.prev && a2.call(n3, "finallyLoc") && this.prev < n3.finallyLoc) {
                var p3 = n3;
                break;
              }
            }
            p3 && ("break" === e3 || "continue" === e3) && p3.tryLoc <= t3 && t3 <= p3.finallyLoc && (p3 = null);
            var r3 = p3 ? p3.completion : {};
            return r3.type = e3, r3.arg = t3, p3 ? (this.method = "next", this.next = p3.finallyLoc, f2) : this.complete(r3);
          }, complete: function(e3, t3) {
            if ("throw" === e3.type)
              throw e3.arg;
            return "break" === e3.type || "continue" === e3.type ? this.next = e3.arg : "return" === e3.type ? (this.rval = this.arg = e3.arg, this.method = "return", this.next = "end") : "normal" === e3.type && t3 && (this.next = t3), f2;
          }, finish: function(e3) {
            for (var t3 = this.tryEntries.length - 1; t3 >= 0; --t3) {
              var i3 = this.tryEntries[t3];
              if (i3.finallyLoc === e3)
                return this.complete(i3.completion, i3.afterLoc), O2(i3), f2;
            }
          }, catch: function(e3) {
            for (var t3 = this.tryEntries.length - 1; t3 >= 0; --t3) {
              var i3 = this.tryEntries[t3];
              if (i3.tryLoc === e3) {
                var n3 = i3.completion;
                if ("throw" === n3.type) {
                  var a3 = n3.arg;
                  O2(i3);
                }
                return a3;
              }
            }
            throw new Error("illegal catch attempt");
          }, delegateYield: function(e3, t3, n3) {
            return this.delegate = { iterator: I2(e3), resultName: t3, nextLoc: n3 }, "next" === this.method && (this.arg = i2), f2;
          } };
        }
        function h2(e3, t3, i3, n3) {
          var a3 = t3 && t3.prototype instanceof b2 ? t3 : b2, p3 = Object.create(a3.prototype), r3 = new T2(n3 || []);
          return p3._invoke = /* @__PURE__ */ function(e4, t4, i4) {
            var n4 = l2;
            return function(a4, p4) {
              if (n4 === d2)
                throw new Error("Generator is already running");
              if (n4 === u2) {
                if ("throw" === a4)
                  throw p4;
                return R2();
              }
              for (i4.method = a4, i4.arg = p4; ; ) {
                var r4 = i4.delegate;
                if (r4) {
                  var o3 = S2(r4, i4);
                  if (o3) {
                    if (o3 === f2)
                      continue;
                    return o3;
                  }
                }
                if ("next" === i4.method)
                  i4.sent = i4._sent = i4.arg;
                else if ("throw" === i4.method) {
                  if (n4 === l2)
                    throw n4 = u2, i4.arg;
                  i4.dispatchException(i4.arg);
                } else
                  "return" === i4.method && i4.abrupt("return", i4.arg);
                n4 = d2;
                var m3 = g2(e4, t4, i4);
                if ("normal" === m3.type) {
                  if (n4 = i4.done ? u2 : s2, m3.arg === f2)
                    continue;
                  return { value: m3.arg, done: i4.done };
                }
                "throw" === m3.type && (n4 = u2, i4.method = "throw", i4.arg = m3.arg);
              }
            };
          }(e3, i3, r3), p3;
        }
        function g2(e3, t3, i3) {
          try {
            return { type: "normal", arg: e3.call(t3, i3) };
          } catch (e4) {
            return { type: "throw", arg: e4 };
          }
        }
        function b2() {
        }
        function w2() {
        }
        function k2() {
        }
        function A2(e3) {
          ["next", "throw", "return"].forEach(function(t3) {
            e3[t3] = function(e4) {
              return this._invoke(t3, e4);
            };
          });
        }
        function E2(e3) {
          function t3(i4, n3, p3, r3) {
            var o3 = g2(e3[i4], e3, n3);
            if ("throw" !== o3.type) {
              var m3 = o3.arg, c3 = m3.value;
              return c3 && "object" == typeof c3 && a2.call(c3, "__await") ? Promise.resolve(c3.__await).then(function(e4) {
                t3("next", e4, p3, r3);
              }, function(e4) {
                t3("throw", e4, p3, r3);
              }) : Promise.resolve(c3).then(function(e4) {
                m3.value = e4, p3(m3);
              }, r3);
            }
            r3(o3.arg);
          }
          var i3;
          this._invoke = function(e4, n3) {
            function a3() {
              return new Promise(function(i4, a4) {
                t3(e4, n3, i4, a4);
              });
            }
            return i3 = i3 ? i3.then(a3, a3) : a3();
          };
        }
        function S2(e3, t3) {
          var n3 = e3.iterator[t3.method];
          if (n3 === i2) {
            if (t3.delegate = null, "throw" === t3.method) {
              if (e3.iterator.return && (t3.method = "return", t3.arg = i2, S2(e3, t3), "throw" === t3.method))
                return f2;
              t3.method = "throw", t3.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return f2;
          }
          var a3 = g2(n3, e3.iterator, t3.arg);
          if ("throw" === a3.type)
            return t3.method = "throw", t3.arg = a3.arg, t3.delegate = null, f2;
          var p3 = a3.arg;
          return p3 ? p3.done ? (t3[e3.resultName] = p3.value, t3.next = e3.nextLoc, "return" !== t3.method && (t3.method = "next", t3.arg = i2), t3.delegate = null, f2) : p3 : (t3.method = "throw", t3.arg = new TypeError("iterator result is not an object"), t3.delegate = null, f2);
        }
        function j2(e3) {
          var t3 = { tryLoc: e3[0] };
          1 in e3 && (t3.catchLoc = e3[1]), 2 in e3 && (t3.finallyLoc = e3[2], t3.afterLoc = e3[3]), this.tryEntries.push(t3);
        }
        function O2(e3) {
          var t3 = e3.completion || {};
          t3.type = "normal", delete t3.arg, e3.completion = t3;
        }
        function T2(e3) {
          this.tryEntries = [{ tryLoc: "root" }], e3.forEach(j2, this), this.reset(true);
        }
        function I2(e3) {
          if (e3) {
            var t3 = e3[r2];
            if (t3)
              return t3.call(e3);
            if ("function" == typeof e3.next)
              return e3;
            if (!isNaN(e3.length)) {
              var n3 = -1, p3 = function t4() {
                for (; ++n3 < e3.length; )
                  if (a2.call(e3, n3))
                    return t4.value = e3[n3], t4.done = false, t4;
                return t4.value = i2, t4.done = true, t4;
              };
              return p3.next = p3;
            }
          }
          return { next: R2 };
        }
        function R2() {
          return { value: i2, done: true };
        }
      }(/* @__PURE__ */ function() {
        return this;
      }() || Function("return this")());
    });
    var vc = t(function() {
      sn(1);
    });
    function xc(e2) {
      var t2 = e2.config, i2 = e2.items, n2 = function(e3, n3, a3) {
        var p3 = [];
        Object.values(i2.all).filter(function(t3) {
          return t3.upload && t3.upload.id === e3;
        }).forEach(function(e4) {
          e4.status = lc.ERROR, e4.upload.retryErrorCounter ? e4.upload.retryErrorCounter -= 1 : e4.upload.retryErrorCounter = t2.maxRetryError, p3.push(e4.id);
        }), a3(p3, { errorType: n3.type });
      }, a2 = function(e3, t3, i3, n3, a3, p3, o2, m2) {
        var c2 = e3 + t3 + 1, l2 = i3.file.webkitSlice ? i3.file.webkitSlice(e3, c2) : i3.file.slice(e3, c2);
        n3.onloadend = function(s2) {
          s2.target.readyState === FileReader.DONE && (i3.upload.blob = l2, i3.upload.chunkIndex = Math.floor(c2 / t3), i3.upload.nextSlice = c2, i3.upload.chunkStart = e3, i3.upload.sliceSize = t3, i3.upload.reader = n3, r2(m2, [i3], a3, p3, o2));
        }, n3.readAsDataURL(l2);
      }, p2 = function(e3, t3) {
        var n3;
        void 0 !== t3 && Object.values(i2.all).filter(function(t4) {
          return t4.upload.id === e3;
        }).forEach(function(e4) {
          e4.upload.chunking ? (e4.upload.loadedBytes += t3.loaded, e4.upload.progress = 100 * e4.upload.loadedBytes / e4.file.size) : (n3 = 100 * t3.loaded / t3.total, e4.upload.progress = n3);
        });
      }, r2 = function() {
        var e3, i3 = (e3 = regeneratorRuntime.mark(function e4(i4, r3, o2, m2, c2) {
          var l2, s2, d2, u2, f2, y2, v2, x2, _2, h2, g2;
          return regeneratorRuntime.wrap(function(e5) {
            for (; ; )
              switch (e5.prev = e5.next) {
                case 0:
                  for ((l2 = new XMLHttpRequest()).open(t2.method, t2.url, true), l2.timeout = t2.xhrTimeout, l2.withCredentials = t2.withCredentials, l2.ontimeout = function(e6) {
                    n2(i4, e6, m2);
                  }, l2.onerror = function(e6) {
                    n2(i4, e6, m2);
                  }, s2 = { Accept: "application/json", "Cache-Control": "no-cache", "X-Requested-With": "XMLHttpRequest" }, d2 = Object.keys(s2), u2 = 0; u2 < d2.length; u2 += 1)
                    f2 = d2[u2], l2.setRequestHeader(f2, s2[f2]);
                  if (t2.headers)
                    for (d2 = Object.keys(t2.headers), y2 = 0; y2 < d2.length; y2 += 1)
                      v2 = d2[y2], "string" != typeof (x2 = t2.headers[v2]) && "number" != typeof x2 || l2.setRequestHeader(v2, x2);
                  return (null != l2.upload ? l2.upload : l2).onprogress = function(e6) {
                    return p2(i4, e6);
                  }, _2 = new FormData(), e5.next = 15, c2(Object.values(r3).filter(function(e6) {
                    return e6.upload.id === i4;
                  }), l2, _2);
                case 15:
                  for (h2 = 0; h2 < r3.length; h2 += 1)
                    (g2 = r3[h2]).upload.id === i4 && (g2.upload.chunking ? (_2.set("fileName", g2.file.name), _2.set("chunkIndex", g2.upload.chunkIndex), _2.set(t2.paramName, g2.upload.blob, g2.file.name)) : _2.append(t2.paramName, g2.file, g2.file.name), g2.status = lc.UPLOADING);
                  l2.onload = function(e6) {
                    var t3;
                    if (4 === l2.readyState) {
                      if ("arraybuffer" !== l2.responseType && "blob" !== l2.responseType && (t3 = l2.responseText, l2.getResponseHeader("content-type") && ~l2.getResponseHeader("content-type").indexOf("application/json")))
                        try {
                          t3 = JSON.parse(t3);
                        } catch (e7) {
                          t3 = "Invalid JSON response from server.";
                        }
                      if (l2.status >= 200 && l2.status < 300) {
                        var p3 = true;
                        Object.values(r3).filter(function(e7) {
                          return e7.upload.id === i4;
                        }).forEach(function(e7) {
                          e7.upload.chunking ? e7.upload.nextSlice < e7.file.size ? (p3 = false, a2(e7.upload.nextSlice, e7.upload.sliceSize, e7, e7.upload.reader, o2, m2, c2, e7.upload.id)) : (e7.status = lc.DONE, e7.upload.progress = 100) : e7.status = lc.DONE;
                        }), true === p3 && o2(r3);
                      } else
                        n2(i4, e6, m2);
                    }
                  }, l2.send(_2);
                case 18:
                case "end":
                  return e5.stop();
              }
          }, e4);
        }), function() {
          var t3 = this, i4 = arguments;
          return new Promise(function(n3, a3) {
            var p3 = e3.apply(t3, i4);
            function r3(e4) {
              yc(p3, n3, a3, r3, o2, "next", e4);
            }
            function o2(e4) {
              yc(p3, n3, a3, r3, o2, "throw", e4);
            }
            r3(void 0);
          });
        });
        return function(e4, t3, n3, a3, p3) {
          return i3.apply(this, arguments);
        };
      }();
      return { upload: function(e3, i3, n3, a3) {
        for (var p3 = im(), o2 = false, m2 = 0; m2 < e3.length; m2 += 1) {
          var c2 = e3[m2];
          (c2.status === lc.QUEUED || t2.retryOnError && c2.status === lc.ERROR && c2.upload.retryErrorCounter > 0) && (c2.upload.id = p3, o2 = true);
        }
        o2 && r2(p3, e3, i3, n3, a3);
      }, uploadWithChunking: function(e3, i3, n3, p3) {
        var r3 = im();
        e3.upload.id = r3, e3.upload.chunking = true, e3.upload.loadedBytes = 0;
        var o2 = new FileReader(), m2 = e3.file.size / t2.numberOfChunks;
        a2(0, m2, e3, o2, i3, n3, p3, r3);
      } };
    }
    Me({ target: "Object", stat: true, forced: vc }, { keys: function(e2) {
      return sn(kt(e2));
    } }), _t("match", 1, function(e2, t2, i2) {
      return [function(t3) {
        var i3 = U(this), n2 = null == t3 ? void 0 : t3[e2];
        return void 0 !== n2 ? n2.call(t3, i3) : new RegExp(t3)[e2](String(i3));
      }, function(e3) {
        var n2 = i2(t2, e3, this);
        if (n2.done)
          return n2.value;
        var a2 = d(e3), p2 = String(this);
        if (!a2.global)
          return Tt(a2, p2);
        var r2 = a2.unicode;
        a2.lastIndex = 0;
        for (var o2, m2 = [], c2 = 0; null !== (o2 = Tt(a2, p2)); ) {
          var l2 = String(o2[0]);
          m2[c2] = l2, "" === l2 && (a2.lastIndex = wt(p2, xe(a2.lastIndex), r2)), c2++;
        }
        return 0 === c2 ? null : m2;
      }];
    });
    var _c = [];
    var hc = false;
    function gc(e2) {
      var t2 = function() {
        hc || 0 === _c.length || (hc = true, function(t3) {
          var i2 = new FileReader();
          i2.addEventListener("load", function() {
            e2(t3.id, i2.result);
          }, false), i2.readAsDataURL(t3.file);
        }(_c.shift()), hc = false);
      };
      return { enqueueThumbnail: function(e3, i2) {
        (/\.(jpe?g|png|gif)$/i.test(i2.name) || i2.type.match("image.*")) && (_c.push({ id: e3, file: i2 }), setTimeout(function() {
          return t2();
        }, 0));
      } };
    }
    function bc(t2) {
      var i2 = t2.config, n2 = t2.context, a2 = e.reactive({ ids: [], all: {} }), p2 = gc(function(e2, t3) {
        a2.all[e2].thumbnail = t3;
      }).enqueueThumbnail, r2 = function(t3) {
        var i3 = t3.config, n3 = t3.items, a3 = t3.context, p3 = function t4() {
          var p4 = xc({ config: i3, items: n3 }), r3 = p4.upload, o3 = p4.uploadWithChunking, m3 = Object.values(n3.all).filter(function(e2) {
            return e2.status === lc.UPLOADING;
          }).length;
          if (!(m3 >= i3.parallelUpload)) {
            var c2 = Object.values(n3.all).filter(function(e2) {
              return e2.status === lc.QUEUED || e2.status === lc.ERROR && i3.retryOnError && e2.upload.retryErrorCounter > 0;
            });
            if (!(c2.length <= 0)) {
              var l2 = function(t5, i4, n4) {
                a3.emit("sending", e.readonly(t5.map(function(e2) {
                  return e2.file;
                })), i4, n4);
              }, s2 = function(n4) {
                i3.autoUpload && t4(), a3.emit("uploaded", e.readonly(n4.map(function(e2) {
                  return e2.file;
                })));
              }, d2 = function(e2, n4) {
                i3.autoUpload && t4(), a3.emit("error-upload", w({ ids: A(e2) }, n4));
              }, u2 = m3;
              if (i3.chunking)
                o3(c2.shift(), s2, d2, l2);
              else if (i3.multipleUpload)
                r3(c2.slice(0, i3.parallelUpload - m3), s2, d2, l2);
              else
                for (; u2 <= i3.parallelUpload; ) {
                  if (c2.length <= 0)
                    return;
                  r3([c2.shift()], s2, d2, l2), u2 += 1;
                }
            }
          }
        };
        return { enqueueFile: function(e2) {
          if (-1 === n3.ids.findIndex(function(t5) {
            return t5 === e2;
          }))
            throw new Error("File with ".concat(e2, " does not exist "));
          var t4 = n3.all[e2];
          if (t4.status !== lc.ADDED || true !== t4.accepted)
            throw new Error("File ".concat(e2, " already in ").concat(e2.status, " state"));
          t4.status = lc.QUEUED, i3.autoUpload && setTimeout(function() {
            return p3();
          }, 0);
        }, processQueue: p3 };
      }({ config: i2, items: a2, context: n2 }), o2 = r2.enqueueFile, m2 = r2.processQueue;
      return { itemManager: { getItems: function() {
        return a2;
      }, removeFile: function(e2) {
        var t3 = a2.ids.findIndex(function(t4) {
          return t4 === e2;
        });
        if (!(t3 < 0)) {
          a2.ids.splice(t3, 1);
          var i3 = a2.all[e2];
          delete a2.all[e2], n2.emit("removed-file", { file: i3.file, status: i3.status, id: e2 });
        }
      }, addFile: function(e2, t3) {
        i2.maxFileSize && t3.size > i2.maxFileSize ? n2.emit("error-add", { files: [t3], error: "MAX_FILE_SIZE" }) : !function(e3) {
          if (null === i2.accepts || 0 === i2.accepts.length)
            return true;
          var t4 = e3.type, n3 = -1 !== i2.accepts.findIndex(function(e4) {
            return e4.trim() === t4.trim();
          });
          if (!n3) {
            var a3 = e3.name.split(".");
            if (a3.length > 1) {
              var p3 = a3[a3.length - 1], r3 = tc.data.filter(function(e4) {
                return e4.ext && !!e4.ext.split(/\s/).find(function(e5) {
                  return p3 === e5;
                });
              }).map(function(e4) {
                return e4.mime_type;
              });
              n3 = !!i2.accepts.find(function(e4) {
                return r3.find(function(t5) {
                  return t5 === e4;
                });
              });
            }
          }
          return n3;
        }(t3) ? n2.emit("error-add", { files: [t3], error: "INVALID_TYPE" }) : i2.maxFiles && a2.ids.length + 1 > i2.maxFiles ? n2.emit("error-add", { files: [t3], error: "MAX_FILE" }) : (a2.ids.push(e2), a2.all[e2] = { file: t3, thumbnail: null, upload: { progress: 0 }, status: lc.ADDED, accepted: true, id: e2 }, p2(e2, t3), o2(e2), n2.emit("added-file", { file: a2.all[e2].file, id: e2 }));
      }, processQueue: m2 } };
    }
    var wc = e.defineComponent({ name: "DropZone", emits: ["config-update", "added-file", "removed-file", "error-upload", "uploaded", "sending", "error-add"], props: w(w({}, Nm), {}, { dropzoneRef: { default: "dropzone" }, dropzoneClassName: { default: "dropzone__box" }, dropzoneMessageClassName: { default: "dropzone__message--style" }, dropzoneItemClassName: { default: "dropzone__item--style" }, dropzoneDetailsClassName: { default: "dropzone__details--style" } }), setup: function(t2, i2) {
      var n2 = e.ref(), a2 = e.ref(false), p2 = fm(), r2 = p2.initHiddenFileInput, o2 = p2.destroyHiddenFileInput, m2 = p2.setMultiple, c2 = function(t3) {
        var i3 = t3.props, n3 = t3.context, a3 = t3.setMultiple, p3 = e.reactive({ paramName: i3.paramName, headers: i3.headers, xhrTimeout: i3.xhrTimeout, withCredentials: i3.withCredentials, url: i3.url ? i3.url : null !== window.URL ? window.URL : window.webkitURL, method: i3.method, maxFiles: i3.maxFiles, maxFileSize: i3.maxFileSize, autoUpload: i3.uploadOnDrop, parallelUpload: i3.parallelUpload, hiddenInputContainer: i3.hiddenInputContainer, clickable: i3.clickable, acceptedFiles: i3.acceptedFiles, retryOnError: i3.retryOnError, maxRetryError: 3, chunking: i3.chunking, numberOfChunks: i3.numberOfChunks, multipleUpload: !i3.chunking && i3.multipleUpload, dropzoneMessageClassName: i3.dropzoneMessageClassName, accepts: [] }), r3 = function() {
          var e2 = [];
          null !== i3.acceptedFiles && i3.acceptedFiles.forEach(function(t4) {
            tc.data.filter(function(e3) {
              return e3.ext && !!e3.ext.split(/\s/).find(function(e4) {
                return t4 === e4;
              }) || e3.mime_type.startsWith(t4);
            }).forEach(function(t5) {
              e2.push(t5.mime_type), t5.ext && e2.push.apply(e2, A(t5.ext.split(/\s/).map(function(e3) {
                return ".".concat(e3);
              })));
            });
          }), p3.accepts = [].concat(e2);
        }, o3 = function() {
          n3.emit("config-update", w({}, p3));
        };
        return r3(), o3(), e.watch(function() {
          return i3.paramName;
        }, function(e2) {
          p3.paramName !== e2 && (p3.paramName = e2, o3());
        }), e.watch(function() {
          return i3.acceptedFiles;
        }, function(e2) {
          p3.acceptedFiles.every(function(t4) {
            return e2.includes(t4);
          }) || (p3.acceptedFiles = A(e2), r3(), o3());
        }), e.watch(function() {
          return i3.headers;
        }, function(e2) {
          p3.headers !== e2 && (p3.headers = e2, o3());
        }), e.watch(function() {
          return i3.xhrTimeout;
        }, function(e2) {
          p3.xhrTimeout !== e2 && (p3.xhrTimeout = e2, o3());
        }), e.watch(function() {
          return i3.withCredentials;
        }, function(e2) {
          p3.withCredentials !== e2 && (p3.withCredentials = e2, o3());
        }), e.watch(function() {
          return i3.method;
        }, function(e2) {
          p3.method !== e2 && (p3.method = e2, o3());
        }), e.watch(function() {
          return i3.maxFiles;
        }, function(e2) {
          p3.maxFiles !== e2 && (p3.maxFiles = e2, o3());
        }), e.watch(function() {
          return i3.maxFileSize;
        }, function(e2) {
          p3.maxFileSize !== e2 && (p3.maxFileSize = e2, o3(), p3.maxFileSize > 1 ? a3(true) : a3(false));
        }), e.watch(function() {
          return i3.hiddenInputContainer;
        }, function(e2) {
          p3.hiddenInputContainer !== e2 && (p3.hiddenInputContainer = e2, o3());
        }), e.watch(function() {
          return i3.clickable;
        }, function(e2) {
          p3.hiddenInputContainer !== e2 && (p3.clickable = e2, o3());
        }), e.watch(function() {
          return i3.uploadOnDrop;
        }, function(e2) {
          p3.uploadOnDrop !== e2 && (p3.autoUpload = e2, o3());
        }), e.watch(function() {
          return i3.parallelUpload;
        }, function(e2) {
          p3.parallelUpload !== e2 && (p3.parallelUpload = e2, o3());
        }), e.watch(function() {
          return i3.retryOnError;
        }, function(e2) {
          p3.retryOnError !== e2 && (p3.retryOnError = e2, o3());
        }), e.watch(function() {
          return i3.maxRetryError;
        }, function(e2) {
          p3.maxRetryError !== e2 && (p3.maxRetryError = e2, o3());
        }), e.watch(function() {
          return i3.multipleUpload;
        }, function(e2) {
          p3.multipleUpload !== e2 && (p3.multipleUpload = !p3.chunking && e2, o3());
        }), e.watch(function() {
          return i3.numberOfChunks;
        }, function(e2) {
          p3.numberOfChunks !== e2 && (p3.numberOfChunks = e2, o3());
        }), e.watch(function() {
          return i3.chunking;
        }, function(e2) {
          p3.chunking !== e2 && (p3.chunking = e2, p3.multipleUpload = !e2 && p3.multipleUpload, o3());
        }), { config: p3 };
      }({ props: t2, context: i2, setMultiple: m2 }).config, l2 = bc({ config: c2, context: i2 }).itemManager, s2 = mm({ itemManager: l2 }), d2 = s2.handleDragOver, u2 = s2.onDrop;
      return e.watch(function() {
        return l2.getItems();
      }, function(t3) {
        0 === t3.ids.length && e.nextTick(function() {
          o2(), r2({ config: c2, dropzone: n2, itemManager: l2 });
        });
      }, { deep: true }), e.watch(function() {
        return t2.clickable;
      }, function(t3) {
        t3 || e.nextTick(function() {
          o2();
        });
      }, { deep: true }), e.onMounted(function() {
        var e2;
        a2.value = ("draggable" in (e2 = document.createElement("div")) || "ondragstart" in e2 && "ondrop" in e2) && "FormData" in window && "FileReader" in window, r2({ config: c2, dropzone: n2, itemManager: l2 });
      }), e.onUnmounted(function() {
        o2();
      }), w(w({}, e.toRefs(l2.getItems())), {}, { accepts: c2.accepts, onDrop: u2, handleDragOver: d2, removeFile: l2.removeFile, filesize: om, processQueue: l2.processQueue, dropzone: n2 });
    } });
    var kc = e.createTextVNode("Drop here");
    var Ac = { class: "dropzone__item-thumbnail" };
    var Ec = { class: "dropzone__item-controls" };
    var Sc = e.createVNode("i", { class: "gg-close" }, null, -1);
    var jc = { class: "dropzone__progress" };
    var Oc = { class: "dropzone__success-mark" };
    var Tc = e.createVNode("i", { class: "gg-check-o" }, null, -1);
    var Ic = { class: "dropzone__error-mark" };
    var Rc = e.createVNode("i", { class: "gg-danger" }, null, -1);
    var Lc = { class: "dropzone__file-size" };
    var Uc = { class: "dropzone__filename" };
    wc.render = function(t2, i2, n2, a2, p2, r2) {
      return e.openBlock(), e.createBlock("form", { ref: t2.dropzoneRef, class: ["dropzone", [t2.dropzoneClassName]], onDrop: i2[1] || (i2[1] = function() {
        return t2.onDrop && t2.onDrop.apply(t2, arguments);
      }), onDragover: i2[2] || (i2[2] = function() {
        return t2.handleDragOver && t2.handleDragOver.apply(t2, arguments);
      }) }, [0 === t2.ids.length ? (e.openBlock(), e.createBlock("div", { key: 0, class: ["dropzone__message", [t2.dropzoneMessageClassName]] }, [e.renderSlot(t2.$slots, "message", {}, function() {
        return [kc];
      })], 2)) : e.createCommentVNode("v-if", true), (e.openBlock(true), e.createBlock(e.Fragment, null, e.renderList(t2.all, function(i3, n3) {
        return e.openBlock(), e.createBlock("div", { class: ["dropzone__item", [{ "dropzone--has-thumbnail": !!i3.thumbnail, "dropzone--added": "ADDED" === i3.status, "dropzone--processing": "UPLOADING" === i3.status, "dropzone--success": "DONE" === i3.status, "dropzone--has-error": "ERROR" === i3.status }, t2.dropzoneItemClassName]], key: n3 }, [e.createVNode("div", Ac, [i3.thumbnail ? (e.openBlock(), e.createBlock("img", { key: 0, src: i3.thumbnail }, null, 8, ["src"])) : e.createCommentVNode("v-if", true)]), e.createVNode("div", Ec, [e.createVNode("div", { class: "dropzone__item-control", onClick: function(e2) {
          return t2.removeFile(n3);
        } }, [e.renderSlot(t2.$slots, "remove", {}, function() {
          return [Sc];
        })], 8, ["onClick"])]), e.createVNode("div", jc, [e.createVNode("progress", { class: "dropzone__progress-bar", max: "100", value: i3.upload.progress }, null, 8, ["value"])]), e.createVNode("div", Oc, [e.renderSlot(t2.$slots, "success", {}, function() {
          return [Tc];
        })]), e.createVNode("div", Ic, [e.renderSlot(t2.$slots, "error", {}, function() {
          return [Rc];
        })]), e.createVNode("div", { class: ["dropzone__details", [t2.dropzoneDetailsClassName]] }, [e.createVNode("div", Lc, [e.createVNode("span", { innerHTML: t2.filesize(i3.file.size) }, null, 8, ["innerHTML"])]), e.createVNode("div", Uc, [e.createVNode("span", null, e.toDisplayString(i3.file.name), 1)])], 2)], 2);
      }), 128))], 34);
    }, wc.__file = "src/DropZone.vue";
    var zc = function(e2) {
      e2.component(wc.name, wc);
    };
    "undefined" != typeof window && window.Vue && zc(window.Vue), wc.install = zc, module.exports = wc;
  }
});
export default require_dropzone_vue_common();
/*! Bundled license information:

@vue/compiler-core/dist/compiler-core.esm-bundler.js:
  (**
  * @vue/compiler-core v3.4.27
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/compiler-dom/dist/compiler-dom.esm-bundler.js:
  (**
  * @vue/compiler-dom v3.4.27
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

vue/dist/vue.cjs.js:
  (**
  * vue v3.4.27
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

dropzone-vue/dist/dropzone-vue.common.js:
  (**
   * dropzone-vue 0.1.11
   * (c) 2021
   * @license MIT
   *)
*/
//# sourceMappingURL=dropzone-vue.js.map
